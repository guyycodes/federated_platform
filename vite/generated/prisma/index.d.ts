
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Plugin
 * 
 */
export type Plugin = $Result.DefaultSelection<Prisma.$PluginPayload>
/**
 * Model PluginPurchase
 * 
 */
export type PluginPurchase = $Result.DefaultSelection<Prisma.$PluginPurchasePayload>
/**
 * Model PluginUsage
 * 
 */
export type PluginUsage = $Result.DefaultSelection<Prisma.$PluginUsagePayload>
/**
 * Model UserAdministrator
 * 
 */
export type UserAdministrator = $Result.DefaultSelection<Prisma.$UserAdministratorPayload>
/**
 * Model Territory
 * 
 */
export type Territory = $Result.DefaultSelection<Prisma.$TerritoryPayload>
/**
 * Model CSI
 * 
 */
export type CSI = $Result.DefaultSelection<Prisma.$CSIPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model TerritoriesAvailable
 * 
 */
export type TerritoriesAvailable = $Result.DefaultSelection<Prisma.$TerritoriesAvailablePayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model FranchiseFee
 * 
 */
export type FranchiseFee = $Result.DefaultSelection<Prisma.$FranchiseFeePayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model GithubCallback
 * 
 */
export type GithubCallback = $Result.DefaultSelection<Prisma.$GithubCallbackPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CSISource: {
  CUSTOMER: 'CUSTOMER',
  STAFF: 'STAFF',
  MYSTERY_SHOPPER: 'MYSTERY_SHOPPER',
  ONLINE_REVIEW: 'ONLINE_REVIEW',
  PHONE_SURVEY: 'PHONE_SURVEY',
  OTHER: 'OTHER'
};

export type CSISource = (typeof CSISource)[keyof typeof CSISource]


export const PluginCategory: {
  DEVELOPMENT: 'DEVELOPMENT',
  PRODUCTIVITY: 'PRODUCTIVITY',
  ANALYTICS: 'ANALYTICS',
  LANGUAGE: 'LANGUAGE',
  AI_ML: 'AI_ML',
  AUTOMATION: 'AUTOMATION',
  INTEGRATION: 'INTEGRATION',
  OTHER: 'OTHER'
};

export type PluginCategory = (typeof PluginCategory)[keyof typeof PluginCategory]


export const PricingModel: {
  FREEMIUM: 'FREEMIUM',
  ONE_TIME: 'ONE_TIME',
  SUBSCRIPTION: 'SUBSCRIPTION',
  USAGE_BASED: 'USAGE_BASED'
};

export type PricingModel = (typeof PricingModel)[keyof typeof PricingModel]


export const PurchaseType: {
  ONE_TIME: 'ONE_TIME',
  SUBSCRIPTION: 'SUBSCRIPTION'
};

export type PurchaseType = (typeof PurchaseType)[keyof typeof PurchaseType]


export const DeploymentStatus: {
  PENDING: 'PENDING',
  DEVELOPMENT: 'DEVELOPMENT',
  STAGING: 'STAGING',
  PRODUCTION: 'PRODUCTION',
  NEW: 'NEW',
  ERROR: 'ERROR'
};

export type DeploymentStatus = (typeof DeploymentStatus)[keyof typeof DeploymentStatus]


export const UserRole: {
  UNSET: 'UNSET',
  USER_ADMIN: 'USER_ADMIN',
  USER: 'USER',
  LOCATION_ADMIN: 'LOCATION_ADMIN',
  CUSTOMER: 'CUSTOMER',
  STAFF: 'STAFF',
  ACCOUNTANT: 'ACCOUNTANT',
  OTHER: 'OTHER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  FULFILLED: 'FULFILLED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]

}

export type CSISource = $Enums.CSISource

export const CSISource: typeof $Enums.CSISource

export type PluginCategory = $Enums.PluginCategory

export const PluginCategory: typeof $Enums.PluginCategory

export type PricingModel = $Enums.PricingModel

export const PricingModel: typeof $Enums.PricingModel

export type PurchaseType = $Enums.PurchaseType

export const PurchaseType: typeof $Enums.PurchaseType

export type DeploymentStatus = $Enums.DeploymentStatus

export const DeploymentStatus: typeof $Enums.DeploymentStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plugin`: Exposes CRUD operations for the **Plugin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plugins
    * const plugins = await prisma.plugin.findMany()
    * ```
    */
  get plugin(): Prisma.PluginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pluginPurchase`: Exposes CRUD operations for the **PluginPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PluginPurchases
    * const pluginPurchases = await prisma.pluginPurchase.findMany()
    * ```
    */
  get pluginPurchase(): Prisma.PluginPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pluginUsage`: Exposes CRUD operations for the **PluginUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PluginUsages
    * const pluginUsages = await prisma.pluginUsage.findMany()
    * ```
    */
  get pluginUsage(): Prisma.PluginUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAdministrator`: Exposes CRUD operations for the **UserAdministrator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAdministrators
    * const userAdministrators = await prisma.userAdministrator.findMany()
    * ```
    */
  get userAdministrator(): Prisma.UserAdministratorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.territory`: Exposes CRUD operations for the **Territory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Territories
    * const territories = await prisma.territory.findMany()
    * ```
    */
  get territory(): Prisma.TerritoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cSI`: Exposes CRUD operations for the **CSI** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CSIS
    * const cSIS = await prisma.cSI.findMany()
    * ```
    */
  get cSI(): Prisma.CSIDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.territoriesAvailable`: Exposes CRUD operations for the **TerritoriesAvailable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TerritoriesAvailables
    * const territoriesAvailables = await prisma.territoriesAvailable.findMany()
    * ```
    */
  get territoriesAvailable(): Prisma.TerritoriesAvailableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.franchiseFee`: Exposes CRUD operations for the **FranchiseFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FranchiseFees
    * const franchiseFees = await prisma.franchiseFee.findMany()
    * ```
    */
  get franchiseFee(): Prisma.FranchiseFeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.githubCallback`: Exposes CRUD operations for the **GithubCallback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GithubCallbacks
    * const githubCallbacks = await prisma.githubCallback.findMany()
    * ```
    */
  get githubCallback(): Prisma.GithubCallbackDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Plugin: 'Plugin',
    PluginPurchase: 'PluginPurchase',
    PluginUsage: 'PluginUsage',
    UserAdministrator: 'UserAdministrator',
    Territory: 'Territory',
    CSI: 'CSI',
    Location: 'Location',
    TerritoriesAvailable: 'TerritoriesAvailable',
    Customer: 'Customer',
    FranchiseFee: 'FranchiseFee',
    Appointment: 'Appointment',
    Subscription: 'Subscription',
    Product: 'Product',
    Order: 'Order',
    OrderItem: 'OrderItem',
    GithubCallback: 'GithubCallback'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "plugin" | "pluginPurchase" | "pluginUsage" | "userAdministrator" | "territory" | "cSI" | "location" | "territoriesAvailable" | "customer" | "franchiseFee" | "appointment" | "subscription" | "product" | "order" | "orderItem" | "githubCallback"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Plugin: {
        payload: Prisma.$PluginPayload<ExtArgs>
        fields: Prisma.PluginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PluginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PluginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          findFirst: {
            args: Prisma.PluginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PluginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          findMany: {
            args: Prisma.PluginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>[]
          }
          create: {
            args: Prisma.PluginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          createMany: {
            args: Prisma.PluginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PluginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>[]
          }
          delete: {
            args: Prisma.PluginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          update: {
            args: Prisma.PluginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          deleteMany: {
            args: Prisma.PluginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PluginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PluginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>[]
          }
          upsert: {
            args: Prisma.PluginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          aggregate: {
            args: Prisma.PluginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlugin>
          }
          groupBy: {
            args: Prisma.PluginGroupByArgs<ExtArgs>
            result: $Utils.Optional<PluginGroupByOutputType>[]
          }
          count: {
            args: Prisma.PluginCountArgs<ExtArgs>
            result: $Utils.Optional<PluginCountAggregateOutputType> | number
          }
        }
      }
      PluginPurchase: {
        payload: Prisma.$PluginPurchasePayload<ExtArgs>
        fields: Prisma.PluginPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PluginPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PluginPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>
          }
          findFirst: {
            args: Prisma.PluginPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PluginPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>
          }
          findMany: {
            args: Prisma.PluginPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>[]
          }
          create: {
            args: Prisma.PluginPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>
          }
          createMany: {
            args: Prisma.PluginPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PluginPurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>[]
          }
          delete: {
            args: Prisma.PluginPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>
          }
          update: {
            args: Prisma.PluginPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>
          }
          deleteMany: {
            args: Prisma.PluginPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PluginPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PluginPurchaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>[]
          }
          upsert: {
            args: Prisma.PluginPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPurchasePayload>
          }
          aggregate: {
            args: Prisma.PluginPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePluginPurchase>
          }
          groupBy: {
            args: Prisma.PluginPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PluginPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PluginPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PluginPurchaseCountAggregateOutputType> | number
          }
        }
      }
      PluginUsage: {
        payload: Prisma.$PluginUsagePayload<ExtArgs>
        fields: Prisma.PluginUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PluginUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PluginUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>
          }
          findFirst: {
            args: Prisma.PluginUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PluginUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>
          }
          findMany: {
            args: Prisma.PluginUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>[]
          }
          create: {
            args: Prisma.PluginUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>
          }
          createMany: {
            args: Prisma.PluginUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PluginUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>[]
          }
          delete: {
            args: Prisma.PluginUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>
          }
          update: {
            args: Prisma.PluginUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>
          }
          deleteMany: {
            args: Prisma.PluginUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PluginUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PluginUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>[]
          }
          upsert: {
            args: Prisma.PluginUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginUsagePayload>
          }
          aggregate: {
            args: Prisma.PluginUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePluginUsage>
          }
          groupBy: {
            args: Prisma.PluginUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PluginUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PluginUsageCountArgs<ExtArgs>
            result: $Utils.Optional<PluginUsageCountAggregateOutputType> | number
          }
        }
      }
      UserAdministrator: {
        payload: Prisma.$UserAdministratorPayload<ExtArgs>
        fields: Prisma.UserAdministratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAdministratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAdministratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>
          }
          findFirst: {
            args: Prisma.UserAdministratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAdministratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>
          }
          findMany: {
            args: Prisma.UserAdministratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>[]
          }
          create: {
            args: Prisma.UserAdministratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>
          }
          createMany: {
            args: Prisma.UserAdministratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAdministratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>[]
          }
          delete: {
            args: Prisma.UserAdministratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>
          }
          update: {
            args: Prisma.UserAdministratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>
          }
          deleteMany: {
            args: Prisma.UserAdministratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAdministratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAdministratorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>[]
          }
          upsert: {
            args: Prisma.UserAdministratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAdministratorPayload>
          }
          aggregate: {
            args: Prisma.UserAdministratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAdministrator>
          }
          groupBy: {
            args: Prisma.UserAdministratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAdministratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAdministratorCountArgs<ExtArgs>
            result: $Utils.Optional<UserAdministratorCountAggregateOutputType> | number
          }
        }
      }
      Territory: {
        payload: Prisma.$TerritoryPayload<ExtArgs>
        fields: Prisma.TerritoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerritoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerritoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          findFirst: {
            args: Prisma.TerritoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerritoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          findMany: {
            args: Prisma.TerritoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>[]
          }
          create: {
            args: Prisma.TerritoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          createMany: {
            args: Prisma.TerritoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerritoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>[]
          }
          delete: {
            args: Prisma.TerritoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          update: {
            args: Prisma.TerritoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          deleteMany: {
            args: Prisma.TerritoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerritoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TerritoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>[]
          }
          upsert: {
            args: Prisma.TerritoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          aggregate: {
            args: Prisma.TerritoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerritory>
          }
          groupBy: {
            args: Prisma.TerritoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerritoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerritoryCountArgs<ExtArgs>
            result: $Utils.Optional<TerritoryCountAggregateOutputType> | number
          }
        }
      }
      CSI: {
        payload: Prisma.$CSIPayload<ExtArgs>
        fields: Prisma.CSIFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CSIFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CSIFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>
          }
          findFirst: {
            args: Prisma.CSIFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CSIFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>
          }
          findMany: {
            args: Prisma.CSIFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>[]
          }
          create: {
            args: Prisma.CSICreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>
          }
          createMany: {
            args: Prisma.CSICreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CSICreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>[]
          }
          delete: {
            args: Prisma.CSIDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>
          }
          update: {
            args: Prisma.CSIUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>
          }
          deleteMany: {
            args: Prisma.CSIDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CSIUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CSIUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>[]
          }
          upsert: {
            args: Prisma.CSIUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CSIPayload>
          }
          aggregate: {
            args: Prisma.CSIAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCSI>
          }
          groupBy: {
            args: Prisma.CSIGroupByArgs<ExtArgs>
            result: $Utils.Optional<CSIGroupByOutputType>[]
          }
          count: {
            args: Prisma.CSICountArgs<ExtArgs>
            result: $Utils.Optional<CSICountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      TerritoriesAvailable: {
        payload: Prisma.$TerritoriesAvailablePayload<ExtArgs>
        fields: Prisma.TerritoriesAvailableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerritoriesAvailableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerritoriesAvailableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>
          }
          findFirst: {
            args: Prisma.TerritoriesAvailableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerritoriesAvailableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>
          }
          findMany: {
            args: Prisma.TerritoriesAvailableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>[]
          }
          create: {
            args: Prisma.TerritoriesAvailableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>
          }
          createMany: {
            args: Prisma.TerritoriesAvailableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerritoriesAvailableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>[]
          }
          delete: {
            args: Prisma.TerritoriesAvailableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>
          }
          update: {
            args: Prisma.TerritoriesAvailableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>
          }
          deleteMany: {
            args: Prisma.TerritoriesAvailableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerritoriesAvailableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TerritoriesAvailableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>[]
          }
          upsert: {
            args: Prisma.TerritoriesAvailableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoriesAvailablePayload>
          }
          aggregate: {
            args: Prisma.TerritoriesAvailableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerritoriesAvailable>
          }
          groupBy: {
            args: Prisma.TerritoriesAvailableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerritoriesAvailableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerritoriesAvailableCountArgs<ExtArgs>
            result: $Utils.Optional<TerritoriesAvailableCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      FranchiseFee: {
        payload: Prisma.$FranchiseFeePayload<ExtArgs>
        fields: Prisma.FranchiseFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FranchiseFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FranchiseFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>
          }
          findFirst: {
            args: Prisma.FranchiseFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FranchiseFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>
          }
          findMany: {
            args: Prisma.FranchiseFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>[]
          }
          create: {
            args: Prisma.FranchiseFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>
          }
          createMany: {
            args: Prisma.FranchiseFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FranchiseFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>[]
          }
          delete: {
            args: Prisma.FranchiseFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>
          }
          update: {
            args: Prisma.FranchiseFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>
          }
          deleteMany: {
            args: Prisma.FranchiseFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FranchiseFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FranchiseFeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>[]
          }
          upsert: {
            args: Prisma.FranchiseFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchiseFeePayload>
          }
          aggregate: {
            args: Prisma.FranchiseFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFranchiseFee>
          }
          groupBy: {
            args: Prisma.FranchiseFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FranchiseFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FranchiseFeeCountArgs<ExtArgs>
            result: $Utils.Optional<FranchiseFeeCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      GithubCallback: {
        payload: Prisma.$GithubCallbackPayload<ExtArgs>
        fields: Prisma.GithubCallbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GithubCallbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GithubCallbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>
          }
          findFirst: {
            args: Prisma.GithubCallbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GithubCallbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>
          }
          findMany: {
            args: Prisma.GithubCallbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>[]
          }
          create: {
            args: Prisma.GithubCallbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>
          }
          createMany: {
            args: Prisma.GithubCallbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GithubCallbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>[]
          }
          delete: {
            args: Prisma.GithubCallbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>
          }
          update: {
            args: Prisma.GithubCallbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>
          }
          deleteMany: {
            args: Prisma.GithubCallbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GithubCallbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GithubCallbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>[]
          }
          upsert: {
            args: Prisma.GithubCallbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GithubCallbackPayload>
          }
          aggregate: {
            args: Prisma.GithubCallbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGithubCallback>
          }
          groupBy: {
            args: Prisma.GithubCallbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<GithubCallbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.GithubCallbackCountArgs<ExtArgs>
            result: $Utils.Optional<GithubCallbackCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    plugin?: PluginOmit
    pluginPurchase?: PluginPurchaseOmit
    pluginUsage?: PluginUsageOmit
    userAdministrator?: UserAdministratorOmit
    territory?: TerritoryOmit
    cSI?: CSIOmit
    location?: LocationOmit
    territoriesAvailable?: TerritoriesAvailableOmit
    customer?: CustomerOmit
    franchiseFee?: FranchiseFeeOmit
    appointment?: AppointmentOmit
    subscription?: SubscriptionOmit
    product?: ProductOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    githubCallback?: GithubCallbackOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedLocations: number
    locationAccess: number
    createdPlugins: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedLocations?: boolean | UserCountOutputTypeCountOwnedLocationsArgs
    locationAccess?: boolean | UserCountOutputTypeCountLocationAccessArgs
    createdPlugins?: boolean | UserCountOutputTypeCountCreatedPluginsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLocationAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAdministratorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPluginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginWhereInput
  }


  /**
   * Count Type PluginCountOutputType
   */

  export type PluginCountOutputType = {
    purchases: number
    usageRecords: number
    githubCallbacks: number
  }

  export type PluginCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | PluginCountOutputTypeCountPurchasesArgs
    usageRecords?: boolean | PluginCountOutputTypeCountUsageRecordsArgs
    githubCallbacks?: boolean | PluginCountOutputTypeCountGithubCallbacksArgs
  }

  // Custom InputTypes
  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginCountOutputType
     */
    select?: PluginCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginPurchaseWhereInput
  }

  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeCountUsageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginUsageWhereInput
  }

  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeCountGithubCallbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubCallbackWhereInput
  }


  /**
   * Count Type PluginPurchaseCountOutputType
   */

  export type PluginPurchaseCountOutputType = {
    usageRecords: number
  }

  export type PluginPurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageRecords?: boolean | PluginPurchaseCountOutputTypeCountUsageRecordsArgs
  }

  // Custom InputTypes
  /**
   * PluginPurchaseCountOutputType without action
   */
  export type PluginPurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchaseCountOutputType
     */
    select?: PluginPurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PluginPurchaseCountOutputType without action
   */
  export type PluginPurchaseCountOutputTypeCountUsageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginUsageWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    csiRecords: number
    adminUsers: number
    customers: number
    appointments: number
    subscriptions: number
    orders: number
    products: number
    franchiseFees: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    csiRecords?: boolean | LocationCountOutputTypeCountCsiRecordsArgs
    adminUsers?: boolean | LocationCountOutputTypeCountAdminUsersArgs
    customers?: boolean | LocationCountOutputTypeCountCustomersArgs
    appointments?: boolean | LocationCountOutputTypeCountAppointmentsArgs
    subscriptions?: boolean | LocationCountOutputTypeCountSubscriptionsArgs
    orders?: boolean | LocationCountOutputTypeCountOrdersArgs
    products?: boolean | LocationCountOutputTypeCountProductsArgs
    franchiseFees?: boolean | LocationCountOutputTypeCountFranchiseFeesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountCsiRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CSIWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAdminUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAdministratorWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountFranchiseFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FranchiseFeeWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    appointments: number
    subscriptions: number
    orders: number
    csiRecords: number
    pluginPurchases: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | CustomerCountOutputTypeCountAppointmentsArgs
    subscriptions?: boolean | CustomerCountOutputTypeCountSubscriptionsArgs
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    csiRecords?: boolean | CustomerCountOutputTypeCountCsiRecordsArgs
    pluginPurchases?: boolean | CustomerCountOutputTypeCountPluginPurchasesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCsiRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CSIWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPluginPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginPurchaseWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    clerkUserId: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    hasCustomerAccount: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    clerkUserId: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    hasCustomerAccount: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    phone: number
    clerkUserId: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    hasCustomerAccount: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    clerkUserId?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    hasCustomerAccount?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    clerkUserId?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    hasCustomerAccount?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    clerkUserId?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    hasCustomerAccount?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    phone: string | null
    clerkUserId: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    hasCustomerAccount: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    clerkUserId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasCustomerAccount?: boolean
    ownedLocations?: boolean | User$ownedLocationsArgs<ExtArgs>
    locationAccess?: boolean | User$locationAccessArgs<ExtArgs>
    customerAccount?: boolean | User$customerAccountArgs<ExtArgs>
    createdPlugins?: boolean | User$createdPluginsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    clerkUserId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasCustomerAccount?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    clerkUserId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasCustomerAccount?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    clerkUserId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasCustomerAccount?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "phone" | "clerkUserId" | "role" | "isActive" | "createdAt" | "updatedAt" | "hasCustomerAccount", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedLocations?: boolean | User$ownedLocationsArgs<ExtArgs>
    locationAccess?: boolean | User$locationAccessArgs<ExtArgs>
    customerAccount?: boolean | User$customerAccountArgs<ExtArgs>
    createdPlugins?: boolean | User$createdPluginsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ownedLocations: Prisma.$LocationPayload<ExtArgs>[]
      locationAccess: Prisma.$UserAdministratorPayload<ExtArgs>[]
      customerAccount: Prisma.$CustomerPayload<ExtArgs> | null
      createdPlugins: Prisma.$PluginPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string
      lastName: string
      phone: string | null
      clerkUserId: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      hasCustomerAccount: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedLocations<T extends User$ownedLocationsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locationAccess<T extends User$locationAccessArgs<ExtArgs> = {}>(args?: Subset<T, User$locationAccessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerAccount<T extends User$customerAccountArgs<ExtArgs> = {}>(args?: Subset<T, User$customerAccountArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdPlugins<T extends User$createdPluginsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPluginsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly clerkUserId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly hasCustomerAccount: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.ownedLocations
   */
  export type User$ownedLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * User.locationAccess
   */
  export type User$locationAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    where?: UserAdministratorWhereInput
    orderBy?: UserAdministratorOrderByWithRelationInput | UserAdministratorOrderByWithRelationInput[]
    cursor?: UserAdministratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAdministratorScalarFieldEnum | UserAdministratorScalarFieldEnum[]
  }

  /**
   * User.customerAccount
   */
  export type User$customerAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * User.createdPlugins
   */
  export type User$createdPluginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    where?: PluginWhereInput
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    cursor?: PluginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Plugin
   */

  export type AggregatePlugin = {
    _count: PluginCountAggregateOutputType | null
    _avg: PluginAvgAggregateOutputType | null
    _sum: PluginSumAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  export type PluginAvgAggregateOutputType = {
    oneTimePrice: number | null
    usagePrice: number | null
    totalInstalls: number | null
    monthlyActiveUsers: number | null
    totalRevenue: number | null
  }

  export type PluginSumAggregateOutputType = {
    oneTimePrice: number | null
    usagePrice: number | null
    totalInstalls: number | null
    monthlyActiveUsers: number | null
    totalRevenue: number | null
  }

  export type PluginMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    description: string | null
    category: $Enums.PluginCategory | null
    templateId: string | null
    gitRepo: string | null
    pricingModel: $Enums.PricingModel | null
    oneTimePrice: number | null
    subscriptionTier: string | null
    usagePrice: number | null
    whiteLabel: boolean | null
    isPublished: boolean | null
    isActive: boolean | null
    deploymentStatus: $Enums.DeploymentStatus | null
    deploymentUrl: string | null
    apiEndpoint: string | null
    totalInstalls: number | null
    monthlyActiveUsers: number | null
    totalRevenue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type PluginMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    name: string | null
    description: string | null
    category: $Enums.PluginCategory | null
    templateId: string | null
    gitRepo: string | null
    pricingModel: $Enums.PricingModel | null
    oneTimePrice: number | null
    subscriptionTier: string | null
    usagePrice: number | null
    whiteLabel: boolean | null
    isPublished: boolean | null
    isActive: boolean | null
    deploymentStatus: $Enums.DeploymentStatus | null
    deploymentUrl: string | null
    apiEndpoint: string | null
    totalInstalls: number | null
    monthlyActiveUsers: number | null
    totalRevenue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type PluginCountAggregateOutputType = {
    id: number
    creatorId: number
    name: number
    description: number
    category: number
    templateId: number
    template: number
    gitRepo: number
    pricingModel: number
    oneTimePrice: number
    subscriptionTier: number
    usagePrice: number
    whiteLabel: number
    isPublished: number
    isActive: number
    deploymentStatus: number
    deploymentUrl: number
    apiEndpoint: number
    totalInstalls: number
    monthlyActiveUsers: number
    totalRevenue: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    _all: number
  }


  export type PluginAvgAggregateInputType = {
    oneTimePrice?: true
    usagePrice?: true
    totalInstalls?: true
    monthlyActiveUsers?: true
    totalRevenue?: true
  }

  export type PluginSumAggregateInputType = {
    oneTimePrice?: true
    usagePrice?: true
    totalInstalls?: true
    monthlyActiveUsers?: true
    totalRevenue?: true
  }

  export type PluginMinAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    description?: true
    category?: true
    templateId?: true
    gitRepo?: true
    pricingModel?: true
    oneTimePrice?: true
    subscriptionTier?: true
    usagePrice?: true
    whiteLabel?: true
    isPublished?: true
    isActive?: true
    deploymentStatus?: true
    deploymentUrl?: true
    apiEndpoint?: true
    totalInstalls?: true
    monthlyActiveUsers?: true
    totalRevenue?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type PluginMaxAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    description?: true
    category?: true
    templateId?: true
    gitRepo?: true
    pricingModel?: true
    oneTimePrice?: true
    subscriptionTier?: true
    usagePrice?: true
    whiteLabel?: true
    isPublished?: true
    isActive?: true
    deploymentStatus?: true
    deploymentUrl?: true
    apiEndpoint?: true
    totalInstalls?: true
    monthlyActiveUsers?: true
    totalRevenue?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type PluginCountAggregateInputType = {
    id?: true
    creatorId?: true
    name?: true
    description?: true
    category?: true
    templateId?: true
    template?: true
    gitRepo?: true
    pricingModel?: true
    oneTimePrice?: true
    subscriptionTier?: true
    usagePrice?: true
    whiteLabel?: true
    isPublished?: true
    isActive?: true
    deploymentStatus?: true
    deploymentUrl?: true
    apiEndpoint?: true
    totalInstalls?: true
    monthlyActiveUsers?: true
    totalRevenue?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    _all?: true
  }

  export type PluginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plugin to aggregate.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plugins
    **/
    _count?: true | PluginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PluginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PluginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PluginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PluginMaxAggregateInputType
  }

  export type GetPluginAggregateType<T extends PluginAggregateArgs> = {
        [P in keyof T & keyof AggregatePlugin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlugin[P]>
      : GetScalarType<T[P], AggregatePlugin[P]>
  }




  export type PluginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginWhereInput
    orderBy?: PluginOrderByWithAggregationInput | PluginOrderByWithAggregationInput[]
    by: PluginScalarFieldEnum[] | PluginScalarFieldEnum
    having?: PluginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PluginCountAggregateInputType | true
    _avg?: PluginAvgAggregateInputType
    _sum?: PluginSumAggregateInputType
    _min?: PluginMinAggregateInputType
    _max?: PluginMaxAggregateInputType
  }

  export type PluginGroupByOutputType = {
    id: string
    creatorId: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonValue
    gitRepo: string | null
    pricingModel: $Enums.PricingModel
    oneTimePrice: number | null
    subscriptionTier: string | null
    usagePrice: number | null
    whiteLabel: boolean
    isPublished: boolean
    isActive: boolean
    deploymentStatus: $Enums.DeploymentStatus
    deploymentUrl: string | null
    apiEndpoint: string | null
    totalInstalls: number
    monthlyActiveUsers: number
    totalRevenue: number
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    _count: PluginCountAggregateOutputType | null
    _avg: PluginAvgAggregateOutputType | null
    _sum: PluginSumAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  type GetPluginGroupByPayload<T extends PluginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PluginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PluginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PluginGroupByOutputType[P]>
            : GetScalarType<T[P], PluginGroupByOutputType[P]>
        }
      >
    >


  export type PluginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    templateId?: boolean
    template?: boolean
    gitRepo?: boolean
    pricingModel?: boolean
    oneTimePrice?: boolean
    subscriptionTier?: boolean
    usagePrice?: boolean
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: boolean
    deploymentUrl?: boolean
    apiEndpoint?: boolean
    totalInstalls?: boolean
    monthlyActiveUsers?: boolean
    totalRevenue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    purchases?: boolean | Plugin$purchasesArgs<ExtArgs>
    usageRecords?: boolean | Plugin$usageRecordsArgs<ExtArgs>
    githubCallbacks?: boolean | Plugin$githubCallbacksArgs<ExtArgs>
    _count?: boolean | PluginCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plugin"]>

  export type PluginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    templateId?: boolean
    template?: boolean
    gitRepo?: boolean
    pricingModel?: boolean
    oneTimePrice?: boolean
    subscriptionTier?: boolean
    usagePrice?: boolean
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: boolean
    deploymentUrl?: boolean
    apiEndpoint?: boolean
    totalInstalls?: boolean
    monthlyActiveUsers?: boolean
    totalRevenue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plugin"]>

  export type PluginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    templateId?: boolean
    template?: boolean
    gitRepo?: boolean
    pricingModel?: boolean
    oneTimePrice?: boolean
    subscriptionTier?: boolean
    usagePrice?: boolean
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: boolean
    deploymentUrl?: boolean
    apiEndpoint?: boolean
    totalInstalls?: boolean
    monthlyActiveUsers?: boolean
    totalRevenue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plugin"]>

  export type PluginSelectScalar = {
    id?: boolean
    creatorId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    templateId?: boolean
    template?: boolean
    gitRepo?: boolean
    pricingModel?: boolean
    oneTimePrice?: boolean
    subscriptionTier?: boolean
    usagePrice?: boolean
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: boolean
    deploymentUrl?: boolean
    apiEndpoint?: boolean
    totalInstalls?: boolean
    monthlyActiveUsers?: boolean
    totalRevenue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }

  export type PluginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorId" | "name" | "description" | "category" | "templateId" | "template" | "gitRepo" | "pricingModel" | "oneTimePrice" | "subscriptionTier" | "usagePrice" | "whiteLabel" | "isPublished" | "isActive" | "deploymentStatus" | "deploymentUrl" | "apiEndpoint" | "totalInstalls" | "monthlyActiveUsers" | "totalRevenue" | "createdAt" | "updatedAt" | "publishedAt", ExtArgs["result"]["plugin"]>
  export type PluginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    purchases?: boolean | Plugin$purchasesArgs<ExtArgs>
    usageRecords?: boolean | Plugin$usageRecordsArgs<ExtArgs>
    githubCallbacks?: boolean | Plugin$githubCallbacksArgs<ExtArgs>
    _count?: boolean | PluginCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PluginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PluginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PluginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plugin"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      purchases: Prisma.$PluginPurchasePayload<ExtArgs>[]
      usageRecords: Prisma.$PluginUsagePayload<ExtArgs>[]
      githubCallbacks: Prisma.$GithubCallbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      name: string
      description: string
      category: $Enums.PluginCategory
      templateId: string
      template: Prisma.JsonValue
      gitRepo: string | null
      pricingModel: $Enums.PricingModel
      oneTimePrice: number | null
      subscriptionTier: string | null
      usagePrice: number | null
      whiteLabel: boolean
      isPublished: boolean
      isActive: boolean
      deploymentStatus: $Enums.DeploymentStatus
      deploymentUrl: string | null
      apiEndpoint: string | null
      totalInstalls: number
      monthlyActiveUsers: number
      totalRevenue: number
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
    }, ExtArgs["result"]["plugin"]>
    composites: {}
  }

  type PluginGetPayload<S extends boolean | null | undefined | PluginDefaultArgs> = $Result.GetResult<Prisma.$PluginPayload, S>

  type PluginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PluginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PluginCountAggregateInputType | true
    }

  export interface PluginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plugin'], meta: { name: 'Plugin' } }
    /**
     * Find zero or one Plugin that matches the filter.
     * @param {PluginFindUniqueArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PluginFindUniqueArgs>(args: SelectSubset<T, PluginFindUniqueArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plugin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PluginFindUniqueOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PluginFindUniqueOrThrowArgs>(args: SelectSubset<T, PluginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plugin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindFirstArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PluginFindFirstArgs>(args?: SelectSubset<T, PluginFindFirstArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plugin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindFirstOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PluginFindFirstOrThrowArgs>(args?: SelectSubset<T, PluginFindFirstOrThrowArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plugins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plugins
     * const plugins = await prisma.plugin.findMany()
     * 
     * // Get first 10 Plugins
     * const plugins = await prisma.plugin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pluginWithIdOnly = await prisma.plugin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PluginFindManyArgs>(args?: SelectSubset<T, PluginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plugin.
     * @param {PluginCreateArgs} args - Arguments to create a Plugin.
     * @example
     * // Create one Plugin
     * const Plugin = await prisma.plugin.create({
     *   data: {
     *     // ... data to create a Plugin
     *   }
     * })
     * 
     */
    create<T extends PluginCreateArgs>(args: SelectSubset<T, PluginCreateArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plugins.
     * @param {PluginCreateManyArgs} args - Arguments to create many Plugins.
     * @example
     * // Create many Plugins
     * const plugin = await prisma.plugin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PluginCreateManyArgs>(args?: SelectSubset<T, PluginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plugins and returns the data saved in the database.
     * @param {PluginCreateManyAndReturnArgs} args - Arguments to create many Plugins.
     * @example
     * // Create many Plugins
     * const plugin = await prisma.plugin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plugins and only return the `id`
     * const pluginWithIdOnly = await prisma.plugin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PluginCreateManyAndReturnArgs>(args?: SelectSubset<T, PluginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plugin.
     * @param {PluginDeleteArgs} args - Arguments to delete one Plugin.
     * @example
     * // Delete one Plugin
     * const Plugin = await prisma.plugin.delete({
     *   where: {
     *     // ... filter to delete one Plugin
     *   }
     * })
     * 
     */
    delete<T extends PluginDeleteArgs>(args: SelectSubset<T, PluginDeleteArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plugin.
     * @param {PluginUpdateArgs} args - Arguments to update one Plugin.
     * @example
     * // Update one Plugin
     * const plugin = await prisma.plugin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PluginUpdateArgs>(args: SelectSubset<T, PluginUpdateArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plugins.
     * @param {PluginDeleteManyArgs} args - Arguments to filter Plugins to delete.
     * @example
     * // Delete a few Plugins
     * const { count } = await prisma.plugin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PluginDeleteManyArgs>(args?: SelectSubset<T, PluginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plugins
     * const plugin = await prisma.plugin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PluginUpdateManyArgs>(args: SelectSubset<T, PluginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plugins and returns the data updated in the database.
     * @param {PluginUpdateManyAndReturnArgs} args - Arguments to update many Plugins.
     * @example
     * // Update many Plugins
     * const plugin = await prisma.plugin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plugins and only return the `id`
     * const pluginWithIdOnly = await prisma.plugin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PluginUpdateManyAndReturnArgs>(args: SelectSubset<T, PluginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plugin.
     * @param {PluginUpsertArgs} args - Arguments to update or create a Plugin.
     * @example
     * // Update or create a Plugin
     * const plugin = await prisma.plugin.upsert({
     *   create: {
     *     // ... data to create a Plugin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plugin we want to update
     *   }
     * })
     */
    upsert<T extends PluginUpsertArgs>(args: SelectSubset<T, PluginUpsertArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginCountArgs} args - Arguments to filter Plugins to count.
     * @example
     * // Count the number of Plugins
     * const count = await prisma.plugin.count({
     *   where: {
     *     // ... the filter for the Plugins we want to count
     *   }
     * })
    **/
    count<T extends PluginCountArgs>(
      args?: Subset<T, PluginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PluginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PluginAggregateArgs>(args: Subset<T, PluginAggregateArgs>): Prisma.PrismaPromise<GetPluginAggregateType<T>>

    /**
     * Group by Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PluginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PluginGroupByArgs['orderBy'] }
        : { orderBy?: PluginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PluginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPluginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plugin model
   */
  readonly fields: PluginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plugin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PluginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchases<T extends Plugin$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Plugin$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageRecords<T extends Plugin$usageRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Plugin$usageRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    githubCallbacks<T extends Plugin$githubCallbacksArgs<ExtArgs> = {}>(args?: Subset<T, Plugin$githubCallbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plugin model
   */
  interface PluginFieldRefs {
    readonly id: FieldRef<"Plugin", 'String'>
    readonly creatorId: FieldRef<"Plugin", 'String'>
    readonly name: FieldRef<"Plugin", 'String'>
    readonly description: FieldRef<"Plugin", 'String'>
    readonly category: FieldRef<"Plugin", 'PluginCategory'>
    readonly templateId: FieldRef<"Plugin", 'String'>
    readonly template: FieldRef<"Plugin", 'Json'>
    readonly gitRepo: FieldRef<"Plugin", 'String'>
    readonly pricingModel: FieldRef<"Plugin", 'PricingModel'>
    readonly oneTimePrice: FieldRef<"Plugin", 'Float'>
    readonly subscriptionTier: FieldRef<"Plugin", 'String'>
    readonly usagePrice: FieldRef<"Plugin", 'Float'>
    readonly whiteLabel: FieldRef<"Plugin", 'Boolean'>
    readonly isPublished: FieldRef<"Plugin", 'Boolean'>
    readonly isActive: FieldRef<"Plugin", 'Boolean'>
    readonly deploymentStatus: FieldRef<"Plugin", 'DeploymentStatus'>
    readonly deploymentUrl: FieldRef<"Plugin", 'String'>
    readonly apiEndpoint: FieldRef<"Plugin", 'String'>
    readonly totalInstalls: FieldRef<"Plugin", 'Int'>
    readonly monthlyActiveUsers: FieldRef<"Plugin", 'Int'>
    readonly totalRevenue: FieldRef<"Plugin", 'Float'>
    readonly createdAt: FieldRef<"Plugin", 'DateTime'>
    readonly updatedAt: FieldRef<"Plugin", 'DateTime'>
    readonly publishedAt: FieldRef<"Plugin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plugin findUnique
   */
  export type PluginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin findUniqueOrThrow
   */
  export type PluginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin findFirst
   */
  export type PluginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin findFirstOrThrow
   */
  export type PluginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin findMany
   */
  export type PluginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugins to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin create
   */
  export type PluginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The data needed to create a Plugin.
     */
    data: XOR<PluginCreateInput, PluginUncheckedCreateInput>
  }

  /**
   * Plugin createMany
   */
  export type PluginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plugins.
     */
    data: PluginCreateManyInput | PluginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plugin createManyAndReturn
   */
  export type PluginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * The data used to create many Plugins.
     */
    data: PluginCreateManyInput | PluginCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plugin update
   */
  export type PluginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The data needed to update a Plugin.
     */
    data: XOR<PluginUpdateInput, PluginUncheckedUpdateInput>
    /**
     * Choose, which Plugin to update.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin updateMany
   */
  export type PluginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plugins.
     */
    data: XOR<PluginUpdateManyMutationInput, PluginUncheckedUpdateManyInput>
    /**
     * Filter which Plugins to update
     */
    where?: PluginWhereInput
    /**
     * Limit how many Plugins to update.
     */
    limit?: number
  }

  /**
   * Plugin updateManyAndReturn
   */
  export type PluginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * The data used to update Plugins.
     */
    data: XOR<PluginUpdateManyMutationInput, PluginUncheckedUpdateManyInput>
    /**
     * Filter which Plugins to update
     */
    where?: PluginWhereInput
    /**
     * Limit how many Plugins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plugin upsert
   */
  export type PluginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The filter to search for the Plugin to update in case it exists.
     */
    where: PluginWhereUniqueInput
    /**
     * In case the Plugin found by the `where` argument doesn't exist, create a new Plugin with this data.
     */
    create: XOR<PluginCreateInput, PluginUncheckedCreateInput>
    /**
     * In case the Plugin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PluginUpdateInput, PluginUncheckedUpdateInput>
  }

  /**
   * Plugin delete
   */
  export type PluginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter which Plugin to delete.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin deleteMany
   */
  export type PluginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plugins to delete
     */
    where?: PluginWhereInput
    /**
     * Limit how many Plugins to delete.
     */
    limit?: number
  }

  /**
   * Plugin.purchases
   */
  export type Plugin$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    where?: PluginPurchaseWhereInput
    orderBy?: PluginPurchaseOrderByWithRelationInput | PluginPurchaseOrderByWithRelationInput[]
    cursor?: PluginPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PluginPurchaseScalarFieldEnum | PluginPurchaseScalarFieldEnum[]
  }

  /**
   * Plugin.usageRecords
   */
  export type Plugin$usageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    where?: PluginUsageWhereInput
    orderBy?: PluginUsageOrderByWithRelationInput | PluginUsageOrderByWithRelationInput[]
    cursor?: PluginUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PluginUsageScalarFieldEnum | PluginUsageScalarFieldEnum[]
  }

  /**
   * Plugin.githubCallbacks
   */
  export type Plugin$githubCallbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    where?: GithubCallbackWhereInput
    orderBy?: GithubCallbackOrderByWithRelationInput | GithubCallbackOrderByWithRelationInput[]
    cursor?: GithubCallbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GithubCallbackScalarFieldEnum | GithubCallbackScalarFieldEnum[]
  }

  /**
   * Plugin without action
   */
  export type PluginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
  }


  /**
   * Model PluginPurchase
   */

  export type AggregatePluginPurchase = {
    _count: PluginPurchaseCountAggregateOutputType | null
    _avg: PluginPurchaseAvgAggregateOutputType | null
    _sum: PluginPurchaseSumAggregateOutputType | null
    _min: PluginPurchaseMinAggregateOutputType | null
    _max: PluginPurchaseMaxAggregateOutputType | null
  }

  export type PluginPurchaseAvgAggregateOutputType = {
    amount: number | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type PluginPurchaseSumAggregateOutputType = {
    amount: number | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type PluginPurchaseMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    pluginId: string | null
    purchaseType: $Enums.PurchaseType | null
    amount: number | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
    nextBillingDate: Date | null
    isActive: boolean | null
    apiKey: string | null
    usageLimit: number | null
    usageCount: number | null
    purchasedAt: Date | null
    lastUsedAt: Date | null
  }

  export type PluginPurchaseMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    pluginId: string | null
    purchaseType: $Enums.PurchaseType | null
    amount: number | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
    nextBillingDate: Date | null
    isActive: boolean | null
    apiKey: string | null
    usageLimit: number | null
    usageCount: number | null
    purchasedAt: Date | null
    lastUsedAt: Date | null
  }

  export type PluginPurchaseCountAggregateOutputType = {
    id: number
    customerId: number
    pluginId: number
    purchaseType: number
    amount: number
    subscriptionStatus: number
    subscriptionStartDate: number
    subscriptionEndDate: number
    nextBillingDate: number
    isActive: number
    apiKey: number
    usageLimit: number
    usageCount: number
    purchasedAt: number
    lastUsedAt: number
    _all: number
  }


  export type PluginPurchaseAvgAggregateInputType = {
    amount?: true
    usageLimit?: true
    usageCount?: true
  }

  export type PluginPurchaseSumAggregateInputType = {
    amount?: true
    usageLimit?: true
    usageCount?: true
  }

  export type PluginPurchaseMinAggregateInputType = {
    id?: true
    customerId?: true
    pluginId?: true
    purchaseType?: true
    amount?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
    nextBillingDate?: true
    isActive?: true
    apiKey?: true
    usageLimit?: true
    usageCount?: true
    purchasedAt?: true
    lastUsedAt?: true
  }

  export type PluginPurchaseMaxAggregateInputType = {
    id?: true
    customerId?: true
    pluginId?: true
    purchaseType?: true
    amount?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
    nextBillingDate?: true
    isActive?: true
    apiKey?: true
    usageLimit?: true
    usageCount?: true
    purchasedAt?: true
    lastUsedAt?: true
  }

  export type PluginPurchaseCountAggregateInputType = {
    id?: true
    customerId?: true
    pluginId?: true
    purchaseType?: true
    amount?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
    nextBillingDate?: true
    isActive?: true
    apiKey?: true
    usageLimit?: true
    usageCount?: true
    purchasedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type PluginPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PluginPurchase to aggregate.
     */
    where?: PluginPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginPurchases to fetch.
     */
    orderBy?: PluginPurchaseOrderByWithRelationInput | PluginPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PluginPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PluginPurchases
    **/
    _count?: true | PluginPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PluginPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PluginPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PluginPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PluginPurchaseMaxAggregateInputType
  }

  export type GetPluginPurchaseAggregateType<T extends PluginPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePluginPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePluginPurchase[P]>
      : GetScalarType<T[P], AggregatePluginPurchase[P]>
  }




  export type PluginPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginPurchaseWhereInput
    orderBy?: PluginPurchaseOrderByWithAggregationInput | PluginPurchaseOrderByWithAggregationInput[]
    by: PluginPurchaseScalarFieldEnum[] | PluginPurchaseScalarFieldEnum
    having?: PluginPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PluginPurchaseCountAggregateInputType | true
    _avg?: PluginPurchaseAvgAggregateInputType
    _sum?: PluginPurchaseSumAggregateInputType
    _min?: PluginPurchaseMinAggregateInputType
    _max?: PluginPurchaseMaxAggregateInputType
  }

  export type PluginPurchaseGroupByOutputType = {
    id: string
    customerId: string
    pluginId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus: $Enums.SubscriptionStatus | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
    nextBillingDate: Date | null
    isActive: boolean
    apiKey: string | null
    usageLimit: number | null
    usageCount: number
    purchasedAt: Date
    lastUsedAt: Date | null
    _count: PluginPurchaseCountAggregateOutputType | null
    _avg: PluginPurchaseAvgAggregateOutputType | null
    _sum: PluginPurchaseSumAggregateOutputType | null
    _min: PluginPurchaseMinAggregateOutputType | null
    _max: PluginPurchaseMaxAggregateOutputType | null
  }

  type GetPluginPurchaseGroupByPayload<T extends PluginPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PluginPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PluginPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PluginPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PluginPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PluginPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    pluginId?: boolean
    purchaseType?: boolean
    amount?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    nextBillingDate?: boolean
    isActive?: boolean
    apiKey?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    purchasedAt?: boolean
    lastUsedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
    usageRecords?: boolean | PluginPurchase$usageRecordsArgs<ExtArgs>
    _count?: boolean | PluginPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pluginPurchase"]>

  export type PluginPurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    pluginId?: boolean
    purchaseType?: boolean
    amount?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    nextBillingDate?: boolean
    isActive?: boolean
    apiKey?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    purchasedAt?: boolean
    lastUsedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pluginPurchase"]>

  export type PluginPurchaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    pluginId?: boolean
    purchaseType?: boolean
    amount?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    nextBillingDate?: boolean
    isActive?: boolean
    apiKey?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    purchasedAt?: boolean
    lastUsedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pluginPurchase"]>

  export type PluginPurchaseSelectScalar = {
    id?: boolean
    customerId?: boolean
    pluginId?: boolean
    purchaseType?: boolean
    amount?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    nextBillingDate?: boolean
    isActive?: boolean
    apiKey?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    purchasedAt?: boolean
    lastUsedAt?: boolean
  }

  export type PluginPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "pluginId" | "purchaseType" | "amount" | "subscriptionStatus" | "subscriptionStartDate" | "subscriptionEndDate" | "nextBillingDate" | "isActive" | "apiKey" | "usageLimit" | "usageCount" | "purchasedAt" | "lastUsedAt", ExtArgs["result"]["pluginPurchase"]>
  export type PluginPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
    usageRecords?: boolean | PluginPurchase$usageRecordsArgs<ExtArgs>
    _count?: boolean | PluginPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PluginPurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }
  export type PluginPurchaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }

  export type $PluginPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PluginPurchase"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      plugin: Prisma.$PluginPayload<ExtArgs>
      usageRecords: Prisma.$PluginUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      pluginId: string
      purchaseType: $Enums.PurchaseType
      amount: number
      subscriptionStatus: $Enums.SubscriptionStatus | null
      subscriptionStartDate: Date | null
      subscriptionEndDate: Date | null
      nextBillingDate: Date | null
      isActive: boolean
      apiKey: string | null
      usageLimit: number | null
      usageCount: number
      purchasedAt: Date
      lastUsedAt: Date | null
    }, ExtArgs["result"]["pluginPurchase"]>
    composites: {}
  }

  type PluginPurchaseGetPayload<S extends boolean | null | undefined | PluginPurchaseDefaultArgs> = $Result.GetResult<Prisma.$PluginPurchasePayload, S>

  type PluginPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PluginPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PluginPurchaseCountAggregateInputType | true
    }

  export interface PluginPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PluginPurchase'], meta: { name: 'PluginPurchase' } }
    /**
     * Find zero or one PluginPurchase that matches the filter.
     * @param {PluginPurchaseFindUniqueArgs} args - Arguments to find a PluginPurchase
     * @example
     * // Get one PluginPurchase
     * const pluginPurchase = await prisma.pluginPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PluginPurchaseFindUniqueArgs>(args: SelectSubset<T, PluginPurchaseFindUniqueArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PluginPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PluginPurchaseFindUniqueOrThrowArgs} args - Arguments to find a PluginPurchase
     * @example
     * // Get one PluginPurchase
     * const pluginPurchase = await prisma.pluginPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PluginPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PluginPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PluginPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginPurchaseFindFirstArgs} args - Arguments to find a PluginPurchase
     * @example
     * // Get one PluginPurchase
     * const pluginPurchase = await prisma.pluginPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PluginPurchaseFindFirstArgs>(args?: SelectSubset<T, PluginPurchaseFindFirstArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PluginPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginPurchaseFindFirstOrThrowArgs} args - Arguments to find a PluginPurchase
     * @example
     * // Get one PluginPurchase
     * const pluginPurchase = await prisma.pluginPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PluginPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PluginPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PluginPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PluginPurchases
     * const pluginPurchases = await prisma.pluginPurchase.findMany()
     * 
     * // Get first 10 PluginPurchases
     * const pluginPurchases = await prisma.pluginPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pluginPurchaseWithIdOnly = await prisma.pluginPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PluginPurchaseFindManyArgs>(args?: SelectSubset<T, PluginPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PluginPurchase.
     * @param {PluginPurchaseCreateArgs} args - Arguments to create a PluginPurchase.
     * @example
     * // Create one PluginPurchase
     * const PluginPurchase = await prisma.pluginPurchase.create({
     *   data: {
     *     // ... data to create a PluginPurchase
     *   }
     * })
     * 
     */
    create<T extends PluginPurchaseCreateArgs>(args: SelectSubset<T, PluginPurchaseCreateArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PluginPurchases.
     * @param {PluginPurchaseCreateManyArgs} args - Arguments to create many PluginPurchases.
     * @example
     * // Create many PluginPurchases
     * const pluginPurchase = await prisma.pluginPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PluginPurchaseCreateManyArgs>(args?: SelectSubset<T, PluginPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PluginPurchases and returns the data saved in the database.
     * @param {PluginPurchaseCreateManyAndReturnArgs} args - Arguments to create many PluginPurchases.
     * @example
     * // Create many PluginPurchases
     * const pluginPurchase = await prisma.pluginPurchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PluginPurchases and only return the `id`
     * const pluginPurchaseWithIdOnly = await prisma.pluginPurchase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PluginPurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PluginPurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PluginPurchase.
     * @param {PluginPurchaseDeleteArgs} args - Arguments to delete one PluginPurchase.
     * @example
     * // Delete one PluginPurchase
     * const PluginPurchase = await prisma.pluginPurchase.delete({
     *   where: {
     *     // ... filter to delete one PluginPurchase
     *   }
     * })
     * 
     */
    delete<T extends PluginPurchaseDeleteArgs>(args: SelectSubset<T, PluginPurchaseDeleteArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PluginPurchase.
     * @param {PluginPurchaseUpdateArgs} args - Arguments to update one PluginPurchase.
     * @example
     * // Update one PluginPurchase
     * const pluginPurchase = await prisma.pluginPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PluginPurchaseUpdateArgs>(args: SelectSubset<T, PluginPurchaseUpdateArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PluginPurchases.
     * @param {PluginPurchaseDeleteManyArgs} args - Arguments to filter PluginPurchases to delete.
     * @example
     * // Delete a few PluginPurchases
     * const { count } = await prisma.pluginPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PluginPurchaseDeleteManyArgs>(args?: SelectSubset<T, PluginPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PluginPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PluginPurchases
     * const pluginPurchase = await prisma.pluginPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PluginPurchaseUpdateManyArgs>(args: SelectSubset<T, PluginPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PluginPurchases and returns the data updated in the database.
     * @param {PluginPurchaseUpdateManyAndReturnArgs} args - Arguments to update many PluginPurchases.
     * @example
     * // Update many PluginPurchases
     * const pluginPurchase = await prisma.pluginPurchase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PluginPurchases and only return the `id`
     * const pluginPurchaseWithIdOnly = await prisma.pluginPurchase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PluginPurchaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PluginPurchaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PluginPurchase.
     * @param {PluginPurchaseUpsertArgs} args - Arguments to update or create a PluginPurchase.
     * @example
     * // Update or create a PluginPurchase
     * const pluginPurchase = await prisma.pluginPurchase.upsert({
     *   create: {
     *     // ... data to create a PluginPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PluginPurchase we want to update
     *   }
     * })
     */
    upsert<T extends PluginPurchaseUpsertArgs>(args: SelectSubset<T, PluginPurchaseUpsertArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PluginPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginPurchaseCountArgs} args - Arguments to filter PluginPurchases to count.
     * @example
     * // Count the number of PluginPurchases
     * const count = await prisma.pluginPurchase.count({
     *   where: {
     *     // ... the filter for the PluginPurchases we want to count
     *   }
     * })
    **/
    count<T extends PluginPurchaseCountArgs>(
      args?: Subset<T, PluginPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PluginPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PluginPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PluginPurchaseAggregateArgs>(args: Subset<T, PluginPurchaseAggregateArgs>): Prisma.PrismaPromise<GetPluginPurchaseAggregateType<T>>

    /**
     * Group by PluginPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PluginPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PluginPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PluginPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PluginPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPluginPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PluginPurchase model
   */
  readonly fields: PluginPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PluginPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PluginPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plugin<T extends PluginDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PluginDefaultArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usageRecords<T extends PluginPurchase$usageRecordsArgs<ExtArgs> = {}>(args?: Subset<T, PluginPurchase$usageRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PluginPurchase model
   */
  interface PluginPurchaseFieldRefs {
    readonly id: FieldRef<"PluginPurchase", 'String'>
    readonly customerId: FieldRef<"PluginPurchase", 'String'>
    readonly pluginId: FieldRef<"PluginPurchase", 'String'>
    readonly purchaseType: FieldRef<"PluginPurchase", 'PurchaseType'>
    readonly amount: FieldRef<"PluginPurchase", 'Float'>
    readonly subscriptionStatus: FieldRef<"PluginPurchase", 'SubscriptionStatus'>
    readonly subscriptionStartDate: FieldRef<"PluginPurchase", 'DateTime'>
    readonly subscriptionEndDate: FieldRef<"PluginPurchase", 'DateTime'>
    readonly nextBillingDate: FieldRef<"PluginPurchase", 'DateTime'>
    readonly isActive: FieldRef<"PluginPurchase", 'Boolean'>
    readonly apiKey: FieldRef<"PluginPurchase", 'String'>
    readonly usageLimit: FieldRef<"PluginPurchase", 'Int'>
    readonly usageCount: FieldRef<"PluginPurchase", 'Int'>
    readonly purchasedAt: FieldRef<"PluginPurchase", 'DateTime'>
    readonly lastUsedAt: FieldRef<"PluginPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PluginPurchase findUnique
   */
  export type PluginPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PluginPurchase to fetch.
     */
    where: PluginPurchaseWhereUniqueInput
  }

  /**
   * PluginPurchase findUniqueOrThrow
   */
  export type PluginPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PluginPurchase to fetch.
     */
    where: PluginPurchaseWhereUniqueInput
  }

  /**
   * PluginPurchase findFirst
   */
  export type PluginPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PluginPurchase to fetch.
     */
    where?: PluginPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginPurchases to fetch.
     */
    orderBy?: PluginPurchaseOrderByWithRelationInput | PluginPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PluginPurchases.
     */
    cursor?: PluginPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PluginPurchases.
     */
    distinct?: PluginPurchaseScalarFieldEnum | PluginPurchaseScalarFieldEnum[]
  }

  /**
   * PluginPurchase findFirstOrThrow
   */
  export type PluginPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PluginPurchase to fetch.
     */
    where?: PluginPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginPurchases to fetch.
     */
    orderBy?: PluginPurchaseOrderByWithRelationInput | PluginPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PluginPurchases.
     */
    cursor?: PluginPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PluginPurchases.
     */
    distinct?: PluginPurchaseScalarFieldEnum | PluginPurchaseScalarFieldEnum[]
  }

  /**
   * PluginPurchase findMany
   */
  export type PluginPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which PluginPurchases to fetch.
     */
    where?: PluginPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginPurchases to fetch.
     */
    orderBy?: PluginPurchaseOrderByWithRelationInput | PluginPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PluginPurchases.
     */
    cursor?: PluginPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginPurchases.
     */
    skip?: number
    distinct?: PluginPurchaseScalarFieldEnum | PluginPurchaseScalarFieldEnum[]
  }

  /**
   * PluginPurchase create
   */
  export type PluginPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a PluginPurchase.
     */
    data: XOR<PluginPurchaseCreateInput, PluginPurchaseUncheckedCreateInput>
  }

  /**
   * PluginPurchase createMany
   */
  export type PluginPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PluginPurchases.
     */
    data: PluginPurchaseCreateManyInput | PluginPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PluginPurchase createManyAndReturn
   */
  export type PluginPurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * The data used to create many PluginPurchases.
     */
    data: PluginPurchaseCreateManyInput | PluginPurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PluginPurchase update
   */
  export type PluginPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a PluginPurchase.
     */
    data: XOR<PluginPurchaseUpdateInput, PluginPurchaseUncheckedUpdateInput>
    /**
     * Choose, which PluginPurchase to update.
     */
    where: PluginPurchaseWhereUniqueInput
  }

  /**
   * PluginPurchase updateMany
   */
  export type PluginPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PluginPurchases.
     */
    data: XOR<PluginPurchaseUpdateManyMutationInput, PluginPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which PluginPurchases to update
     */
    where?: PluginPurchaseWhereInput
    /**
     * Limit how many PluginPurchases to update.
     */
    limit?: number
  }

  /**
   * PluginPurchase updateManyAndReturn
   */
  export type PluginPurchaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * The data used to update PluginPurchases.
     */
    data: XOR<PluginPurchaseUpdateManyMutationInput, PluginPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which PluginPurchases to update
     */
    where?: PluginPurchaseWhereInput
    /**
     * Limit how many PluginPurchases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PluginPurchase upsert
   */
  export type PluginPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the PluginPurchase to update in case it exists.
     */
    where: PluginPurchaseWhereUniqueInput
    /**
     * In case the PluginPurchase found by the `where` argument doesn't exist, create a new PluginPurchase with this data.
     */
    create: XOR<PluginPurchaseCreateInput, PluginPurchaseUncheckedCreateInput>
    /**
     * In case the PluginPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PluginPurchaseUpdateInput, PluginPurchaseUncheckedUpdateInput>
  }

  /**
   * PluginPurchase delete
   */
  export type PluginPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    /**
     * Filter which PluginPurchase to delete.
     */
    where: PluginPurchaseWhereUniqueInput
  }

  /**
   * PluginPurchase deleteMany
   */
  export type PluginPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PluginPurchases to delete
     */
    where?: PluginPurchaseWhereInput
    /**
     * Limit how many PluginPurchases to delete.
     */
    limit?: number
  }

  /**
   * PluginPurchase.usageRecords
   */
  export type PluginPurchase$usageRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    where?: PluginUsageWhereInput
    orderBy?: PluginUsageOrderByWithRelationInput | PluginUsageOrderByWithRelationInput[]
    cursor?: PluginUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PluginUsageScalarFieldEnum | PluginUsageScalarFieldEnum[]
  }

  /**
   * PluginPurchase without action
   */
  export type PluginPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PluginUsage
   */

  export type AggregatePluginUsage = {
    _count: PluginUsageCountAggregateOutputType | null
    _avg: PluginUsageAvgAggregateOutputType | null
    _sum: PluginUsageSumAggregateOutputType | null
    _min: PluginUsageMinAggregateOutputType | null
    _max: PluginUsageMaxAggregateOutputType | null
  }

  export type PluginUsageAvgAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
    requestSize: number | null
    responseSize: number | null
  }

  export type PluginUsageSumAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
    requestSize: number | null
    responseSize: number | null
  }

  export type PluginUsageMinAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    pluginId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    requestSize: number | null
    responseSize: number | null
    userAgent: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type PluginUsageMaxAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    pluginId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    requestSize: number | null
    responseSize: number | null
    userAgent: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type PluginUsageCountAggregateOutputType = {
    id: number
    purchaseId: number
    pluginId: number
    endpoint: number
    method: number
    statusCode: number
    responseTime: number
    requestSize: number
    responseSize: number
    userAgent: number
    ipAddress: number
    timestamp: number
    _all: number
  }


  export type PluginUsageAvgAggregateInputType = {
    statusCode?: true
    responseTime?: true
    requestSize?: true
    responseSize?: true
  }

  export type PluginUsageSumAggregateInputType = {
    statusCode?: true
    responseTime?: true
    requestSize?: true
    responseSize?: true
  }

  export type PluginUsageMinAggregateInputType = {
    id?: true
    purchaseId?: true
    pluginId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    requestSize?: true
    responseSize?: true
    userAgent?: true
    ipAddress?: true
    timestamp?: true
  }

  export type PluginUsageMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    pluginId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    requestSize?: true
    responseSize?: true
    userAgent?: true
    ipAddress?: true
    timestamp?: true
  }

  export type PluginUsageCountAggregateInputType = {
    id?: true
    purchaseId?: true
    pluginId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    requestSize?: true
    responseSize?: true
    userAgent?: true
    ipAddress?: true
    timestamp?: true
    _all?: true
  }

  export type PluginUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PluginUsage to aggregate.
     */
    where?: PluginUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginUsages to fetch.
     */
    orderBy?: PluginUsageOrderByWithRelationInput | PluginUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PluginUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PluginUsages
    **/
    _count?: true | PluginUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PluginUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PluginUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PluginUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PluginUsageMaxAggregateInputType
  }

  export type GetPluginUsageAggregateType<T extends PluginUsageAggregateArgs> = {
        [P in keyof T & keyof AggregatePluginUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePluginUsage[P]>
      : GetScalarType<T[P], AggregatePluginUsage[P]>
  }




  export type PluginUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginUsageWhereInput
    orderBy?: PluginUsageOrderByWithAggregationInput | PluginUsageOrderByWithAggregationInput[]
    by: PluginUsageScalarFieldEnum[] | PluginUsageScalarFieldEnum
    having?: PluginUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PluginUsageCountAggregateInputType | true
    _avg?: PluginUsageAvgAggregateInputType
    _sum?: PluginUsageSumAggregateInputType
    _min?: PluginUsageMinAggregateInputType
    _max?: PluginUsageMaxAggregateInputType
  }

  export type PluginUsageGroupByOutputType = {
    id: string
    purchaseId: string
    pluginId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize: number | null
    responseSize: number | null
    userAgent: string | null
    ipAddress: string | null
    timestamp: Date
    _count: PluginUsageCountAggregateOutputType | null
    _avg: PluginUsageAvgAggregateOutputType | null
    _sum: PluginUsageSumAggregateOutputType | null
    _min: PluginUsageMinAggregateOutputType | null
    _max: PluginUsageMaxAggregateOutputType | null
  }

  type GetPluginUsageGroupByPayload<T extends PluginUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PluginUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PluginUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PluginUsageGroupByOutputType[P]>
            : GetScalarType<T[P], PluginUsageGroupByOutputType[P]>
        }
      >
    >


  export type PluginUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    pluginId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    requestSize?: boolean
    responseSize?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
    purchase?: boolean | PluginPurchaseDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pluginUsage"]>

  export type PluginUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    pluginId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    requestSize?: boolean
    responseSize?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
    purchase?: boolean | PluginPurchaseDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pluginUsage"]>

  export type PluginUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    pluginId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    requestSize?: boolean
    responseSize?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
    purchase?: boolean | PluginPurchaseDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pluginUsage"]>

  export type PluginUsageSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    pluginId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    requestSize?: boolean
    responseSize?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
  }

  export type PluginUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseId" | "pluginId" | "endpoint" | "method" | "statusCode" | "responseTime" | "requestSize" | "responseSize" | "userAgent" | "ipAddress" | "timestamp", ExtArgs["result"]["pluginUsage"]>
  export type PluginUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PluginPurchaseDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }
  export type PluginUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PluginPurchaseDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }
  export type PluginUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PluginPurchaseDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }

  export type $PluginUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PluginUsage"
    objects: {
      purchase: Prisma.$PluginPurchasePayload<ExtArgs>
      plugin: Prisma.$PluginPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseId: string
      pluginId: string
      endpoint: string
      method: string
      statusCode: number
      responseTime: number
      requestSize: number | null
      responseSize: number | null
      userAgent: string | null
      ipAddress: string | null
      timestamp: Date
    }, ExtArgs["result"]["pluginUsage"]>
    composites: {}
  }

  type PluginUsageGetPayload<S extends boolean | null | undefined | PluginUsageDefaultArgs> = $Result.GetResult<Prisma.$PluginUsagePayload, S>

  type PluginUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PluginUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PluginUsageCountAggregateInputType | true
    }

  export interface PluginUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PluginUsage'], meta: { name: 'PluginUsage' } }
    /**
     * Find zero or one PluginUsage that matches the filter.
     * @param {PluginUsageFindUniqueArgs} args - Arguments to find a PluginUsage
     * @example
     * // Get one PluginUsage
     * const pluginUsage = await prisma.pluginUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PluginUsageFindUniqueArgs>(args: SelectSubset<T, PluginUsageFindUniqueArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PluginUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PluginUsageFindUniqueOrThrowArgs} args - Arguments to find a PluginUsage
     * @example
     * // Get one PluginUsage
     * const pluginUsage = await prisma.pluginUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PluginUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, PluginUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PluginUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUsageFindFirstArgs} args - Arguments to find a PluginUsage
     * @example
     * // Get one PluginUsage
     * const pluginUsage = await prisma.pluginUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PluginUsageFindFirstArgs>(args?: SelectSubset<T, PluginUsageFindFirstArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PluginUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUsageFindFirstOrThrowArgs} args - Arguments to find a PluginUsage
     * @example
     * // Get one PluginUsage
     * const pluginUsage = await prisma.pluginUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PluginUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, PluginUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PluginUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PluginUsages
     * const pluginUsages = await prisma.pluginUsage.findMany()
     * 
     * // Get first 10 PluginUsages
     * const pluginUsages = await prisma.pluginUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pluginUsageWithIdOnly = await prisma.pluginUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PluginUsageFindManyArgs>(args?: SelectSubset<T, PluginUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PluginUsage.
     * @param {PluginUsageCreateArgs} args - Arguments to create a PluginUsage.
     * @example
     * // Create one PluginUsage
     * const PluginUsage = await prisma.pluginUsage.create({
     *   data: {
     *     // ... data to create a PluginUsage
     *   }
     * })
     * 
     */
    create<T extends PluginUsageCreateArgs>(args: SelectSubset<T, PluginUsageCreateArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PluginUsages.
     * @param {PluginUsageCreateManyArgs} args - Arguments to create many PluginUsages.
     * @example
     * // Create many PluginUsages
     * const pluginUsage = await prisma.pluginUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PluginUsageCreateManyArgs>(args?: SelectSubset<T, PluginUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PluginUsages and returns the data saved in the database.
     * @param {PluginUsageCreateManyAndReturnArgs} args - Arguments to create many PluginUsages.
     * @example
     * // Create many PluginUsages
     * const pluginUsage = await prisma.pluginUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PluginUsages and only return the `id`
     * const pluginUsageWithIdOnly = await prisma.pluginUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PluginUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, PluginUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PluginUsage.
     * @param {PluginUsageDeleteArgs} args - Arguments to delete one PluginUsage.
     * @example
     * // Delete one PluginUsage
     * const PluginUsage = await prisma.pluginUsage.delete({
     *   where: {
     *     // ... filter to delete one PluginUsage
     *   }
     * })
     * 
     */
    delete<T extends PluginUsageDeleteArgs>(args: SelectSubset<T, PluginUsageDeleteArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PluginUsage.
     * @param {PluginUsageUpdateArgs} args - Arguments to update one PluginUsage.
     * @example
     * // Update one PluginUsage
     * const pluginUsage = await prisma.pluginUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PluginUsageUpdateArgs>(args: SelectSubset<T, PluginUsageUpdateArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PluginUsages.
     * @param {PluginUsageDeleteManyArgs} args - Arguments to filter PluginUsages to delete.
     * @example
     * // Delete a few PluginUsages
     * const { count } = await prisma.pluginUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PluginUsageDeleteManyArgs>(args?: SelectSubset<T, PluginUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PluginUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PluginUsages
     * const pluginUsage = await prisma.pluginUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PluginUsageUpdateManyArgs>(args: SelectSubset<T, PluginUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PluginUsages and returns the data updated in the database.
     * @param {PluginUsageUpdateManyAndReturnArgs} args - Arguments to update many PluginUsages.
     * @example
     * // Update many PluginUsages
     * const pluginUsage = await prisma.pluginUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PluginUsages and only return the `id`
     * const pluginUsageWithIdOnly = await prisma.pluginUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PluginUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, PluginUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PluginUsage.
     * @param {PluginUsageUpsertArgs} args - Arguments to update or create a PluginUsage.
     * @example
     * // Update or create a PluginUsage
     * const pluginUsage = await prisma.pluginUsage.upsert({
     *   create: {
     *     // ... data to create a PluginUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PluginUsage we want to update
     *   }
     * })
     */
    upsert<T extends PluginUsageUpsertArgs>(args: SelectSubset<T, PluginUsageUpsertArgs<ExtArgs>>): Prisma__PluginUsageClient<$Result.GetResult<Prisma.$PluginUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PluginUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUsageCountArgs} args - Arguments to filter PluginUsages to count.
     * @example
     * // Count the number of PluginUsages
     * const count = await prisma.pluginUsage.count({
     *   where: {
     *     // ... the filter for the PluginUsages we want to count
     *   }
     * })
    **/
    count<T extends PluginUsageCountArgs>(
      args?: Subset<T, PluginUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PluginUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PluginUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PluginUsageAggregateArgs>(args: Subset<T, PluginUsageAggregateArgs>): Prisma.PrismaPromise<GetPluginUsageAggregateType<T>>

    /**
     * Group by PluginUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PluginUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PluginUsageGroupByArgs['orderBy'] }
        : { orderBy?: PluginUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PluginUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPluginUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PluginUsage model
   */
  readonly fields: PluginUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PluginUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PluginUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PluginPurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PluginPurchaseDefaultArgs<ExtArgs>>): Prisma__PluginPurchaseClient<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plugin<T extends PluginDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PluginDefaultArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PluginUsage model
   */
  interface PluginUsageFieldRefs {
    readonly id: FieldRef<"PluginUsage", 'String'>
    readonly purchaseId: FieldRef<"PluginUsage", 'String'>
    readonly pluginId: FieldRef<"PluginUsage", 'String'>
    readonly endpoint: FieldRef<"PluginUsage", 'String'>
    readonly method: FieldRef<"PluginUsage", 'String'>
    readonly statusCode: FieldRef<"PluginUsage", 'Int'>
    readonly responseTime: FieldRef<"PluginUsage", 'Int'>
    readonly requestSize: FieldRef<"PluginUsage", 'Int'>
    readonly responseSize: FieldRef<"PluginUsage", 'Int'>
    readonly userAgent: FieldRef<"PluginUsage", 'String'>
    readonly ipAddress: FieldRef<"PluginUsage", 'String'>
    readonly timestamp: FieldRef<"PluginUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PluginUsage findUnique
   */
  export type PluginUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * Filter, which PluginUsage to fetch.
     */
    where: PluginUsageWhereUniqueInput
  }

  /**
   * PluginUsage findUniqueOrThrow
   */
  export type PluginUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * Filter, which PluginUsage to fetch.
     */
    where: PluginUsageWhereUniqueInput
  }

  /**
   * PluginUsage findFirst
   */
  export type PluginUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * Filter, which PluginUsage to fetch.
     */
    where?: PluginUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginUsages to fetch.
     */
    orderBy?: PluginUsageOrderByWithRelationInput | PluginUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PluginUsages.
     */
    cursor?: PluginUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PluginUsages.
     */
    distinct?: PluginUsageScalarFieldEnum | PluginUsageScalarFieldEnum[]
  }

  /**
   * PluginUsage findFirstOrThrow
   */
  export type PluginUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * Filter, which PluginUsage to fetch.
     */
    where?: PluginUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginUsages to fetch.
     */
    orderBy?: PluginUsageOrderByWithRelationInput | PluginUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PluginUsages.
     */
    cursor?: PluginUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PluginUsages.
     */
    distinct?: PluginUsageScalarFieldEnum | PluginUsageScalarFieldEnum[]
  }

  /**
   * PluginUsage findMany
   */
  export type PluginUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * Filter, which PluginUsages to fetch.
     */
    where?: PluginUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginUsages to fetch.
     */
    orderBy?: PluginUsageOrderByWithRelationInput | PluginUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PluginUsages.
     */
    cursor?: PluginUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginUsages.
     */
    skip?: number
    distinct?: PluginUsageScalarFieldEnum | PluginUsageScalarFieldEnum[]
  }

  /**
   * PluginUsage create
   */
  export type PluginUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a PluginUsage.
     */
    data: XOR<PluginUsageCreateInput, PluginUsageUncheckedCreateInput>
  }

  /**
   * PluginUsage createMany
   */
  export type PluginUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PluginUsages.
     */
    data: PluginUsageCreateManyInput | PluginUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PluginUsage createManyAndReturn
   */
  export type PluginUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * The data used to create many PluginUsages.
     */
    data: PluginUsageCreateManyInput | PluginUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PluginUsage update
   */
  export type PluginUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a PluginUsage.
     */
    data: XOR<PluginUsageUpdateInput, PluginUsageUncheckedUpdateInput>
    /**
     * Choose, which PluginUsage to update.
     */
    where: PluginUsageWhereUniqueInput
  }

  /**
   * PluginUsage updateMany
   */
  export type PluginUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PluginUsages.
     */
    data: XOR<PluginUsageUpdateManyMutationInput, PluginUsageUncheckedUpdateManyInput>
    /**
     * Filter which PluginUsages to update
     */
    where?: PluginUsageWhereInput
    /**
     * Limit how many PluginUsages to update.
     */
    limit?: number
  }

  /**
   * PluginUsage updateManyAndReturn
   */
  export type PluginUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * The data used to update PluginUsages.
     */
    data: XOR<PluginUsageUpdateManyMutationInput, PluginUsageUncheckedUpdateManyInput>
    /**
     * Filter which PluginUsages to update
     */
    where?: PluginUsageWhereInput
    /**
     * Limit how many PluginUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PluginUsage upsert
   */
  export type PluginUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the PluginUsage to update in case it exists.
     */
    where: PluginUsageWhereUniqueInput
    /**
     * In case the PluginUsage found by the `where` argument doesn't exist, create a new PluginUsage with this data.
     */
    create: XOR<PluginUsageCreateInput, PluginUsageUncheckedCreateInput>
    /**
     * In case the PluginUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PluginUsageUpdateInput, PluginUsageUncheckedUpdateInput>
  }

  /**
   * PluginUsage delete
   */
  export type PluginUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
    /**
     * Filter which PluginUsage to delete.
     */
    where: PluginUsageWhereUniqueInput
  }

  /**
   * PluginUsage deleteMany
   */
  export type PluginUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PluginUsages to delete
     */
    where?: PluginUsageWhereInput
    /**
     * Limit how many PluginUsages to delete.
     */
    limit?: number
  }

  /**
   * PluginUsage without action
   */
  export type PluginUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginUsage
     */
    select?: PluginUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginUsage
     */
    omit?: PluginUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginUsageInclude<ExtArgs> | null
  }


  /**
   * Model UserAdministrator
   */

  export type AggregateUserAdministrator = {
    _count: UserAdministratorCountAggregateOutputType | null
    _min: UserAdministratorMinAggregateOutputType | null
    _max: UserAdministratorMaxAggregateOutputType | null
  }

  export type UserAdministratorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    canViewFinancials: boolean | null
    canManageStaff: boolean | null
    canEditAppointments: boolean | null
    canViewReports: boolean | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserAdministratorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    canViewFinancials: boolean | null
    canManageStaff: boolean | null
    canEditAppointments: boolean | null
    canViewReports: boolean | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserAdministratorCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    canViewFinancials: number
    canManageStaff: number
    canEditAppointments: number
    canViewReports: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type UserAdministratorMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    canViewFinancials?: true
    canManageStaff?: true
    canEditAppointments?: true
    canViewReports?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserAdministratorMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    canViewFinancials?: true
    canManageStaff?: true
    canEditAppointments?: true
    canViewReports?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserAdministratorCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    canViewFinancials?: true
    canManageStaff?: true
    canEditAppointments?: true
    canViewReports?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type UserAdministratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdministrator to aggregate.
     */
    where?: UserAdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdministrators to fetch.
     */
    orderBy?: UserAdministratorOrderByWithRelationInput | UserAdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdministrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdministrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAdministrators
    **/
    _count?: true | UserAdministratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAdministratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAdministratorMaxAggregateInputType
  }

  export type GetUserAdministratorAggregateType<T extends UserAdministratorAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAdministrator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAdministrator[P]>
      : GetScalarType<T[P], AggregateUserAdministrator[P]>
  }




  export type UserAdministratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAdministratorWhereInput
    orderBy?: UserAdministratorOrderByWithAggregationInput | UserAdministratorOrderByWithAggregationInput[]
    by: UserAdministratorScalarFieldEnum[] | UserAdministratorScalarFieldEnum
    having?: UserAdministratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAdministratorCountAggregateInputType | true
    _min?: UserAdministratorMinAggregateInputType
    _max?: UserAdministratorMaxAggregateInputType
  }

  export type UserAdministratorGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    canViewFinancials: boolean
    canManageStaff: boolean
    canEditAppointments: boolean
    canViewReports: boolean
    assignedAt: Date
    assignedBy: string | null
    _count: UserAdministratorCountAggregateOutputType | null
    _min: UserAdministratorMinAggregateOutputType | null
    _max: UserAdministratorMaxAggregateOutputType | null
  }

  type GetUserAdministratorGroupByPayload<T extends UserAdministratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAdministratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAdministratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAdministratorGroupByOutputType[P]>
            : GetScalarType<T[P], UserAdministratorGroupByOutputType[P]>
        }
      >
    >


  export type UserAdministratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAdministrator"]>

  export type UserAdministratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAdministrator"]>

  export type UserAdministratorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAdministrator"]>

  export type UserAdministratorSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type UserAdministratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "canViewFinancials" | "canManageStaff" | "canEditAppointments" | "canViewReports" | "assignedAt" | "assignedBy", ExtArgs["result"]["userAdministrator"]>
  export type UserAdministratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type UserAdministratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type UserAdministratorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $UserAdministratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAdministrator"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      canViewFinancials: boolean
      canManageStaff: boolean
      canEditAppointments: boolean
      canViewReports: boolean
      assignedAt: Date
      assignedBy: string | null
    }, ExtArgs["result"]["userAdministrator"]>
    composites: {}
  }

  type UserAdministratorGetPayload<S extends boolean | null | undefined | UserAdministratorDefaultArgs> = $Result.GetResult<Prisma.$UserAdministratorPayload, S>

  type UserAdministratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAdministratorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAdministratorCountAggregateInputType | true
    }

  export interface UserAdministratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAdministrator'], meta: { name: 'UserAdministrator' } }
    /**
     * Find zero or one UserAdministrator that matches the filter.
     * @param {UserAdministratorFindUniqueArgs} args - Arguments to find a UserAdministrator
     * @example
     * // Get one UserAdministrator
     * const userAdministrator = await prisma.userAdministrator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAdministratorFindUniqueArgs>(args: SelectSubset<T, UserAdministratorFindUniqueArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAdministrator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAdministratorFindUniqueOrThrowArgs} args - Arguments to find a UserAdministrator
     * @example
     * // Get one UserAdministrator
     * const userAdministrator = await prisma.userAdministrator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAdministratorFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAdministratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAdministrator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdministratorFindFirstArgs} args - Arguments to find a UserAdministrator
     * @example
     * // Get one UserAdministrator
     * const userAdministrator = await prisma.userAdministrator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAdministratorFindFirstArgs>(args?: SelectSubset<T, UserAdministratorFindFirstArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAdministrator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdministratorFindFirstOrThrowArgs} args - Arguments to find a UserAdministrator
     * @example
     * // Get one UserAdministrator
     * const userAdministrator = await prisma.userAdministrator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAdministratorFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAdministratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAdministrators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdministratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAdministrators
     * const userAdministrators = await prisma.userAdministrator.findMany()
     * 
     * // Get first 10 UserAdministrators
     * const userAdministrators = await prisma.userAdministrator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAdministratorWithIdOnly = await prisma.userAdministrator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAdministratorFindManyArgs>(args?: SelectSubset<T, UserAdministratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAdministrator.
     * @param {UserAdministratorCreateArgs} args - Arguments to create a UserAdministrator.
     * @example
     * // Create one UserAdministrator
     * const UserAdministrator = await prisma.userAdministrator.create({
     *   data: {
     *     // ... data to create a UserAdministrator
     *   }
     * })
     * 
     */
    create<T extends UserAdministratorCreateArgs>(args: SelectSubset<T, UserAdministratorCreateArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAdministrators.
     * @param {UserAdministratorCreateManyArgs} args - Arguments to create many UserAdministrators.
     * @example
     * // Create many UserAdministrators
     * const userAdministrator = await prisma.userAdministrator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAdministratorCreateManyArgs>(args?: SelectSubset<T, UserAdministratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAdministrators and returns the data saved in the database.
     * @param {UserAdministratorCreateManyAndReturnArgs} args - Arguments to create many UserAdministrators.
     * @example
     * // Create many UserAdministrators
     * const userAdministrator = await prisma.userAdministrator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAdministrators and only return the `id`
     * const userAdministratorWithIdOnly = await prisma.userAdministrator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAdministratorCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAdministratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAdministrator.
     * @param {UserAdministratorDeleteArgs} args - Arguments to delete one UserAdministrator.
     * @example
     * // Delete one UserAdministrator
     * const UserAdministrator = await prisma.userAdministrator.delete({
     *   where: {
     *     // ... filter to delete one UserAdministrator
     *   }
     * })
     * 
     */
    delete<T extends UserAdministratorDeleteArgs>(args: SelectSubset<T, UserAdministratorDeleteArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAdministrator.
     * @param {UserAdministratorUpdateArgs} args - Arguments to update one UserAdministrator.
     * @example
     * // Update one UserAdministrator
     * const userAdministrator = await prisma.userAdministrator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAdministratorUpdateArgs>(args: SelectSubset<T, UserAdministratorUpdateArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAdministrators.
     * @param {UserAdministratorDeleteManyArgs} args - Arguments to filter UserAdministrators to delete.
     * @example
     * // Delete a few UserAdministrators
     * const { count } = await prisma.userAdministrator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAdministratorDeleteManyArgs>(args?: SelectSubset<T, UserAdministratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAdministrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdministratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAdministrators
     * const userAdministrator = await prisma.userAdministrator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAdministratorUpdateManyArgs>(args: SelectSubset<T, UserAdministratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAdministrators and returns the data updated in the database.
     * @param {UserAdministratorUpdateManyAndReturnArgs} args - Arguments to update many UserAdministrators.
     * @example
     * // Update many UserAdministrators
     * const userAdministrator = await prisma.userAdministrator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAdministrators and only return the `id`
     * const userAdministratorWithIdOnly = await prisma.userAdministrator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAdministratorUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAdministratorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAdministrator.
     * @param {UserAdministratorUpsertArgs} args - Arguments to update or create a UserAdministrator.
     * @example
     * // Update or create a UserAdministrator
     * const userAdministrator = await prisma.userAdministrator.upsert({
     *   create: {
     *     // ... data to create a UserAdministrator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAdministrator we want to update
     *   }
     * })
     */
    upsert<T extends UserAdministratorUpsertArgs>(args: SelectSubset<T, UserAdministratorUpsertArgs<ExtArgs>>): Prisma__UserAdministratorClient<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAdministrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdministratorCountArgs} args - Arguments to filter UserAdministrators to count.
     * @example
     * // Count the number of UserAdministrators
     * const count = await prisma.userAdministrator.count({
     *   where: {
     *     // ... the filter for the UserAdministrators we want to count
     *   }
     * })
    **/
    count<T extends UserAdministratorCountArgs>(
      args?: Subset<T, UserAdministratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAdministratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAdministrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdministratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAdministratorAggregateArgs>(args: Subset<T, UserAdministratorAggregateArgs>): Prisma.PrismaPromise<GetUserAdministratorAggregateType<T>>

    /**
     * Group by UserAdministrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdministratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAdministratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAdministratorGroupByArgs['orderBy'] }
        : { orderBy?: UserAdministratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAdministratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAdministratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAdministrator model
   */
  readonly fields: UserAdministratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAdministrator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAdministratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAdministrator model
   */
  interface UserAdministratorFieldRefs {
    readonly id: FieldRef<"UserAdministrator", 'String'>
    readonly userId: FieldRef<"UserAdministrator", 'String'>
    readonly locationId: FieldRef<"UserAdministrator", 'String'>
    readonly canViewFinancials: FieldRef<"UserAdministrator", 'Boolean'>
    readonly canManageStaff: FieldRef<"UserAdministrator", 'Boolean'>
    readonly canEditAppointments: FieldRef<"UserAdministrator", 'Boolean'>
    readonly canViewReports: FieldRef<"UserAdministrator", 'Boolean'>
    readonly assignedAt: FieldRef<"UserAdministrator", 'DateTime'>
    readonly assignedBy: FieldRef<"UserAdministrator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAdministrator findUnique
   */
  export type UserAdministratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * Filter, which UserAdministrator to fetch.
     */
    where: UserAdministratorWhereUniqueInput
  }

  /**
   * UserAdministrator findUniqueOrThrow
   */
  export type UserAdministratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * Filter, which UserAdministrator to fetch.
     */
    where: UserAdministratorWhereUniqueInput
  }

  /**
   * UserAdministrator findFirst
   */
  export type UserAdministratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * Filter, which UserAdministrator to fetch.
     */
    where?: UserAdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdministrators to fetch.
     */
    orderBy?: UserAdministratorOrderByWithRelationInput | UserAdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdministrators.
     */
    cursor?: UserAdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdministrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdministrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdministrators.
     */
    distinct?: UserAdministratorScalarFieldEnum | UserAdministratorScalarFieldEnum[]
  }

  /**
   * UserAdministrator findFirstOrThrow
   */
  export type UserAdministratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * Filter, which UserAdministrator to fetch.
     */
    where?: UserAdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdministrators to fetch.
     */
    orderBy?: UserAdministratorOrderByWithRelationInput | UserAdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdministrators.
     */
    cursor?: UserAdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdministrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdministrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdministrators.
     */
    distinct?: UserAdministratorScalarFieldEnum | UserAdministratorScalarFieldEnum[]
  }

  /**
   * UserAdministrator findMany
   */
  export type UserAdministratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * Filter, which UserAdministrators to fetch.
     */
    where?: UserAdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdministrators to fetch.
     */
    orderBy?: UserAdministratorOrderByWithRelationInput | UserAdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAdministrators.
     */
    cursor?: UserAdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdministrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdministrators.
     */
    skip?: number
    distinct?: UserAdministratorScalarFieldEnum | UserAdministratorScalarFieldEnum[]
  }

  /**
   * UserAdministrator create
   */
  export type UserAdministratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAdministrator.
     */
    data: XOR<UserAdministratorCreateInput, UserAdministratorUncheckedCreateInput>
  }

  /**
   * UserAdministrator createMany
   */
  export type UserAdministratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAdministrators.
     */
    data: UserAdministratorCreateManyInput | UserAdministratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAdministrator createManyAndReturn
   */
  export type UserAdministratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * The data used to create many UserAdministrators.
     */
    data: UserAdministratorCreateManyInput | UserAdministratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAdministrator update
   */
  export type UserAdministratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAdministrator.
     */
    data: XOR<UserAdministratorUpdateInput, UserAdministratorUncheckedUpdateInput>
    /**
     * Choose, which UserAdministrator to update.
     */
    where: UserAdministratorWhereUniqueInput
  }

  /**
   * UserAdministrator updateMany
   */
  export type UserAdministratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAdministrators.
     */
    data: XOR<UserAdministratorUpdateManyMutationInput, UserAdministratorUncheckedUpdateManyInput>
    /**
     * Filter which UserAdministrators to update
     */
    where?: UserAdministratorWhereInput
    /**
     * Limit how many UserAdministrators to update.
     */
    limit?: number
  }

  /**
   * UserAdministrator updateManyAndReturn
   */
  export type UserAdministratorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * The data used to update UserAdministrators.
     */
    data: XOR<UserAdministratorUpdateManyMutationInput, UserAdministratorUncheckedUpdateManyInput>
    /**
     * Filter which UserAdministrators to update
     */
    where?: UserAdministratorWhereInput
    /**
     * Limit how many UserAdministrators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAdministrator upsert
   */
  export type UserAdministratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAdministrator to update in case it exists.
     */
    where: UserAdministratorWhereUniqueInput
    /**
     * In case the UserAdministrator found by the `where` argument doesn't exist, create a new UserAdministrator with this data.
     */
    create: XOR<UserAdministratorCreateInput, UserAdministratorUncheckedCreateInput>
    /**
     * In case the UserAdministrator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAdministratorUpdateInput, UserAdministratorUncheckedUpdateInput>
  }

  /**
   * UserAdministrator delete
   */
  export type UserAdministratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    /**
     * Filter which UserAdministrator to delete.
     */
    where: UserAdministratorWhereUniqueInput
  }

  /**
   * UserAdministrator deleteMany
   */
  export type UserAdministratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdministrators to delete
     */
    where?: UserAdministratorWhereInput
    /**
     * Limit how many UserAdministrators to delete.
     */
    limit?: number
  }

  /**
   * UserAdministrator without action
   */
  export type UserAdministratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
  }


  /**
   * Model Territory
   */

  export type AggregateTerritory = {
    _count: TerritoryCountAggregateOutputType | null
    _avg: TerritoryAvgAggregateOutputType | null
    _sum: TerritorySumAggregateOutputType | null
    _min: TerritoryMinAggregateOutputType | null
    _max: TerritoryMaxAggregateOutputType | null
  }

  export type TerritoryAvgAggregateOutputType = {
    exclusiveRadius: number | null
    populationServed: number | null
    marketPenetration: number | null
  }

  export type TerritorySumAggregateOutputType = {
    exclusiveRadius: number | null
    populationServed: number | null
    marketPenetration: number | null
  }

  export type TerritoryMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    territoryCode: string | null
    territoryName: string | null
    territoryAddress: string | null
    territoryCity: string | null
    territoryState: string | null
    territoryZipCode: string | null
    territoryPhone: string | null
    territoryEmail: string | null
    exclusiveRadius: number | null
    populationServed: number | null
    marketPenetration: number | null
    assignedAt: Date | null
  }

  export type TerritoryMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    territoryCode: string | null
    territoryName: string | null
    territoryAddress: string | null
    territoryCity: string | null
    territoryState: string | null
    territoryZipCode: string | null
    territoryPhone: string | null
    territoryEmail: string | null
    exclusiveRadius: number | null
    populationServed: number | null
    marketPenetration: number | null
    assignedAt: Date | null
  }

  export type TerritoryCountAggregateOutputType = {
    id: number
    locationId: number
    territoryCode: number
    territoryName: number
    territoryAddress: number
    territoryCity: number
    territoryState: number
    territoryZipCode: number
    territoryPhone: number
    territoryEmail: number
    exclusiveRadius: number
    populationServed: number
    marketPenetration: number
    assignedAt: number
    _all: number
  }


  export type TerritoryAvgAggregateInputType = {
    exclusiveRadius?: true
    populationServed?: true
    marketPenetration?: true
  }

  export type TerritorySumAggregateInputType = {
    exclusiveRadius?: true
    populationServed?: true
    marketPenetration?: true
  }

  export type TerritoryMinAggregateInputType = {
    id?: true
    locationId?: true
    territoryCode?: true
    territoryName?: true
    territoryAddress?: true
    territoryCity?: true
    territoryState?: true
    territoryZipCode?: true
    territoryPhone?: true
    territoryEmail?: true
    exclusiveRadius?: true
    populationServed?: true
    marketPenetration?: true
    assignedAt?: true
  }

  export type TerritoryMaxAggregateInputType = {
    id?: true
    locationId?: true
    territoryCode?: true
    territoryName?: true
    territoryAddress?: true
    territoryCity?: true
    territoryState?: true
    territoryZipCode?: true
    territoryPhone?: true
    territoryEmail?: true
    exclusiveRadius?: true
    populationServed?: true
    marketPenetration?: true
    assignedAt?: true
  }

  export type TerritoryCountAggregateInputType = {
    id?: true
    locationId?: true
    territoryCode?: true
    territoryName?: true
    territoryAddress?: true
    territoryCity?: true
    territoryState?: true
    territoryZipCode?: true
    territoryPhone?: true
    territoryEmail?: true
    exclusiveRadius?: true
    populationServed?: true
    marketPenetration?: true
    assignedAt?: true
    _all?: true
  }

  export type TerritoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Territory to aggregate.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Territories
    **/
    _count?: true | TerritoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TerritoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TerritorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerritoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerritoryMaxAggregateInputType
  }

  export type GetTerritoryAggregateType<T extends TerritoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTerritory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerritory[P]>
      : GetScalarType<T[P], AggregateTerritory[P]>
  }




  export type TerritoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoryWhereInput
    orderBy?: TerritoryOrderByWithAggregationInput | TerritoryOrderByWithAggregationInput[]
    by: TerritoryScalarFieldEnum[] | TerritoryScalarFieldEnum
    having?: TerritoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerritoryCountAggregateInputType | true
    _avg?: TerritoryAvgAggregateInputType
    _sum?: TerritorySumAggregateInputType
    _min?: TerritoryMinAggregateInputType
    _max?: TerritoryMaxAggregateInputType
  }

  export type TerritoryGroupByOutputType = {
    id: string
    locationId: string
    territoryCode: string
    territoryName: string
    territoryAddress: string | null
    territoryCity: string | null
    territoryState: string | null
    territoryZipCode: string | null
    territoryPhone: string | null
    territoryEmail: string | null
    exclusiveRadius: number | null
    populationServed: number | null
    marketPenetration: number | null
    assignedAt: Date
    _count: TerritoryCountAggregateOutputType | null
    _avg: TerritoryAvgAggregateOutputType | null
    _sum: TerritorySumAggregateOutputType | null
    _min: TerritoryMinAggregateOutputType | null
    _max: TerritoryMaxAggregateOutputType | null
  }

  type GetTerritoryGroupByPayload<T extends TerritoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerritoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerritoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerritoryGroupByOutputType[P]>
            : GetScalarType<T[P], TerritoryGroupByOutputType[P]>
        }
      >
    >


  export type TerritorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    territoryAddress?: boolean
    territoryCity?: boolean
    territoryState?: boolean
    territoryZipCode?: boolean
    territoryPhone?: boolean
    territoryEmail?: boolean
    exclusiveRadius?: boolean
    populationServed?: boolean
    marketPenetration?: boolean
    assignedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["territory"]>

  export type TerritorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    territoryAddress?: boolean
    territoryCity?: boolean
    territoryState?: boolean
    territoryZipCode?: boolean
    territoryPhone?: boolean
    territoryEmail?: boolean
    exclusiveRadius?: boolean
    populationServed?: boolean
    marketPenetration?: boolean
    assignedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["territory"]>

  export type TerritorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    territoryAddress?: boolean
    territoryCity?: boolean
    territoryState?: boolean
    territoryZipCode?: boolean
    territoryPhone?: boolean
    territoryEmail?: boolean
    exclusiveRadius?: boolean
    populationServed?: boolean
    marketPenetration?: boolean
    assignedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["territory"]>

  export type TerritorySelectScalar = {
    id?: boolean
    locationId?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    territoryAddress?: boolean
    territoryCity?: boolean
    territoryState?: boolean
    territoryZipCode?: boolean
    territoryPhone?: boolean
    territoryEmail?: boolean
    exclusiveRadius?: boolean
    populationServed?: boolean
    marketPenetration?: boolean
    assignedAt?: boolean
  }

  export type TerritoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "territoryCode" | "territoryName" | "territoryAddress" | "territoryCity" | "territoryState" | "territoryZipCode" | "territoryPhone" | "territoryEmail" | "exclusiveRadius" | "populationServed" | "marketPenetration" | "assignedAt", ExtArgs["result"]["territory"]>
  export type TerritoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type TerritoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type TerritoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $TerritoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Territory"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      territoryCode: string
      territoryName: string
      territoryAddress: string | null
      territoryCity: string | null
      territoryState: string | null
      territoryZipCode: string | null
      territoryPhone: string | null
      territoryEmail: string | null
      exclusiveRadius: number | null
      populationServed: number | null
      marketPenetration: number | null
      assignedAt: Date
    }, ExtArgs["result"]["territory"]>
    composites: {}
  }

  type TerritoryGetPayload<S extends boolean | null | undefined | TerritoryDefaultArgs> = $Result.GetResult<Prisma.$TerritoryPayload, S>

  type TerritoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TerritoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TerritoryCountAggregateInputType | true
    }

  export interface TerritoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Territory'], meta: { name: 'Territory' } }
    /**
     * Find zero or one Territory that matches the filter.
     * @param {TerritoryFindUniqueArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerritoryFindUniqueArgs>(args: SelectSubset<T, TerritoryFindUniqueArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Territory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TerritoryFindUniqueOrThrowArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerritoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TerritoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Territory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryFindFirstArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerritoryFindFirstArgs>(args?: SelectSubset<T, TerritoryFindFirstArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Territory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryFindFirstOrThrowArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerritoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TerritoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Territories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Territories
     * const territories = await prisma.territory.findMany()
     * 
     * // Get first 10 Territories
     * const territories = await prisma.territory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const territoryWithIdOnly = await prisma.territory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerritoryFindManyArgs>(args?: SelectSubset<T, TerritoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Territory.
     * @param {TerritoryCreateArgs} args - Arguments to create a Territory.
     * @example
     * // Create one Territory
     * const Territory = await prisma.territory.create({
     *   data: {
     *     // ... data to create a Territory
     *   }
     * })
     * 
     */
    create<T extends TerritoryCreateArgs>(args: SelectSubset<T, TerritoryCreateArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Territories.
     * @param {TerritoryCreateManyArgs} args - Arguments to create many Territories.
     * @example
     * // Create many Territories
     * const territory = await prisma.territory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerritoryCreateManyArgs>(args?: SelectSubset<T, TerritoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Territories and returns the data saved in the database.
     * @param {TerritoryCreateManyAndReturnArgs} args - Arguments to create many Territories.
     * @example
     * // Create many Territories
     * const territory = await prisma.territory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Territories and only return the `id`
     * const territoryWithIdOnly = await prisma.territory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerritoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TerritoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Territory.
     * @param {TerritoryDeleteArgs} args - Arguments to delete one Territory.
     * @example
     * // Delete one Territory
     * const Territory = await prisma.territory.delete({
     *   where: {
     *     // ... filter to delete one Territory
     *   }
     * })
     * 
     */
    delete<T extends TerritoryDeleteArgs>(args: SelectSubset<T, TerritoryDeleteArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Territory.
     * @param {TerritoryUpdateArgs} args - Arguments to update one Territory.
     * @example
     * // Update one Territory
     * const territory = await prisma.territory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerritoryUpdateArgs>(args: SelectSubset<T, TerritoryUpdateArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Territories.
     * @param {TerritoryDeleteManyArgs} args - Arguments to filter Territories to delete.
     * @example
     * // Delete a few Territories
     * const { count } = await prisma.territory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerritoryDeleteManyArgs>(args?: SelectSubset<T, TerritoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Territories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Territories
     * const territory = await prisma.territory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerritoryUpdateManyArgs>(args: SelectSubset<T, TerritoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Territories and returns the data updated in the database.
     * @param {TerritoryUpdateManyAndReturnArgs} args - Arguments to update many Territories.
     * @example
     * // Update many Territories
     * const territory = await prisma.territory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Territories and only return the `id`
     * const territoryWithIdOnly = await prisma.territory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TerritoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TerritoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Territory.
     * @param {TerritoryUpsertArgs} args - Arguments to update or create a Territory.
     * @example
     * // Update or create a Territory
     * const territory = await prisma.territory.upsert({
     *   create: {
     *     // ... data to create a Territory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Territory we want to update
     *   }
     * })
     */
    upsert<T extends TerritoryUpsertArgs>(args: SelectSubset<T, TerritoryUpsertArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Territories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryCountArgs} args - Arguments to filter Territories to count.
     * @example
     * // Count the number of Territories
     * const count = await prisma.territory.count({
     *   where: {
     *     // ... the filter for the Territories we want to count
     *   }
     * })
    **/
    count<T extends TerritoryCountArgs>(
      args?: Subset<T, TerritoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerritoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Territory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerritoryAggregateArgs>(args: Subset<T, TerritoryAggregateArgs>): Prisma.PrismaPromise<GetTerritoryAggregateType<T>>

    /**
     * Group by Territory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerritoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerritoryGroupByArgs['orderBy'] }
        : { orderBy?: TerritoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerritoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerritoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Territory model
   */
  readonly fields: TerritoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Territory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerritoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Territory model
   */
  interface TerritoryFieldRefs {
    readonly id: FieldRef<"Territory", 'String'>
    readonly locationId: FieldRef<"Territory", 'String'>
    readonly territoryCode: FieldRef<"Territory", 'String'>
    readonly territoryName: FieldRef<"Territory", 'String'>
    readonly territoryAddress: FieldRef<"Territory", 'String'>
    readonly territoryCity: FieldRef<"Territory", 'String'>
    readonly territoryState: FieldRef<"Territory", 'String'>
    readonly territoryZipCode: FieldRef<"Territory", 'String'>
    readonly territoryPhone: FieldRef<"Territory", 'String'>
    readonly territoryEmail: FieldRef<"Territory", 'String'>
    readonly exclusiveRadius: FieldRef<"Territory", 'Float'>
    readonly populationServed: FieldRef<"Territory", 'Int'>
    readonly marketPenetration: FieldRef<"Territory", 'Float'>
    readonly assignedAt: FieldRef<"Territory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Territory findUnique
   */
  export type TerritoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory findUniqueOrThrow
   */
  export type TerritoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory findFirst
   */
  export type TerritoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Territories.
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Territories.
     */
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Territory findFirstOrThrow
   */
  export type TerritoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Territories.
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Territories.
     */
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Territory findMany
   */
  export type TerritoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territories to fetch.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Territories.
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Territory create
   */
  export type TerritoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Territory.
     */
    data: XOR<TerritoryCreateInput, TerritoryUncheckedCreateInput>
  }

  /**
   * Territory createMany
   */
  export type TerritoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Territories.
     */
    data: TerritoryCreateManyInput | TerritoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Territory createManyAndReturn
   */
  export type TerritoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * The data used to create many Territories.
     */
    data: TerritoryCreateManyInput | TerritoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Territory update
   */
  export type TerritoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Territory.
     */
    data: XOR<TerritoryUpdateInput, TerritoryUncheckedUpdateInput>
    /**
     * Choose, which Territory to update.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory updateMany
   */
  export type TerritoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Territories.
     */
    data: XOR<TerritoryUpdateManyMutationInput, TerritoryUncheckedUpdateManyInput>
    /**
     * Filter which Territories to update
     */
    where?: TerritoryWhereInput
    /**
     * Limit how many Territories to update.
     */
    limit?: number
  }

  /**
   * Territory updateManyAndReturn
   */
  export type TerritoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * The data used to update Territories.
     */
    data: XOR<TerritoryUpdateManyMutationInput, TerritoryUncheckedUpdateManyInput>
    /**
     * Filter which Territories to update
     */
    where?: TerritoryWhereInput
    /**
     * Limit how many Territories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Territory upsert
   */
  export type TerritoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Territory to update in case it exists.
     */
    where: TerritoryWhereUniqueInput
    /**
     * In case the Territory found by the `where` argument doesn't exist, create a new Territory with this data.
     */
    create: XOR<TerritoryCreateInput, TerritoryUncheckedCreateInput>
    /**
     * In case the Territory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerritoryUpdateInput, TerritoryUncheckedUpdateInput>
  }

  /**
   * Territory delete
   */
  export type TerritoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter which Territory to delete.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory deleteMany
   */
  export type TerritoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Territories to delete
     */
    where?: TerritoryWhereInput
    /**
     * Limit how many Territories to delete.
     */
    limit?: number
  }

  /**
   * Territory without action
   */
  export type TerritoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
  }


  /**
   * Model CSI
   */

  export type AggregateCSI = {
    _count: CSICountAggregateOutputType | null
    _avg: CSIAvgAggregateOutputType | null
    _sum: CSISumAggregateOutputType | null
    _min: CSIMinAggregateOutputType | null
    _max: CSIMaxAggregateOutputType | null
  }

  export type CSIAvgAggregateOutputType = {
    score: number | null
  }

  export type CSISumAggregateOutputType = {
    score: number | null
  }

  export type CSIMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    score: number | null
    comment: string | null
    source: $Enums.CSISource | null
    surveyType: string | null
    customerId: string | null
    recordedAt: Date | null
    recordedBy: string | null
  }

  export type CSIMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    score: number | null
    comment: string | null
    source: $Enums.CSISource | null
    surveyType: string | null
    customerId: string | null
    recordedAt: Date | null
    recordedBy: string | null
  }

  export type CSICountAggregateOutputType = {
    id: number
    locationId: number
    score: number
    comment: number
    source: number
    surveyType: number
    customerId: number
    recordedAt: number
    recordedBy: number
    _all: number
  }


  export type CSIAvgAggregateInputType = {
    score?: true
  }

  export type CSISumAggregateInputType = {
    score?: true
  }

  export type CSIMinAggregateInputType = {
    id?: true
    locationId?: true
    score?: true
    comment?: true
    source?: true
    surveyType?: true
    customerId?: true
    recordedAt?: true
    recordedBy?: true
  }

  export type CSIMaxAggregateInputType = {
    id?: true
    locationId?: true
    score?: true
    comment?: true
    source?: true
    surveyType?: true
    customerId?: true
    recordedAt?: true
    recordedBy?: true
  }

  export type CSICountAggregateInputType = {
    id?: true
    locationId?: true
    score?: true
    comment?: true
    source?: true
    surveyType?: true
    customerId?: true
    recordedAt?: true
    recordedBy?: true
    _all?: true
  }

  export type CSIAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CSI to aggregate.
     */
    where?: CSIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSIS to fetch.
     */
    orderBy?: CSIOrderByWithRelationInput | CSIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CSIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CSIS
    **/
    _count?: true | CSICountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CSIAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CSISumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CSIMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CSIMaxAggregateInputType
  }

  export type GetCSIAggregateType<T extends CSIAggregateArgs> = {
        [P in keyof T & keyof AggregateCSI]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCSI[P]>
      : GetScalarType<T[P], AggregateCSI[P]>
  }




  export type CSIGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CSIWhereInput
    orderBy?: CSIOrderByWithAggregationInput | CSIOrderByWithAggregationInput[]
    by: CSIScalarFieldEnum[] | CSIScalarFieldEnum
    having?: CSIScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CSICountAggregateInputType | true
    _avg?: CSIAvgAggregateInputType
    _sum?: CSISumAggregateInputType
    _min?: CSIMinAggregateInputType
    _max?: CSIMaxAggregateInputType
  }

  export type CSIGroupByOutputType = {
    id: string
    locationId: string
    score: number
    comment: string | null
    source: $Enums.CSISource
    surveyType: string | null
    customerId: string | null
    recordedAt: Date
    recordedBy: string | null
    _count: CSICountAggregateOutputType | null
    _avg: CSIAvgAggregateOutputType | null
    _sum: CSISumAggregateOutputType | null
    _min: CSIMinAggregateOutputType | null
    _max: CSIMaxAggregateOutputType | null
  }

  type GetCSIGroupByPayload<T extends CSIGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CSIGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CSIGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CSIGroupByOutputType[P]>
            : GetScalarType<T[P], CSIGroupByOutputType[P]>
        }
      >
    >


  export type CSISelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    score?: boolean
    comment?: boolean
    source?: boolean
    surveyType?: boolean
    customerId?: boolean
    recordedAt?: boolean
    recordedBy?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CSI$customerArgs<ExtArgs>
  }, ExtArgs["result"]["cSI"]>

  export type CSISelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    score?: boolean
    comment?: boolean
    source?: boolean
    surveyType?: boolean
    customerId?: boolean
    recordedAt?: boolean
    recordedBy?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CSI$customerArgs<ExtArgs>
  }, ExtArgs["result"]["cSI"]>

  export type CSISelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    score?: boolean
    comment?: boolean
    source?: boolean
    surveyType?: boolean
    customerId?: boolean
    recordedAt?: boolean
    recordedBy?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CSI$customerArgs<ExtArgs>
  }, ExtArgs["result"]["cSI"]>

  export type CSISelectScalar = {
    id?: boolean
    locationId?: boolean
    score?: boolean
    comment?: boolean
    source?: boolean
    surveyType?: boolean
    customerId?: boolean
    recordedAt?: boolean
    recordedBy?: boolean
  }

  export type CSIOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "score" | "comment" | "source" | "surveyType" | "customerId" | "recordedAt" | "recordedBy", ExtArgs["result"]["cSI"]>
  export type CSIInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CSI$customerArgs<ExtArgs>
  }
  export type CSIIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CSI$customerArgs<ExtArgs>
  }
  export type CSIIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CSI$customerArgs<ExtArgs>
  }

  export type $CSIPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CSI"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      score: number
      comment: string | null
      source: $Enums.CSISource
      surveyType: string | null
      customerId: string | null
      recordedAt: Date
      recordedBy: string | null
    }, ExtArgs["result"]["cSI"]>
    composites: {}
  }

  type CSIGetPayload<S extends boolean | null | undefined | CSIDefaultArgs> = $Result.GetResult<Prisma.$CSIPayload, S>

  type CSICountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CSIFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CSICountAggregateInputType | true
    }

  export interface CSIDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CSI'], meta: { name: 'CSI' } }
    /**
     * Find zero or one CSI that matches the filter.
     * @param {CSIFindUniqueArgs} args - Arguments to find a CSI
     * @example
     * // Get one CSI
     * const cSI = await prisma.cSI.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CSIFindUniqueArgs>(args: SelectSubset<T, CSIFindUniqueArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CSI that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CSIFindUniqueOrThrowArgs} args - Arguments to find a CSI
     * @example
     * // Get one CSI
     * const cSI = await prisma.cSI.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CSIFindUniqueOrThrowArgs>(args: SelectSubset<T, CSIFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CSI that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSIFindFirstArgs} args - Arguments to find a CSI
     * @example
     * // Get one CSI
     * const cSI = await prisma.cSI.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CSIFindFirstArgs>(args?: SelectSubset<T, CSIFindFirstArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CSI that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSIFindFirstOrThrowArgs} args - Arguments to find a CSI
     * @example
     * // Get one CSI
     * const cSI = await prisma.cSI.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CSIFindFirstOrThrowArgs>(args?: SelectSubset<T, CSIFindFirstOrThrowArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CSIS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSIFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CSIS
     * const cSIS = await prisma.cSI.findMany()
     * 
     * // Get first 10 CSIS
     * const cSIS = await prisma.cSI.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cSIWithIdOnly = await prisma.cSI.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CSIFindManyArgs>(args?: SelectSubset<T, CSIFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CSI.
     * @param {CSICreateArgs} args - Arguments to create a CSI.
     * @example
     * // Create one CSI
     * const CSI = await prisma.cSI.create({
     *   data: {
     *     // ... data to create a CSI
     *   }
     * })
     * 
     */
    create<T extends CSICreateArgs>(args: SelectSubset<T, CSICreateArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CSIS.
     * @param {CSICreateManyArgs} args - Arguments to create many CSIS.
     * @example
     * // Create many CSIS
     * const cSI = await prisma.cSI.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CSICreateManyArgs>(args?: SelectSubset<T, CSICreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CSIS and returns the data saved in the database.
     * @param {CSICreateManyAndReturnArgs} args - Arguments to create many CSIS.
     * @example
     * // Create many CSIS
     * const cSI = await prisma.cSI.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CSIS and only return the `id`
     * const cSIWithIdOnly = await prisma.cSI.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CSICreateManyAndReturnArgs>(args?: SelectSubset<T, CSICreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CSI.
     * @param {CSIDeleteArgs} args - Arguments to delete one CSI.
     * @example
     * // Delete one CSI
     * const CSI = await prisma.cSI.delete({
     *   where: {
     *     // ... filter to delete one CSI
     *   }
     * })
     * 
     */
    delete<T extends CSIDeleteArgs>(args: SelectSubset<T, CSIDeleteArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CSI.
     * @param {CSIUpdateArgs} args - Arguments to update one CSI.
     * @example
     * // Update one CSI
     * const cSI = await prisma.cSI.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CSIUpdateArgs>(args: SelectSubset<T, CSIUpdateArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CSIS.
     * @param {CSIDeleteManyArgs} args - Arguments to filter CSIS to delete.
     * @example
     * // Delete a few CSIS
     * const { count } = await prisma.cSI.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CSIDeleteManyArgs>(args?: SelectSubset<T, CSIDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CSIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSIUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CSIS
     * const cSI = await prisma.cSI.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CSIUpdateManyArgs>(args: SelectSubset<T, CSIUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CSIS and returns the data updated in the database.
     * @param {CSIUpdateManyAndReturnArgs} args - Arguments to update many CSIS.
     * @example
     * // Update many CSIS
     * const cSI = await prisma.cSI.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CSIS and only return the `id`
     * const cSIWithIdOnly = await prisma.cSI.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CSIUpdateManyAndReturnArgs>(args: SelectSubset<T, CSIUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CSI.
     * @param {CSIUpsertArgs} args - Arguments to update or create a CSI.
     * @example
     * // Update or create a CSI
     * const cSI = await prisma.cSI.upsert({
     *   create: {
     *     // ... data to create a CSI
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CSI we want to update
     *   }
     * })
     */
    upsert<T extends CSIUpsertArgs>(args: SelectSubset<T, CSIUpsertArgs<ExtArgs>>): Prisma__CSIClient<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CSIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSICountArgs} args - Arguments to filter CSIS to count.
     * @example
     * // Count the number of CSIS
     * const count = await prisma.cSI.count({
     *   where: {
     *     // ... the filter for the CSIS we want to count
     *   }
     * })
    **/
    count<T extends CSICountArgs>(
      args?: Subset<T, CSICountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CSICountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CSI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSIAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CSIAggregateArgs>(args: Subset<T, CSIAggregateArgs>): Prisma.PrismaPromise<GetCSIAggregateType<T>>

    /**
     * Group by CSI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CSIGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CSIGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CSIGroupByArgs['orderBy'] }
        : { orderBy?: CSIGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CSIGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCSIGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CSI model
   */
  readonly fields: CSIFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CSI.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CSIClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CSI$customerArgs<ExtArgs> = {}>(args?: Subset<T, CSI$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CSI model
   */
  interface CSIFieldRefs {
    readonly id: FieldRef<"CSI", 'String'>
    readonly locationId: FieldRef<"CSI", 'String'>
    readonly score: FieldRef<"CSI", 'Int'>
    readonly comment: FieldRef<"CSI", 'String'>
    readonly source: FieldRef<"CSI", 'CSISource'>
    readonly surveyType: FieldRef<"CSI", 'String'>
    readonly customerId: FieldRef<"CSI", 'String'>
    readonly recordedAt: FieldRef<"CSI", 'DateTime'>
    readonly recordedBy: FieldRef<"CSI", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CSI findUnique
   */
  export type CSIFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * Filter, which CSI to fetch.
     */
    where: CSIWhereUniqueInput
  }

  /**
   * CSI findUniqueOrThrow
   */
  export type CSIFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * Filter, which CSI to fetch.
     */
    where: CSIWhereUniqueInput
  }

  /**
   * CSI findFirst
   */
  export type CSIFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * Filter, which CSI to fetch.
     */
    where?: CSIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSIS to fetch.
     */
    orderBy?: CSIOrderByWithRelationInput | CSIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CSIS.
     */
    cursor?: CSIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CSIS.
     */
    distinct?: CSIScalarFieldEnum | CSIScalarFieldEnum[]
  }

  /**
   * CSI findFirstOrThrow
   */
  export type CSIFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * Filter, which CSI to fetch.
     */
    where?: CSIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSIS to fetch.
     */
    orderBy?: CSIOrderByWithRelationInput | CSIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CSIS.
     */
    cursor?: CSIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CSIS.
     */
    distinct?: CSIScalarFieldEnum | CSIScalarFieldEnum[]
  }

  /**
   * CSI findMany
   */
  export type CSIFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * Filter, which CSIS to fetch.
     */
    where?: CSIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CSIS to fetch.
     */
    orderBy?: CSIOrderByWithRelationInput | CSIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CSIS.
     */
    cursor?: CSIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CSIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CSIS.
     */
    skip?: number
    distinct?: CSIScalarFieldEnum | CSIScalarFieldEnum[]
  }

  /**
   * CSI create
   */
  export type CSICreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * The data needed to create a CSI.
     */
    data: XOR<CSICreateInput, CSIUncheckedCreateInput>
  }

  /**
   * CSI createMany
   */
  export type CSICreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CSIS.
     */
    data: CSICreateManyInput | CSICreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CSI createManyAndReturn
   */
  export type CSICreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * The data used to create many CSIS.
     */
    data: CSICreateManyInput | CSICreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CSI update
   */
  export type CSIUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * The data needed to update a CSI.
     */
    data: XOR<CSIUpdateInput, CSIUncheckedUpdateInput>
    /**
     * Choose, which CSI to update.
     */
    where: CSIWhereUniqueInput
  }

  /**
   * CSI updateMany
   */
  export type CSIUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CSIS.
     */
    data: XOR<CSIUpdateManyMutationInput, CSIUncheckedUpdateManyInput>
    /**
     * Filter which CSIS to update
     */
    where?: CSIWhereInput
    /**
     * Limit how many CSIS to update.
     */
    limit?: number
  }

  /**
   * CSI updateManyAndReturn
   */
  export type CSIUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * The data used to update CSIS.
     */
    data: XOR<CSIUpdateManyMutationInput, CSIUncheckedUpdateManyInput>
    /**
     * Filter which CSIS to update
     */
    where?: CSIWhereInput
    /**
     * Limit how many CSIS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CSI upsert
   */
  export type CSIUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * The filter to search for the CSI to update in case it exists.
     */
    where: CSIWhereUniqueInput
    /**
     * In case the CSI found by the `where` argument doesn't exist, create a new CSI with this data.
     */
    create: XOR<CSICreateInput, CSIUncheckedCreateInput>
    /**
     * In case the CSI was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CSIUpdateInput, CSIUncheckedUpdateInput>
  }

  /**
   * CSI delete
   */
  export type CSIDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    /**
     * Filter which CSI to delete.
     */
    where: CSIWhereUniqueInput
  }

  /**
   * CSI deleteMany
   */
  export type CSIDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CSIS to delete
     */
    where?: CSIWhereInput
    /**
     * Limit how many CSIS to delete.
     */
    limit?: number
  }

  /**
   * CSI.customer
   */
  export type CSI$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * CSI without action
   */
  export type CSIDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    franchiseFeeRate: number | null
    royaltyRate: number | null
    currentCSIAverage: number | null
  }

  export type LocationSumAggregateOutputType = {
    franchiseFeeRate: number | null
    royaltyRate: number | null
    currentCSIAverage: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    franchiseId: string | null
    ownerId: string | null
    franchiseFeeRate: number | null
    royaltyRate: number | null
    timezone: string | null
    currentCSIAverage: number | null
    lastCSIUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    franchiseId: string | null
    ownerId: string | null
    franchiseFeeRate: number | null
    royaltyRate: number | null
    timezone: string | null
    currentCSIAverage: number | null
    lastCSIUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    city: number
    state: number
    zipCode: number
    phone: number
    email: number
    isActive: number
    franchiseId: number
    ownerId: number
    franchiseFeeRate: number
    royaltyRate: number
    timezone: number
    businessHours: number
    currentCSIAverage: number
    lastCSIUpdate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    franchiseFeeRate?: true
    royaltyRate?: true
    currentCSIAverage?: true
  }

  export type LocationSumAggregateInputType = {
    franchiseFeeRate?: true
    royaltyRate?: true
    currentCSIAverage?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    isActive?: true
    franchiseId?: true
    ownerId?: true
    franchiseFeeRate?: true
    royaltyRate?: true
    timezone?: true
    currentCSIAverage?: true
    lastCSIUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    isActive?: true
    franchiseId?: true
    ownerId?: true
    franchiseFeeRate?: true
    royaltyRate?: true
    timezone?: true
    currentCSIAverage?: true
    lastCSIUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    isActive?: true
    franchiseId?: true
    ownerId?: true
    franchiseFeeRate?: true
    royaltyRate?: true
    timezone?: true
    businessHours?: true
    currentCSIAverage?: true
    lastCSIUpdate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive: boolean
    franchiseId: string | null
    ownerId: string | null
    franchiseFeeRate: number | null
    royaltyRate: number | null
    timezone: string
    businessHours: JsonValue | null
    currentCSIAverage: number | null
    lastCSIUpdate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    franchiseId?: boolean
    ownerId?: boolean
    franchiseFeeRate?: boolean
    royaltyRate?: boolean
    timezone?: boolean
    businessHours?: boolean
    currentCSIAverage?: boolean
    lastCSIUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Location$ownerArgs<ExtArgs>
    territory?: boolean | Location$territoryArgs<ExtArgs>
    csiRecords?: boolean | Location$csiRecordsArgs<ExtArgs>
    adminUsers?: boolean | Location$adminUsersArgs<ExtArgs>
    customers?: boolean | Location$customersArgs<ExtArgs>
    appointments?: boolean | Location$appointmentsArgs<ExtArgs>
    subscriptions?: boolean | Location$subscriptionsArgs<ExtArgs>
    orders?: boolean | Location$ordersArgs<ExtArgs>
    products?: boolean | Location$productsArgs<ExtArgs>
    franchiseFees?: boolean | Location$franchiseFeesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    franchiseId?: boolean
    ownerId?: boolean
    franchiseFeeRate?: boolean
    royaltyRate?: boolean
    timezone?: boolean
    businessHours?: boolean
    currentCSIAverage?: boolean
    lastCSIUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Location$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    franchiseId?: boolean
    ownerId?: boolean
    franchiseFeeRate?: boolean
    royaltyRate?: boolean
    timezone?: boolean
    businessHours?: boolean
    currentCSIAverage?: boolean
    lastCSIUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Location$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    franchiseId?: boolean
    ownerId?: boolean
    franchiseFeeRate?: boolean
    royaltyRate?: boolean
    timezone?: boolean
    businessHours?: boolean
    currentCSIAverage?: boolean
    lastCSIUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "city" | "state" | "zipCode" | "phone" | "email" | "isActive" | "franchiseId" | "ownerId" | "franchiseFeeRate" | "royaltyRate" | "timezone" | "businessHours" | "currentCSIAverage" | "lastCSIUpdate" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Location$ownerArgs<ExtArgs>
    territory?: boolean | Location$territoryArgs<ExtArgs>
    csiRecords?: boolean | Location$csiRecordsArgs<ExtArgs>
    adminUsers?: boolean | Location$adminUsersArgs<ExtArgs>
    customers?: boolean | Location$customersArgs<ExtArgs>
    appointments?: boolean | Location$appointmentsArgs<ExtArgs>
    subscriptions?: boolean | Location$subscriptionsArgs<ExtArgs>
    orders?: boolean | Location$ordersArgs<ExtArgs>
    products?: boolean | Location$productsArgs<ExtArgs>
    franchiseFees?: boolean | Location$franchiseFeesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Location$ownerArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Location$ownerArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      territory: Prisma.$TerritoryPayload<ExtArgs> | null
      csiRecords: Prisma.$CSIPayload<ExtArgs>[]
      adminUsers: Prisma.$UserAdministratorPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      franchiseFees: Prisma.$FranchiseFeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      city: string
      state: string
      zipCode: string
      phone: string
      email: string
      isActive: boolean
      franchiseId: string | null
      ownerId: string | null
      franchiseFeeRate: number | null
      royaltyRate: number | null
      timezone: string
      businessHours: Prisma.JsonValue | null
      currentCSIAverage: number | null
      lastCSIUpdate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends Location$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Location$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    territory<T extends Location$territoryArgs<ExtArgs> = {}>(args?: Subset<T, Location$territoryArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    csiRecords<T extends Location$csiRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Location$csiRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminUsers<T extends Location$adminUsersArgs<ExtArgs> = {}>(args?: Subset<T, Location$adminUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAdministratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Location$customersArgs<ExtArgs> = {}>(args?: Subset<T, Location$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Location$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Location$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Location$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Location$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Location$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Location$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Location$productsArgs<ExtArgs> = {}>(args?: Subset<T, Location$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    franchiseFees<T extends Location$franchiseFeesArgs<ExtArgs> = {}>(args?: Subset<T, Location$franchiseFeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly state: FieldRef<"Location", 'String'>
    readonly zipCode: FieldRef<"Location", 'String'>
    readonly phone: FieldRef<"Location", 'String'>
    readonly email: FieldRef<"Location", 'String'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly franchiseId: FieldRef<"Location", 'String'>
    readonly ownerId: FieldRef<"Location", 'String'>
    readonly franchiseFeeRate: FieldRef<"Location", 'Float'>
    readonly royaltyRate: FieldRef<"Location", 'Float'>
    readonly timezone: FieldRef<"Location", 'String'>
    readonly businessHours: FieldRef<"Location", 'Json'>
    readonly currentCSIAverage: FieldRef<"Location", 'Float'>
    readonly lastCSIUpdate: FieldRef<"Location", 'DateTime'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.owner
   */
  export type Location$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Location.territory
   */
  export type Location$territoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Territory
     */
    omit?: TerritoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    where?: TerritoryWhereInput
  }

  /**
   * Location.csiRecords
   */
  export type Location$csiRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    where?: CSIWhereInput
    orderBy?: CSIOrderByWithRelationInput | CSIOrderByWithRelationInput[]
    cursor?: CSIWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CSIScalarFieldEnum | CSIScalarFieldEnum[]
  }

  /**
   * Location.adminUsers
   */
  export type Location$adminUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdministrator
     */
    select?: UserAdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAdministrator
     */
    omit?: UserAdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAdministratorInclude<ExtArgs> | null
    where?: UserAdministratorWhereInput
    orderBy?: UserAdministratorOrderByWithRelationInput | UserAdministratorOrderByWithRelationInput[]
    cursor?: UserAdministratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAdministratorScalarFieldEnum | UserAdministratorScalarFieldEnum[]
  }

  /**
   * Location.customers
   */
  export type Location$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Location.appointments
   */
  export type Location$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Location.subscriptions
   */
  export type Location$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Location.orders
   */
  export type Location$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Location.products
   */
  export type Location$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Location.franchiseFees
   */
  export type Location$franchiseFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    where?: FranchiseFeeWhereInput
    orderBy?: FranchiseFeeOrderByWithRelationInput | FranchiseFeeOrderByWithRelationInput[]
    cursor?: FranchiseFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FranchiseFeeScalarFieldEnum | FranchiseFeeScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model TerritoriesAvailable
   */

  export type AggregateTerritoriesAvailable = {
    _count: TerritoriesAvailableCountAggregateOutputType | null
    _avg: TerritoriesAvailableAvgAggregateOutputType | null
    _sum: TerritoriesAvailableSumAggregateOutputType | null
    _min: TerritoriesAvailableMinAggregateOutputType | null
    _max: TerritoriesAvailableMaxAggregateOutputType | null
  }

  export type TerritoriesAvailableAvgAggregateOutputType = {
    estimatedPopulation: number | null
    averageIncome: number | null
    competitorCount: number | null
    franchiseFee: number | null
    minimumInvestment: number | null
    exclusiveRadius: number | null
  }

  export type TerritoriesAvailableSumAggregateOutputType = {
    estimatedPopulation: number | null
    averageIncome: number | null
    competitorCount: number | null
    franchiseFee: number | null
    minimumInvestment: number | null
    exclusiveRadius: number | null
  }

  export type TerritoriesAvailableMinAggregateOutputType = {
    id: string | null
    territoryCode: string | null
    territoryName: string | null
    state: string | null
    city: string | null
    county: string | null
    estimatedPopulation: number | null
    averageIncome: number | null
    competitorCount: number | null
    marketPotential: string | null
    franchiseFee: number | null
    minimumInvestment: number | null
    exclusiveRadius: number | null
    isAvailable: boolean | null
    reservedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerritoriesAvailableMaxAggregateOutputType = {
    id: string | null
    territoryCode: string | null
    territoryName: string | null
    state: string | null
    city: string | null
    county: string | null
    estimatedPopulation: number | null
    averageIncome: number | null
    competitorCount: number | null
    marketPotential: string | null
    franchiseFee: number | null
    minimumInvestment: number | null
    exclusiveRadius: number | null
    isAvailable: boolean | null
    reservedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerritoriesAvailableCountAggregateOutputType = {
    id: number
    territoryCode: number
    territoryName: number
    state: number
    city: number
    zipCodes: number
    county: number
    estimatedPopulation: number
    averageIncome: number
    competitorCount: number
    marketPotential: number
    franchiseFee: number
    minimumInvestment: number
    exclusiveRadius: number
    isAvailable: number
    reservedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TerritoriesAvailableAvgAggregateInputType = {
    estimatedPopulation?: true
    averageIncome?: true
    competitorCount?: true
    franchiseFee?: true
    minimumInvestment?: true
    exclusiveRadius?: true
  }

  export type TerritoriesAvailableSumAggregateInputType = {
    estimatedPopulation?: true
    averageIncome?: true
    competitorCount?: true
    franchiseFee?: true
    minimumInvestment?: true
    exclusiveRadius?: true
  }

  export type TerritoriesAvailableMinAggregateInputType = {
    id?: true
    territoryCode?: true
    territoryName?: true
    state?: true
    city?: true
    county?: true
    estimatedPopulation?: true
    averageIncome?: true
    competitorCount?: true
    marketPotential?: true
    franchiseFee?: true
    minimumInvestment?: true
    exclusiveRadius?: true
    isAvailable?: true
    reservedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerritoriesAvailableMaxAggregateInputType = {
    id?: true
    territoryCode?: true
    territoryName?: true
    state?: true
    city?: true
    county?: true
    estimatedPopulation?: true
    averageIncome?: true
    competitorCount?: true
    marketPotential?: true
    franchiseFee?: true
    minimumInvestment?: true
    exclusiveRadius?: true
    isAvailable?: true
    reservedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerritoriesAvailableCountAggregateInputType = {
    id?: true
    territoryCode?: true
    territoryName?: true
    state?: true
    city?: true
    zipCodes?: true
    county?: true
    estimatedPopulation?: true
    averageIncome?: true
    competitorCount?: true
    marketPotential?: true
    franchiseFee?: true
    minimumInvestment?: true
    exclusiveRadius?: true
    isAvailable?: true
    reservedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TerritoriesAvailableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerritoriesAvailable to aggregate.
     */
    where?: TerritoriesAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoriesAvailables to fetch.
     */
    orderBy?: TerritoriesAvailableOrderByWithRelationInput | TerritoriesAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerritoriesAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoriesAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoriesAvailables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TerritoriesAvailables
    **/
    _count?: true | TerritoriesAvailableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TerritoriesAvailableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TerritoriesAvailableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerritoriesAvailableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerritoriesAvailableMaxAggregateInputType
  }

  export type GetTerritoriesAvailableAggregateType<T extends TerritoriesAvailableAggregateArgs> = {
        [P in keyof T & keyof AggregateTerritoriesAvailable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerritoriesAvailable[P]>
      : GetScalarType<T[P], AggregateTerritoriesAvailable[P]>
  }




  export type TerritoriesAvailableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoriesAvailableWhereInput
    orderBy?: TerritoriesAvailableOrderByWithAggregationInput | TerritoriesAvailableOrderByWithAggregationInput[]
    by: TerritoriesAvailableScalarFieldEnum[] | TerritoriesAvailableScalarFieldEnum
    having?: TerritoriesAvailableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerritoriesAvailableCountAggregateInputType | true
    _avg?: TerritoriesAvailableAvgAggregateInputType
    _sum?: TerritoriesAvailableSumAggregateInputType
    _min?: TerritoriesAvailableMinAggregateInputType
    _max?: TerritoriesAvailableMaxAggregateInputType
  }

  export type TerritoriesAvailableGroupByOutputType = {
    id: string
    territoryCode: string
    territoryName: string
    state: string
    city: string | null
    zipCodes: string[]
    county: string | null
    estimatedPopulation: number | null
    averageIncome: number | null
    competitorCount: number | null
    marketPotential: string | null
    franchiseFee: number
    minimumInvestment: number | null
    exclusiveRadius: number | null
    isAvailable: boolean
    reservedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TerritoriesAvailableCountAggregateOutputType | null
    _avg: TerritoriesAvailableAvgAggregateOutputType | null
    _sum: TerritoriesAvailableSumAggregateOutputType | null
    _min: TerritoriesAvailableMinAggregateOutputType | null
    _max: TerritoriesAvailableMaxAggregateOutputType | null
  }

  type GetTerritoriesAvailableGroupByPayload<T extends TerritoriesAvailableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerritoriesAvailableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerritoriesAvailableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerritoriesAvailableGroupByOutputType[P]>
            : GetScalarType<T[P], TerritoriesAvailableGroupByOutputType[P]>
        }
      >
    >


  export type TerritoriesAvailableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    state?: boolean
    city?: boolean
    zipCodes?: boolean
    county?: boolean
    estimatedPopulation?: boolean
    averageIncome?: boolean
    competitorCount?: boolean
    marketPotential?: boolean
    franchiseFee?: boolean
    minimumInvestment?: boolean
    exclusiveRadius?: boolean
    isAvailable?: boolean
    reservedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["territoriesAvailable"]>

  export type TerritoriesAvailableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    state?: boolean
    city?: boolean
    zipCodes?: boolean
    county?: boolean
    estimatedPopulation?: boolean
    averageIncome?: boolean
    competitorCount?: boolean
    marketPotential?: boolean
    franchiseFee?: boolean
    minimumInvestment?: boolean
    exclusiveRadius?: boolean
    isAvailable?: boolean
    reservedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["territoriesAvailable"]>

  export type TerritoriesAvailableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    state?: boolean
    city?: boolean
    zipCodes?: boolean
    county?: boolean
    estimatedPopulation?: boolean
    averageIncome?: boolean
    competitorCount?: boolean
    marketPotential?: boolean
    franchiseFee?: boolean
    minimumInvestment?: boolean
    exclusiveRadius?: boolean
    isAvailable?: boolean
    reservedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["territoriesAvailable"]>

  export type TerritoriesAvailableSelectScalar = {
    id?: boolean
    territoryCode?: boolean
    territoryName?: boolean
    state?: boolean
    city?: boolean
    zipCodes?: boolean
    county?: boolean
    estimatedPopulation?: boolean
    averageIncome?: boolean
    competitorCount?: boolean
    marketPotential?: boolean
    franchiseFee?: boolean
    minimumInvestment?: boolean
    exclusiveRadius?: boolean
    isAvailable?: boolean
    reservedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TerritoriesAvailableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "territoryCode" | "territoryName" | "state" | "city" | "zipCodes" | "county" | "estimatedPopulation" | "averageIncome" | "competitorCount" | "marketPotential" | "franchiseFee" | "minimumInvestment" | "exclusiveRadius" | "isAvailable" | "reservedUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["territoriesAvailable"]>

  export type $TerritoriesAvailablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TerritoriesAvailable"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      territoryCode: string
      territoryName: string
      state: string
      city: string | null
      zipCodes: string[]
      county: string | null
      estimatedPopulation: number | null
      averageIncome: number | null
      competitorCount: number | null
      marketPotential: string | null
      franchiseFee: number
      minimumInvestment: number | null
      exclusiveRadius: number | null
      isAvailable: boolean
      reservedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["territoriesAvailable"]>
    composites: {}
  }

  type TerritoriesAvailableGetPayload<S extends boolean | null | undefined | TerritoriesAvailableDefaultArgs> = $Result.GetResult<Prisma.$TerritoriesAvailablePayload, S>

  type TerritoriesAvailableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TerritoriesAvailableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TerritoriesAvailableCountAggregateInputType | true
    }

  export interface TerritoriesAvailableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TerritoriesAvailable'], meta: { name: 'TerritoriesAvailable' } }
    /**
     * Find zero or one TerritoriesAvailable that matches the filter.
     * @param {TerritoriesAvailableFindUniqueArgs} args - Arguments to find a TerritoriesAvailable
     * @example
     * // Get one TerritoriesAvailable
     * const territoriesAvailable = await prisma.territoriesAvailable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerritoriesAvailableFindUniqueArgs>(args: SelectSubset<T, TerritoriesAvailableFindUniqueArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TerritoriesAvailable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TerritoriesAvailableFindUniqueOrThrowArgs} args - Arguments to find a TerritoriesAvailable
     * @example
     * // Get one TerritoriesAvailable
     * const territoriesAvailable = await prisma.territoriesAvailable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerritoriesAvailableFindUniqueOrThrowArgs>(args: SelectSubset<T, TerritoriesAvailableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TerritoriesAvailable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAvailableFindFirstArgs} args - Arguments to find a TerritoriesAvailable
     * @example
     * // Get one TerritoriesAvailable
     * const territoriesAvailable = await prisma.territoriesAvailable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerritoriesAvailableFindFirstArgs>(args?: SelectSubset<T, TerritoriesAvailableFindFirstArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TerritoriesAvailable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAvailableFindFirstOrThrowArgs} args - Arguments to find a TerritoriesAvailable
     * @example
     * // Get one TerritoriesAvailable
     * const territoriesAvailable = await prisma.territoriesAvailable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerritoriesAvailableFindFirstOrThrowArgs>(args?: SelectSubset<T, TerritoriesAvailableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TerritoriesAvailables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAvailableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TerritoriesAvailables
     * const territoriesAvailables = await prisma.territoriesAvailable.findMany()
     * 
     * // Get first 10 TerritoriesAvailables
     * const territoriesAvailables = await prisma.territoriesAvailable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const territoriesAvailableWithIdOnly = await prisma.territoriesAvailable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerritoriesAvailableFindManyArgs>(args?: SelectSubset<T, TerritoriesAvailableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TerritoriesAvailable.
     * @param {TerritoriesAvailableCreateArgs} args - Arguments to create a TerritoriesAvailable.
     * @example
     * // Create one TerritoriesAvailable
     * const TerritoriesAvailable = await prisma.territoriesAvailable.create({
     *   data: {
     *     // ... data to create a TerritoriesAvailable
     *   }
     * })
     * 
     */
    create<T extends TerritoriesAvailableCreateArgs>(args: SelectSubset<T, TerritoriesAvailableCreateArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TerritoriesAvailables.
     * @param {TerritoriesAvailableCreateManyArgs} args - Arguments to create many TerritoriesAvailables.
     * @example
     * // Create many TerritoriesAvailables
     * const territoriesAvailable = await prisma.territoriesAvailable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerritoriesAvailableCreateManyArgs>(args?: SelectSubset<T, TerritoriesAvailableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TerritoriesAvailables and returns the data saved in the database.
     * @param {TerritoriesAvailableCreateManyAndReturnArgs} args - Arguments to create many TerritoriesAvailables.
     * @example
     * // Create many TerritoriesAvailables
     * const territoriesAvailable = await prisma.territoriesAvailable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TerritoriesAvailables and only return the `id`
     * const territoriesAvailableWithIdOnly = await prisma.territoriesAvailable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerritoriesAvailableCreateManyAndReturnArgs>(args?: SelectSubset<T, TerritoriesAvailableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TerritoriesAvailable.
     * @param {TerritoriesAvailableDeleteArgs} args - Arguments to delete one TerritoriesAvailable.
     * @example
     * // Delete one TerritoriesAvailable
     * const TerritoriesAvailable = await prisma.territoriesAvailable.delete({
     *   where: {
     *     // ... filter to delete one TerritoriesAvailable
     *   }
     * })
     * 
     */
    delete<T extends TerritoriesAvailableDeleteArgs>(args: SelectSubset<T, TerritoriesAvailableDeleteArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TerritoriesAvailable.
     * @param {TerritoriesAvailableUpdateArgs} args - Arguments to update one TerritoriesAvailable.
     * @example
     * // Update one TerritoriesAvailable
     * const territoriesAvailable = await prisma.territoriesAvailable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerritoriesAvailableUpdateArgs>(args: SelectSubset<T, TerritoriesAvailableUpdateArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TerritoriesAvailables.
     * @param {TerritoriesAvailableDeleteManyArgs} args - Arguments to filter TerritoriesAvailables to delete.
     * @example
     * // Delete a few TerritoriesAvailables
     * const { count } = await prisma.territoriesAvailable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerritoriesAvailableDeleteManyArgs>(args?: SelectSubset<T, TerritoriesAvailableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TerritoriesAvailables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAvailableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TerritoriesAvailables
     * const territoriesAvailable = await prisma.territoriesAvailable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerritoriesAvailableUpdateManyArgs>(args: SelectSubset<T, TerritoriesAvailableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TerritoriesAvailables and returns the data updated in the database.
     * @param {TerritoriesAvailableUpdateManyAndReturnArgs} args - Arguments to update many TerritoriesAvailables.
     * @example
     * // Update many TerritoriesAvailables
     * const territoriesAvailable = await prisma.territoriesAvailable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TerritoriesAvailables and only return the `id`
     * const territoriesAvailableWithIdOnly = await prisma.territoriesAvailable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TerritoriesAvailableUpdateManyAndReturnArgs>(args: SelectSubset<T, TerritoriesAvailableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TerritoriesAvailable.
     * @param {TerritoriesAvailableUpsertArgs} args - Arguments to update or create a TerritoriesAvailable.
     * @example
     * // Update or create a TerritoriesAvailable
     * const territoriesAvailable = await prisma.territoriesAvailable.upsert({
     *   create: {
     *     // ... data to create a TerritoriesAvailable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TerritoriesAvailable we want to update
     *   }
     * })
     */
    upsert<T extends TerritoriesAvailableUpsertArgs>(args: SelectSubset<T, TerritoriesAvailableUpsertArgs<ExtArgs>>): Prisma__TerritoriesAvailableClient<$Result.GetResult<Prisma.$TerritoriesAvailablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TerritoriesAvailables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAvailableCountArgs} args - Arguments to filter TerritoriesAvailables to count.
     * @example
     * // Count the number of TerritoriesAvailables
     * const count = await prisma.territoriesAvailable.count({
     *   where: {
     *     // ... the filter for the TerritoriesAvailables we want to count
     *   }
     * })
    **/
    count<T extends TerritoriesAvailableCountArgs>(
      args?: Subset<T, TerritoriesAvailableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerritoriesAvailableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TerritoriesAvailable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAvailableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerritoriesAvailableAggregateArgs>(args: Subset<T, TerritoriesAvailableAggregateArgs>): Prisma.PrismaPromise<GetTerritoriesAvailableAggregateType<T>>

    /**
     * Group by TerritoriesAvailable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoriesAvailableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerritoriesAvailableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerritoriesAvailableGroupByArgs['orderBy'] }
        : { orderBy?: TerritoriesAvailableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerritoriesAvailableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerritoriesAvailableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TerritoriesAvailable model
   */
  readonly fields: TerritoriesAvailableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TerritoriesAvailable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerritoriesAvailableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TerritoriesAvailable model
   */
  interface TerritoriesAvailableFieldRefs {
    readonly id: FieldRef<"TerritoriesAvailable", 'String'>
    readonly territoryCode: FieldRef<"TerritoriesAvailable", 'String'>
    readonly territoryName: FieldRef<"TerritoriesAvailable", 'String'>
    readonly state: FieldRef<"TerritoriesAvailable", 'String'>
    readonly city: FieldRef<"TerritoriesAvailable", 'String'>
    readonly zipCodes: FieldRef<"TerritoriesAvailable", 'String[]'>
    readonly county: FieldRef<"TerritoriesAvailable", 'String'>
    readonly estimatedPopulation: FieldRef<"TerritoriesAvailable", 'Int'>
    readonly averageIncome: FieldRef<"TerritoriesAvailable", 'Float'>
    readonly competitorCount: FieldRef<"TerritoriesAvailable", 'Int'>
    readonly marketPotential: FieldRef<"TerritoriesAvailable", 'String'>
    readonly franchiseFee: FieldRef<"TerritoriesAvailable", 'Float'>
    readonly minimumInvestment: FieldRef<"TerritoriesAvailable", 'Float'>
    readonly exclusiveRadius: FieldRef<"TerritoriesAvailable", 'Float'>
    readonly isAvailable: FieldRef<"TerritoriesAvailable", 'Boolean'>
    readonly reservedUntil: FieldRef<"TerritoriesAvailable", 'DateTime'>
    readonly createdAt: FieldRef<"TerritoriesAvailable", 'DateTime'>
    readonly updatedAt: FieldRef<"TerritoriesAvailable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TerritoriesAvailable findUnique
   */
  export type TerritoriesAvailableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * Filter, which TerritoriesAvailable to fetch.
     */
    where: TerritoriesAvailableWhereUniqueInput
  }

  /**
   * TerritoriesAvailable findUniqueOrThrow
   */
  export type TerritoriesAvailableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * Filter, which TerritoriesAvailable to fetch.
     */
    where: TerritoriesAvailableWhereUniqueInput
  }

  /**
   * TerritoriesAvailable findFirst
   */
  export type TerritoriesAvailableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * Filter, which TerritoriesAvailable to fetch.
     */
    where?: TerritoriesAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoriesAvailables to fetch.
     */
    orderBy?: TerritoriesAvailableOrderByWithRelationInput | TerritoriesAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerritoriesAvailables.
     */
    cursor?: TerritoriesAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoriesAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoriesAvailables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerritoriesAvailables.
     */
    distinct?: TerritoriesAvailableScalarFieldEnum | TerritoriesAvailableScalarFieldEnum[]
  }

  /**
   * TerritoriesAvailable findFirstOrThrow
   */
  export type TerritoriesAvailableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * Filter, which TerritoriesAvailable to fetch.
     */
    where?: TerritoriesAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoriesAvailables to fetch.
     */
    orderBy?: TerritoriesAvailableOrderByWithRelationInput | TerritoriesAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerritoriesAvailables.
     */
    cursor?: TerritoriesAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoriesAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoriesAvailables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerritoriesAvailables.
     */
    distinct?: TerritoriesAvailableScalarFieldEnum | TerritoriesAvailableScalarFieldEnum[]
  }

  /**
   * TerritoriesAvailable findMany
   */
  export type TerritoriesAvailableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * Filter, which TerritoriesAvailables to fetch.
     */
    where?: TerritoriesAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoriesAvailables to fetch.
     */
    orderBy?: TerritoriesAvailableOrderByWithRelationInput | TerritoriesAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TerritoriesAvailables.
     */
    cursor?: TerritoriesAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoriesAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoriesAvailables.
     */
    skip?: number
    distinct?: TerritoriesAvailableScalarFieldEnum | TerritoriesAvailableScalarFieldEnum[]
  }

  /**
   * TerritoriesAvailable create
   */
  export type TerritoriesAvailableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * The data needed to create a TerritoriesAvailable.
     */
    data: XOR<TerritoriesAvailableCreateInput, TerritoriesAvailableUncheckedCreateInput>
  }

  /**
   * TerritoriesAvailable createMany
   */
  export type TerritoriesAvailableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TerritoriesAvailables.
     */
    data: TerritoriesAvailableCreateManyInput | TerritoriesAvailableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TerritoriesAvailable createManyAndReturn
   */
  export type TerritoriesAvailableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * The data used to create many TerritoriesAvailables.
     */
    data: TerritoriesAvailableCreateManyInput | TerritoriesAvailableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TerritoriesAvailable update
   */
  export type TerritoriesAvailableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * The data needed to update a TerritoriesAvailable.
     */
    data: XOR<TerritoriesAvailableUpdateInput, TerritoriesAvailableUncheckedUpdateInput>
    /**
     * Choose, which TerritoriesAvailable to update.
     */
    where: TerritoriesAvailableWhereUniqueInput
  }

  /**
   * TerritoriesAvailable updateMany
   */
  export type TerritoriesAvailableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TerritoriesAvailables.
     */
    data: XOR<TerritoriesAvailableUpdateManyMutationInput, TerritoriesAvailableUncheckedUpdateManyInput>
    /**
     * Filter which TerritoriesAvailables to update
     */
    where?: TerritoriesAvailableWhereInput
    /**
     * Limit how many TerritoriesAvailables to update.
     */
    limit?: number
  }

  /**
   * TerritoriesAvailable updateManyAndReturn
   */
  export type TerritoriesAvailableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * The data used to update TerritoriesAvailables.
     */
    data: XOR<TerritoriesAvailableUpdateManyMutationInput, TerritoriesAvailableUncheckedUpdateManyInput>
    /**
     * Filter which TerritoriesAvailables to update
     */
    where?: TerritoriesAvailableWhereInput
    /**
     * Limit how many TerritoriesAvailables to update.
     */
    limit?: number
  }

  /**
   * TerritoriesAvailable upsert
   */
  export type TerritoriesAvailableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * The filter to search for the TerritoriesAvailable to update in case it exists.
     */
    where: TerritoriesAvailableWhereUniqueInput
    /**
     * In case the TerritoriesAvailable found by the `where` argument doesn't exist, create a new TerritoriesAvailable with this data.
     */
    create: XOR<TerritoriesAvailableCreateInput, TerritoriesAvailableUncheckedCreateInput>
    /**
     * In case the TerritoriesAvailable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerritoriesAvailableUpdateInput, TerritoriesAvailableUncheckedUpdateInput>
  }

  /**
   * TerritoriesAvailable delete
   */
  export type TerritoriesAvailableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
    /**
     * Filter which TerritoriesAvailable to delete.
     */
    where: TerritoriesAvailableWhereUniqueInput
  }

  /**
   * TerritoriesAvailable deleteMany
   */
  export type TerritoriesAvailableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerritoriesAvailables to delete
     */
    where?: TerritoriesAvailableWhereInput
    /**
     * Limit how many TerritoriesAvailables to delete.
     */
    limit?: number
  }

  /**
   * TerritoriesAvailable without action
   */
  export type TerritoriesAvailableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoriesAvailable
     */
    select?: TerritoriesAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerritoriesAvailable
     */
    omit?: TerritoriesAvailableOmit<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    dogAge: number | null
    dogWeight: number | null
  }

  export type CustomerSumAggregateOutputType = {
    dogAge: number | null
    dogWeight: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: $Enums.UserRole | null
    dogName: string | null
    dogBreed: string | null
    dogAge: number | null
    dogWeight: number | null
    allergies: string | null
    preferredGroomer: string | null
    notes: string | null
    squareCustomerId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: $Enums.UserRole | null
    dogName: string | null
    dogBreed: string | null
    dogAge: number | null
    dogWeight: number | null
    allergies: string | null
    preferredGroomer: string | null
    notes: string | null
    squareCustomerId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    locationId: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    role: number
    dogName: number
    dogBreed: number
    dogAge: number
    dogWeight: number
    allergies: number
    preferredGroomer: number
    notes: number
    squareCustomerId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    dogAge?: true
    dogWeight?: true
  }

  export type CustomerSumAggregateInputType = {
    dogAge?: true
    dogWeight?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    locationId?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    dogName?: true
    dogBreed?: true
    dogAge?: true
    dogWeight?: true
    allergies?: true
    preferredGroomer?: true
    notes?: true
    squareCustomerId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    locationId?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    dogName?: true
    dogBreed?: true
    dogAge?: true
    dogWeight?: true
    allergies?: true
    preferredGroomer?: true
    notes?: true
    squareCustomerId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    locationId?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    dogName?: true
    dogBreed?: true
    dogAge?: true
    dogWeight?: true
    allergies?: true
    preferredGroomer?: true
    notes?: true
    squareCustomerId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    locationId: string | null
    userId: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role: $Enums.UserRole
    dogName: string | null
    dogBreed: string | null
    dogAge: number | null
    dogWeight: number | null
    allergies: string | null
    preferredGroomer: string | null
    notes: string | null
    squareCustomerId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    dogName?: boolean
    dogBreed?: boolean
    dogAge?: boolean
    dogWeight?: boolean
    allergies?: boolean
    preferredGroomer?: boolean
    notes?: boolean
    squareCustomerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Customer$locationArgs<ExtArgs>
    userAccount?: boolean | Customer$userAccountArgs<ExtArgs>
    appointments?: boolean | Customer$appointmentsArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    csiRecords?: boolean | Customer$csiRecordsArgs<ExtArgs>
    pluginPurchases?: boolean | Customer$pluginPurchasesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    dogName?: boolean
    dogBreed?: boolean
    dogAge?: boolean
    dogWeight?: boolean
    allergies?: boolean
    preferredGroomer?: boolean
    notes?: boolean
    squareCustomerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Customer$locationArgs<ExtArgs>
    userAccount?: boolean | Customer$userAccountArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    dogName?: boolean
    dogBreed?: boolean
    dogAge?: boolean
    dogWeight?: boolean
    allergies?: boolean
    preferredGroomer?: boolean
    notes?: boolean
    squareCustomerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Customer$locationArgs<ExtArgs>
    userAccount?: boolean | Customer$userAccountArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    locationId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    dogName?: boolean
    dogBreed?: boolean
    dogAge?: boolean
    dogWeight?: boolean
    allergies?: boolean
    preferredGroomer?: boolean
    notes?: boolean
    squareCustomerId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "userId" | "firstName" | "lastName" | "email" | "phone" | "role" | "dogName" | "dogBreed" | "dogAge" | "dogWeight" | "allergies" | "preferredGroomer" | "notes" | "squareCustomerId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Customer$locationArgs<ExtArgs>
    userAccount?: boolean | Customer$userAccountArgs<ExtArgs>
    appointments?: boolean | Customer$appointmentsArgs<ExtArgs>
    subscriptions?: boolean | Customer$subscriptionsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    csiRecords?: boolean | Customer$csiRecordsArgs<ExtArgs>
    pluginPurchases?: boolean | Customer$pluginPurchasesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Customer$locationArgs<ExtArgs>
    userAccount?: boolean | Customer$userAccountArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Customer$locationArgs<ExtArgs>
    userAccount?: boolean | Customer$userAccountArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
      userAccount: Prisma.$UserPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      csiRecords: Prisma.$CSIPayload<ExtArgs>[]
      pluginPurchases: Prisma.$PluginPurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string | null
      userId: string | null
      firstName: string
      lastName: string
      email: string
      phone: string
      role: $Enums.UserRole
      dogName: string | null
      dogBreed: string | null
      dogAge: number | null
      dogWeight: number | null
      allergies: string | null
      preferredGroomer: string | null
      notes: string | null
      squareCustomerId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends Customer$locationArgs<ExtArgs> = {}>(args?: Subset<T, Customer$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userAccount<T extends Customer$userAccountArgs<ExtArgs> = {}>(args?: Subset<T, Customer$userAccountArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Customer$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Customer$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    csiRecords<T extends Customer$csiRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$csiRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CSIPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pluginPurchases<T extends Customer$pluginPurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$pluginPurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly locationId: FieldRef<"Customer", 'String'>
    readonly userId: FieldRef<"Customer", 'String'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly role: FieldRef<"Customer", 'UserRole'>
    readonly dogName: FieldRef<"Customer", 'String'>
    readonly dogBreed: FieldRef<"Customer", 'String'>
    readonly dogAge: FieldRef<"Customer", 'Int'>
    readonly dogWeight: FieldRef<"Customer", 'Float'>
    readonly allergies: FieldRef<"Customer", 'String'>
    readonly preferredGroomer: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly squareCustomerId: FieldRef<"Customer", 'String'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.location
   */
  export type Customer$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Customer.userAccount
   */
  export type Customer$userAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Customer.appointments
   */
  export type Customer$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Customer.subscriptions
   */
  export type Customer$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.csiRecords
   */
  export type Customer$csiRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CSI
     */
    select?: CSISelect<ExtArgs> | null
    /**
     * Omit specific fields from the CSI
     */
    omit?: CSIOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CSIInclude<ExtArgs> | null
    where?: CSIWhereInput
    orderBy?: CSIOrderByWithRelationInput | CSIOrderByWithRelationInput[]
    cursor?: CSIWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CSIScalarFieldEnum | CSIScalarFieldEnum[]
  }

  /**
   * Customer.pluginPurchases
   */
  export type Customer$pluginPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginPurchase
     */
    select?: PluginPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PluginPurchase
     */
    omit?: PluginPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginPurchaseInclude<ExtArgs> | null
    where?: PluginPurchaseWhereInput
    orderBy?: PluginPurchaseOrderByWithRelationInput | PluginPurchaseOrderByWithRelationInput[]
    cursor?: PluginPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PluginPurchaseScalarFieldEnum | PluginPurchaseScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model FranchiseFee
   */

  export type AggregateFranchiseFee = {
    _count: FranchiseFeeCountAggregateOutputType | null
    _avg: FranchiseFeeAvgAggregateOutputType | null
    _sum: FranchiseFeeSumAggregateOutputType | null
    _min: FranchiseFeeMinAggregateOutputType | null
    _max: FranchiseFeeMaxAggregateOutputType | null
  }

  export type FranchiseFeeAvgAggregateOutputType = {
    month: number | null
    year: number | null
    serviceRevenue: number | null
    productRevenue: number | null
    subscriptionRevenue: number | null
    totalRevenue: number | null
    franchiseFee: number | null
    royaltyFee: number | null
    totalFees: number | null
  }

  export type FranchiseFeeSumAggregateOutputType = {
    month: number | null
    year: number | null
    serviceRevenue: number | null
    productRevenue: number | null
    subscriptionRevenue: number | null
    totalRevenue: number | null
    franchiseFee: number | null
    royaltyFee: number | null
    totalFees: number | null
  }

  export type FranchiseFeeMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    month: number | null
    year: number | null
    serviceRevenue: number | null
    productRevenue: number | null
    subscriptionRevenue: number | null
    totalRevenue: number | null
    franchiseFee: number | null
    royaltyFee: number | null
    totalFees: number | null
    isPaid: boolean | null
    paidAt: Date | null
    dueDate: Date | null
    createdAt: Date | null
  }

  export type FranchiseFeeMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    month: number | null
    year: number | null
    serviceRevenue: number | null
    productRevenue: number | null
    subscriptionRevenue: number | null
    totalRevenue: number | null
    franchiseFee: number | null
    royaltyFee: number | null
    totalFees: number | null
    isPaid: boolean | null
    paidAt: Date | null
    dueDate: Date | null
    createdAt: Date | null
  }

  export type FranchiseFeeCountAggregateOutputType = {
    id: number
    locationId: number
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid: number
    paidAt: number
    dueDate: number
    createdAt: number
    _all: number
  }


  export type FranchiseFeeAvgAggregateInputType = {
    month?: true
    year?: true
    serviceRevenue?: true
    productRevenue?: true
    subscriptionRevenue?: true
    totalRevenue?: true
    franchiseFee?: true
    royaltyFee?: true
    totalFees?: true
  }

  export type FranchiseFeeSumAggregateInputType = {
    month?: true
    year?: true
    serviceRevenue?: true
    productRevenue?: true
    subscriptionRevenue?: true
    totalRevenue?: true
    franchiseFee?: true
    royaltyFee?: true
    totalFees?: true
  }

  export type FranchiseFeeMinAggregateInputType = {
    id?: true
    locationId?: true
    month?: true
    year?: true
    serviceRevenue?: true
    productRevenue?: true
    subscriptionRevenue?: true
    totalRevenue?: true
    franchiseFee?: true
    royaltyFee?: true
    totalFees?: true
    isPaid?: true
    paidAt?: true
    dueDate?: true
    createdAt?: true
  }

  export type FranchiseFeeMaxAggregateInputType = {
    id?: true
    locationId?: true
    month?: true
    year?: true
    serviceRevenue?: true
    productRevenue?: true
    subscriptionRevenue?: true
    totalRevenue?: true
    franchiseFee?: true
    royaltyFee?: true
    totalFees?: true
    isPaid?: true
    paidAt?: true
    dueDate?: true
    createdAt?: true
  }

  export type FranchiseFeeCountAggregateInputType = {
    id?: true
    locationId?: true
    month?: true
    year?: true
    serviceRevenue?: true
    productRevenue?: true
    subscriptionRevenue?: true
    totalRevenue?: true
    franchiseFee?: true
    royaltyFee?: true
    totalFees?: true
    isPaid?: true
    paidAt?: true
    dueDate?: true
    createdAt?: true
    _all?: true
  }

  export type FranchiseFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FranchiseFee to aggregate.
     */
    where?: FranchiseFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FranchiseFees to fetch.
     */
    orderBy?: FranchiseFeeOrderByWithRelationInput | FranchiseFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FranchiseFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FranchiseFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FranchiseFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FranchiseFees
    **/
    _count?: true | FranchiseFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FranchiseFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FranchiseFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FranchiseFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FranchiseFeeMaxAggregateInputType
  }

  export type GetFranchiseFeeAggregateType<T extends FranchiseFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateFranchiseFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFranchiseFee[P]>
      : GetScalarType<T[P], AggregateFranchiseFee[P]>
  }




  export type FranchiseFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FranchiseFeeWhereInput
    orderBy?: FranchiseFeeOrderByWithAggregationInput | FranchiseFeeOrderByWithAggregationInput[]
    by: FranchiseFeeScalarFieldEnum[] | FranchiseFeeScalarFieldEnum
    having?: FranchiseFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FranchiseFeeCountAggregateInputType | true
    _avg?: FranchiseFeeAvgAggregateInputType
    _sum?: FranchiseFeeSumAggregateInputType
    _min?: FranchiseFeeMinAggregateInputType
    _max?: FranchiseFeeMaxAggregateInputType
  }

  export type FranchiseFeeGroupByOutputType = {
    id: string
    locationId: string
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid: boolean
    paidAt: Date | null
    dueDate: Date
    createdAt: Date
    _count: FranchiseFeeCountAggregateOutputType | null
    _avg: FranchiseFeeAvgAggregateOutputType | null
    _sum: FranchiseFeeSumAggregateOutputType | null
    _min: FranchiseFeeMinAggregateOutputType | null
    _max: FranchiseFeeMaxAggregateOutputType | null
  }

  type GetFranchiseFeeGroupByPayload<T extends FranchiseFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FranchiseFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FranchiseFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FranchiseFeeGroupByOutputType[P]>
            : GetScalarType<T[P], FranchiseFeeGroupByOutputType[P]>
        }
      >
    >


  export type FranchiseFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    month?: boolean
    year?: boolean
    serviceRevenue?: boolean
    productRevenue?: boolean
    subscriptionRevenue?: boolean
    totalRevenue?: boolean
    franchiseFee?: boolean
    royaltyFee?: boolean
    totalFees?: boolean
    isPaid?: boolean
    paidAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["franchiseFee"]>

  export type FranchiseFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    month?: boolean
    year?: boolean
    serviceRevenue?: boolean
    productRevenue?: boolean
    subscriptionRevenue?: boolean
    totalRevenue?: boolean
    franchiseFee?: boolean
    royaltyFee?: boolean
    totalFees?: boolean
    isPaid?: boolean
    paidAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["franchiseFee"]>

  export type FranchiseFeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    month?: boolean
    year?: boolean
    serviceRevenue?: boolean
    productRevenue?: boolean
    subscriptionRevenue?: boolean
    totalRevenue?: boolean
    franchiseFee?: boolean
    royaltyFee?: boolean
    totalFees?: boolean
    isPaid?: boolean
    paidAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["franchiseFee"]>

  export type FranchiseFeeSelectScalar = {
    id?: boolean
    locationId?: boolean
    month?: boolean
    year?: boolean
    serviceRevenue?: boolean
    productRevenue?: boolean
    subscriptionRevenue?: boolean
    totalRevenue?: boolean
    franchiseFee?: boolean
    royaltyFee?: boolean
    totalFees?: boolean
    isPaid?: boolean
    paidAt?: boolean
    dueDate?: boolean
    createdAt?: boolean
  }

  export type FranchiseFeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "month" | "year" | "serviceRevenue" | "productRevenue" | "subscriptionRevenue" | "totalRevenue" | "franchiseFee" | "royaltyFee" | "totalFees" | "isPaid" | "paidAt" | "dueDate" | "createdAt", ExtArgs["result"]["franchiseFee"]>
  export type FranchiseFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type FranchiseFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type FranchiseFeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $FranchiseFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FranchiseFee"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      month: number
      year: number
      serviceRevenue: number
      productRevenue: number
      subscriptionRevenue: number
      totalRevenue: number
      franchiseFee: number
      royaltyFee: number
      totalFees: number
      isPaid: boolean
      paidAt: Date | null
      dueDate: Date
      createdAt: Date
    }, ExtArgs["result"]["franchiseFee"]>
    composites: {}
  }

  type FranchiseFeeGetPayload<S extends boolean | null | undefined | FranchiseFeeDefaultArgs> = $Result.GetResult<Prisma.$FranchiseFeePayload, S>

  type FranchiseFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FranchiseFeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FranchiseFeeCountAggregateInputType | true
    }

  export interface FranchiseFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FranchiseFee'], meta: { name: 'FranchiseFee' } }
    /**
     * Find zero or one FranchiseFee that matches the filter.
     * @param {FranchiseFeeFindUniqueArgs} args - Arguments to find a FranchiseFee
     * @example
     * // Get one FranchiseFee
     * const franchiseFee = await prisma.franchiseFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FranchiseFeeFindUniqueArgs>(args: SelectSubset<T, FranchiseFeeFindUniqueArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FranchiseFee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FranchiseFeeFindUniqueOrThrowArgs} args - Arguments to find a FranchiseFee
     * @example
     * // Get one FranchiseFee
     * const franchiseFee = await prisma.franchiseFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FranchiseFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, FranchiseFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FranchiseFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFeeFindFirstArgs} args - Arguments to find a FranchiseFee
     * @example
     * // Get one FranchiseFee
     * const franchiseFee = await prisma.franchiseFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FranchiseFeeFindFirstArgs>(args?: SelectSubset<T, FranchiseFeeFindFirstArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FranchiseFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFeeFindFirstOrThrowArgs} args - Arguments to find a FranchiseFee
     * @example
     * // Get one FranchiseFee
     * const franchiseFee = await prisma.franchiseFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FranchiseFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, FranchiseFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FranchiseFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FranchiseFees
     * const franchiseFees = await prisma.franchiseFee.findMany()
     * 
     * // Get first 10 FranchiseFees
     * const franchiseFees = await prisma.franchiseFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const franchiseFeeWithIdOnly = await prisma.franchiseFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FranchiseFeeFindManyArgs>(args?: SelectSubset<T, FranchiseFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FranchiseFee.
     * @param {FranchiseFeeCreateArgs} args - Arguments to create a FranchiseFee.
     * @example
     * // Create one FranchiseFee
     * const FranchiseFee = await prisma.franchiseFee.create({
     *   data: {
     *     // ... data to create a FranchiseFee
     *   }
     * })
     * 
     */
    create<T extends FranchiseFeeCreateArgs>(args: SelectSubset<T, FranchiseFeeCreateArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FranchiseFees.
     * @param {FranchiseFeeCreateManyArgs} args - Arguments to create many FranchiseFees.
     * @example
     * // Create many FranchiseFees
     * const franchiseFee = await prisma.franchiseFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FranchiseFeeCreateManyArgs>(args?: SelectSubset<T, FranchiseFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FranchiseFees and returns the data saved in the database.
     * @param {FranchiseFeeCreateManyAndReturnArgs} args - Arguments to create many FranchiseFees.
     * @example
     * // Create many FranchiseFees
     * const franchiseFee = await prisma.franchiseFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FranchiseFees and only return the `id`
     * const franchiseFeeWithIdOnly = await prisma.franchiseFee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FranchiseFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, FranchiseFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FranchiseFee.
     * @param {FranchiseFeeDeleteArgs} args - Arguments to delete one FranchiseFee.
     * @example
     * // Delete one FranchiseFee
     * const FranchiseFee = await prisma.franchiseFee.delete({
     *   where: {
     *     // ... filter to delete one FranchiseFee
     *   }
     * })
     * 
     */
    delete<T extends FranchiseFeeDeleteArgs>(args: SelectSubset<T, FranchiseFeeDeleteArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FranchiseFee.
     * @param {FranchiseFeeUpdateArgs} args - Arguments to update one FranchiseFee.
     * @example
     * // Update one FranchiseFee
     * const franchiseFee = await prisma.franchiseFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FranchiseFeeUpdateArgs>(args: SelectSubset<T, FranchiseFeeUpdateArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FranchiseFees.
     * @param {FranchiseFeeDeleteManyArgs} args - Arguments to filter FranchiseFees to delete.
     * @example
     * // Delete a few FranchiseFees
     * const { count } = await prisma.franchiseFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FranchiseFeeDeleteManyArgs>(args?: SelectSubset<T, FranchiseFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FranchiseFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FranchiseFees
     * const franchiseFee = await prisma.franchiseFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FranchiseFeeUpdateManyArgs>(args: SelectSubset<T, FranchiseFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FranchiseFees and returns the data updated in the database.
     * @param {FranchiseFeeUpdateManyAndReturnArgs} args - Arguments to update many FranchiseFees.
     * @example
     * // Update many FranchiseFees
     * const franchiseFee = await prisma.franchiseFee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FranchiseFees and only return the `id`
     * const franchiseFeeWithIdOnly = await prisma.franchiseFee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FranchiseFeeUpdateManyAndReturnArgs>(args: SelectSubset<T, FranchiseFeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FranchiseFee.
     * @param {FranchiseFeeUpsertArgs} args - Arguments to update or create a FranchiseFee.
     * @example
     * // Update or create a FranchiseFee
     * const franchiseFee = await prisma.franchiseFee.upsert({
     *   create: {
     *     // ... data to create a FranchiseFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FranchiseFee we want to update
     *   }
     * })
     */
    upsert<T extends FranchiseFeeUpsertArgs>(args: SelectSubset<T, FranchiseFeeUpsertArgs<ExtArgs>>): Prisma__FranchiseFeeClient<$Result.GetResult<Prisma.$FranchiseFeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FranchiseFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFeeCountArgs} args - Arguments to filter FranchiseFees to count.
     * @example
     * // Count the number of FranchiseFees
     * const count = await prisma.franchiseFee.count({
     *   where: {
     *     // ... the filter for the FranchiseFees we want to count
     *   }
     * })
    **/
    count<T extends FranchiseFeeCountArgs>(
      args?: Subset<T, FranchiseFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FranchiseFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FranchiseFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FranchiseFeeAggregateArgs>(args: Subset<T, FranchiseFeeAggregateArgs>): Prisma.PrismaPromise<GetFranchiseFeeAggregateType<T>>

    /**
     * Group by FranchiseFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FranchiseFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FranchiseFeeGroupByArgs['orderBy'] }
        : { orderBy?: FranchiseFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FranchiseFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFranchiseFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FranchiseFee model
   */
  readonly fields: FranchiseFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FranchiseFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FranchiseFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FranchiseFee model
   */
  interface FranchiseFeeFieldRefs {
    readonly id: FieldRef<"FranchiseFee", 'String'>
    readonly locationId: FieldRef<"FranchiseFee", 'String'>
    readonly month: FieldRef<"FranchiseFee", 'Int'>
    readonly year: FieldRef<"FranchiseFee", 'Int'>
    readonly serviceRevenue: FieldRef<"FranchiseFee", 'Float'>
    readonly productRevenue: FieldRef<"FranchiseFee", 'Float'>
    readonly subscriptionRevenue: FieldRef<"FranchiseFee", 'Float'>
    readonly totalRevenue: FieldRef<"FranchiseFee", 'Float'>
    readonly franchiseFee: FieldRef<"FranchiseFee", 'Float'>
    readonly royaltyFee: FieldRef<"FranchiseFee", 'Float'>
    readonly totalFees: FieldRef<"FranchiseFee", 'Float'>
    readonly isPaid: FieldRef<"FranchiseFee", 'Boolean'>
    readonly paidAt: FieldRef<"FranchiseFee", 'DateTime'>
    readonly dueDate: FieldRef<"FranchiseFee", 'DateTime'>
    readonly createdAt: FieldRef<"FranchiseFee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FranchiseFee findUnique
   */
  export type FranchiseFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * Filter, which FranchiseFee to fetch.
     */
    where: FranchiseFeeWhereUniqueInput
  }

  /**
   * FranchiseFee findUniqueOrThrow
   */
  export type FranchiseFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * Filter, which FranchiseFee to fetch.
     */
    where: FranchiseFeeWhereUniqueInput
  }

  /**
   * FranchiseFee findFirst
   */
  export type FranchiseFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * Filter, which FranchiseFee to fetch.
     */
    where?: FranchiseFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FranchiseFees to fetch.
     */
    orderBy?: FranchiseFeeOrderByWithRelationInput | FranchiseFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FranchiseFees.
     */
    cursor?: FranchiseFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FranchiseFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FranchiseFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FranchiseFees.
     */
    distinct?: FranchiseFeeScalarFieldEnum | FranchiseFeeScalarFieldEnum[]
  }

  /**
   * FranchiseFee findFirstOrThrow
   */
  export type FranchiseFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * Filter, which FranchiseFee to fetch.
     */
    where?: FranchiseFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FranchiseFees to fetch.
     */
    orderBy?: FranchiseFeeOrderByWithRelationInput | FranchiseFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FranchiseFees.
     */
    cursor?: FranchiseFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FranchiseFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FranchiseFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FranchiseFees.
     */
    distinct?: FranchiseFeeScalarFieldEnum | FranchiseFeeScalarFieldEnum[]
  }

  /**
   * FranchiseFee findMany
   */
  export type FranchiseFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * Filter, which FranchiseFees to fetch.
     */
    where?: FranchiseFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FranchiseFees to fetch.
     */
    orderBy?: FranchiseFeeOrderByWithRelationInput | FranchiseFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FranchiseFees.
     */
    cursor?: FranchiseFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FranchiseFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FranchiseFees.
     */
    skip?: number
    distinct?: FranchiseFeeScalarFieldEnum | FranchiseFeeScalarFieldEnum[]
  }

  /**
   * FranchiseFee create
   */
  export type FranchiseFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a FranchiseFee.
     */
    data: XOR<FranchiseFeeCreateInput, FranchiseFeeUncheckedCreateInput>
  }

  /**
   * FranchiseFee createMany
   */
  export type FranchiseFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FranchiseFees.
     */
    data: FranchiseFeeCreateManyInput | FranchiseFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FranchiseFee createManyAndReturn
   */
  export type FranchiseFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * The data used to create many FranchiseFees.
     */
    data: FranchiseFeeCreateManyInput | FranchiseFeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FranchiseFee update
   */
  export type FranchiseFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a FranchiseFee.
     */
    data: XOR<FranchiseFeeUpdateInput, FranchiseFeeUncheckedUpdateInput>
    /**
     * Choose, which FranchiseFee to update.
     */
    where: FranchiseFeeWhereUniqueInput
  }

  /**
   * FranchiseFee updateMany
   */
  export type FranchiseFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FranchiseFees.
     */
    data: XOR<FranchiseFeeUpdateManyMutationInput, FranchiseFeeUncheckedUpdateManyInput>
    /**
     * Filter which FranchiseFees to update
     */
    where?: FranchiseFeeWhereInput
    /**
     * Limit how many FranchiseFees to update.
     */
    limit?: number
  }

  /**
   * FranchiseFee updateManyAndReturn
   */
  export type FranchiseFeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * The data used to update FranchiseFees.
     */
    data: XOR<FranchiseFeeUpdateManyMutationInput, FranchiseFeeUncheckedUpdateManyInput>
    /**
     * Filter which FranchiseFees to update
     */
    where?: FranchiseFeeWhereInput
    /**
     * Limit how many FranchiseFees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FranchiseFee upsert
   */
  export type FranchiseFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the FranchiseFee to update in case it exists.
     */
    where: FranchiseFeeWhereUniqueInput
    /**
     * In case the FranchiseFee found by the `where` argument doesn't exist, create a new FranchiseFee with this data.
     */
    create: XOR<FranchiseFeeCreateInput, FranchiseFeeUncheckedCreateInput>
    /**
     * In case the FranchiseFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FranchiseFeeUpdateInput, FranchiseFeeUncheckedUpdateInput>
  }

  /**
   * FranchiseFee delete
   */
  export type FranchiseFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
    /**
     * Filter which FranchiseFee to delete.
     */
    where: FranchiseFeeWhereUniqueInput
  }

  /**
   * FranchiseFee deleteMany
   */
  export type FranchiseFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FranchiseFees to delete
     */
    where?: FranchiseFeeWhereInput
    /**
     * Limit how many FranchiseFees to delete.
     */
    limit?: number
  }

  /**
   * FranchiseFee without action
   */
  export type FranchiseFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseFee
     */
    select?: FranchiseFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FranchiseFee
     */
    omit?: FranchiseFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseFeeInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    duration: number | null
    price: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    duration: number | null
    price: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    customerId: string | null
    serviceType: string | null
    scheduledAt: Date | null
    duration: number | null
    price: number | null
    notes: string | null
    assignedTo: string | null
    status: $Enums.AppointmentStatus | null
    completedAt: Date | null
    squareOrderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    customerId: string | null
    serviceType: string | null
    scheduledAt: Date | null
    duration: number | null
    price: number | null
    notes: string | null
    assignedTo: string | null
    status: $Enums.AppointmentStatus | null
    completedAt: Date | null
    squareOrderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    locationId: number
    customerId: number
    serviceType: number
    scheduledAt: number
    duration: number
    price: number
    notes: number
    assignedTo: number
    status: number
    completedAt: number
    squareOrderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    duration?: true
    price?: true
  }

  export type AppointmentSumAggregateInputType = {
    duration?: true
    price?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    serviceType?: true
    scheduledAt?: true
    duration?: true
    price?: true
    notes?: true
    assignedTo?: true
    status?: true
    completedAt?: true
    squareOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    serviceType?: true
    scheduledAt?: true
    duration?: true
    price?: true
    notes?: true
    assignedTo?: true
    status?: true
    completedAt?: true
    squareOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    serviceType?: true
    scheduledAt?: true
    duration?: true
    price?: true
    notes?: true
    assignedTo?: true
    status?: true
    completedAt?: true
    squareOrderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    locationId: string
    customerId: string
    serviceType: string
    scheduledAt: Date
    duration: number
    price: number
    notes: string | null
    assignedTo: string | null
    status: $Enums.AppointmentStatus
    completedAt: Date | null
    squareOrderId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    serviceType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    price?: boolean
    notes?: boolean
    assignedTo?: boolean
    status?: boolean
    completedAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    serviceType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    price?: boolean
    notes?: boolean
    assignedTo?: boolean
    status?: boolean
    completedAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    serviceType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    price?: boolean
    notes?: boolean
    assignedTo?: boolean
    status?: boolean
    completedAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    serviceType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    price?: boolean
    notes?: boolean
    assignedTo?: boolean
    status?: boolean
    completedAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "customerId" | "serviceType" | "scheduledAt" | "duration" | "price" | "notes" | "assignedTo" | "status" | "completedAt" | "squareOrderId" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      customerId: string
      serviceType: string
      scheduledAt: Date
      duration: number
      price: number
      notes: string | null
      assignedTo: string | null
      status: $Enums.AppointmentStatus
      completedAt: Date | null
      squareOrderId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly locationId: FieldRef<"Appointment", 'String'>
    readonly customerId: FieldRef<"Appointment", 'String'>
    readonly serviceType: FieldRef<"Appointment", 'String'>
    readonly scheduledAt: FieldRef<"Appointment", 'DateTime'>
    readonly duration: FieldRef<"Appointment", 'Int'>
    readonly price: FieldRef<"Appointment", 'Float'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly assignedTo: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly completedAt: FieldRef<"Appointment", 'DateTime'>
    readonly squareOrderId: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    price: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    customerId: string | null
    packageType: string | null
    price: number | null
    billingInterval: string | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    nextBillingDate: Date | null
    canceledAt: Date | null
    squareSubscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    customerId: string | null
    packageType: string | null
    price: number | null
    billingInterval: string | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    nextBillingDate: Date | null
    canceledAt: Date | null
    squareSubscriptionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    locationId: number
    customerId: number
    packageType: number
    price: number
    billingInterval: number
    status: number
    startDate: number
    nextBillingDate: number
    canceledAt: number
    squareSubscriptionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    price?: true
  }

  export type SubscriptionSumAggregateInputType = {
    price?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    packageType?: true
    price?: true
    billingInterval?: true
    status?: true
    startDate?: true
    nextBillingDate?: true
    canceledAt?: true
    squareSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    packageType?: true
    price?: true
    billingInterval?: true
    status?: true
    startDate?: true
    nextBillingDate?: true
    canceledAt?: true
    squareSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    packageType?: true
    price?: true
    billingInterval?: true
    status?: true
    startDate?: true
    nextBillingDate?: true
    canceledAt?: true
    squareSubscriptionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    locationId: string
    customerId: string
    packageType: string
    price: number
    billingInterval: string
    status: $Enums.SubscriptionStatus
    startDate: Date
    nextBillingDate: Date | null
    canceledAt: Date | null
    squareSubscriptionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    packageType?: boolean
    price?: boolean
    billingInterval?: boolean
    status?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    canceledAt?: boolean
    squareSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    packageType?: boolean
    price?: boolean
    billingInterval?: boolean
    status?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    canceledAt?: boolean
    squareSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    packageType?: boolean
    price?: boolean
    billingInterval?: boolean
    status?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    canceledAt?: boolean
    squareSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    packageType?: boolean
    price?: boolean
    billingInterval?: boolean
    status?: boolean
    startDate?: boolean
    nextBillingDate?: boolean
    canceledAt?: boolean
    squareSubscriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "customerId" | "packageType" | "price" | "billingInterval" | "status" | "startDate" | "nextBillingDate" | "canceledAt" | "squareSubscriptionId" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      customerId: string
      packageType: string
      price: number
      billingInterval: string
      status: $Enums.SubscriptionStatus
      startDate: Date
      nextBillingDate: Date | null
      canceledAt: Date | null
      squareSubscriptionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly locationId: FieldRef<"Subscription", 'String'>
    readonly customerId: FieldRef<"Subscription", 'String'>
    readonly packageType: FieldRef<"Subscription", 'String'>
    readonly price: FieldRef<"Subscription", 'Float'>
    readonly billingInterval: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"Subscription", 'DateTime'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly squareSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    cost: number | null
    stockQuantity: number | null
    lowStockThreshold: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    cost: number | null
    stockQuantity: number | null
    lowStockThreshold: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    name: string | null
    description: string | null
    category: string | null
    price: number | null
    cost: number | null
    stockQuantity: number | null
    lowStockThreshold: number | null
    squareItemId: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    name: string | null
    description: string | null
    category: string | null
    price: number | null
    cost: number | null
    stockQuantity: number | null
    lowStockThreshold: number | null
    squareItemId: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    locationId: number
    name: number
    description: number
    category: number
    price: number
    cost: number
    stockQuantity: number
    lowStockThreshold: number
    squareItemId: number
    imageUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    cost?: true
    stockQuantity?: true
    lowStockThreshold?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    cost?: true
    stockQuantity?: true
    lowStockThreshold?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    cost?: true
    stockQuantity?: true
    lowStockThreshold?: true
    squareItemId?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    cost?: true
    stockQuantity?: true
    lowStockThreshold?: true
    squareItemId?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    locationId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    cost?: true
    stockQuantity?: true
    lowStockThreshold?: true
    squareItemId?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    locationId: string | null
    name: string
    description: string | null
    category: string
    price: number
    cost: number | null
    stockQuantity: number
    lowStockThreshold: number
    squareItemId: string | null
    imageUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    cost?: boolean
    stockQuantity?: boolean
    lowStockThreshold?: boolean
    squareItemId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Product$locationArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    cost?: boolean
    stockQuantity?: boolean
    lowStockThreshold?: boolean
    squareItemId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Product$locationArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    cost?: boolean
    stockQuantity?: boolean
    lowStockThreshold?: boolean
    squareItemId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Product$locationArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    cost?: boolean
    stockQuantity?: boolean
    lowStockThreshold?: boolean
    squareItemId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "name" | "description" | "category" | "price" | "cost" | "stockQuantity" | "lowStockThreshold" | "squareItemId" | "imageUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Product$locationArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Product$locationArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Product$locationArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string | null
      name: string
      description: string | null
      category: string
      price: number
      cost: number | null
      stockQuantity: number
      lowStockThreshold: number
      squareItemId: string | null
      imageUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends Product$locationArgs<ExtArgs> = {}>(args?: Subset<T, Product$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly locationId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly cost: FieldRef<"Product", 'Float'>
    readonly stockQuantity: FieldRef<"Product", 'Int'>
    readonly lowStockThreshold: FieldRef<"Product", 'Int'>
    readonly squareItemId: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.location
   */
  export type Product$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type OrderSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    customerId: string | null
    subtotal: number | null
    tax: number | null
    total: number | null
    status: $Enums.OrderStatus | null
    shippingAddress: string | null
    fulfilledAt: Date | null
    squareOrderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    customerId: string | null
    subtotal: number | null
    tax: number | null
    total: number | null
    status: $Enums.OrderStatus | null
    shippingAddress: string | null
    fulfilledAt: Date | null
    squareOrderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    locationId: number
    customerId: number
    subtotal: number
    tax: number
    total: number
    status: number
    shippingAddress: number
    fulfilledAt: number
    squareOrderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type OrderSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    shippingAddress?: true
    fulfilledAt?: true
    squareOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    shippingAddress?: true
    fulfilledAt?: true
    squareOrderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    locationId?: true
    customerId?: true
    subtotal?: true
    tax?: true
    total?: true
    status?: true
    shippingAddress?: true
    fulfilledAt?: true
    squareOrderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    locationId: string
    customerId: string | null
    subtotal: number
    tax: number
    total: number
    status: $Enums.OrderStatus
    shippingAddress: string | null
    fulfilledAt: Date | null
    squareOrderId: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    shippingAddress?: boolean
    fulfilledAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    shippingAddress?: boolean
    fulfilledAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    shippingAddress?: boolean
    fulfilledAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    locationId?: boolean
    customerId?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    shippingAddress?: boolean
    fulfilledAt?: boolean
    squareOrderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "customerId" | "subtotal" | "tax" | "total" | "status" | "shippingAddress" | "fulfilledAt" | "squareOrderId" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      customerId: string | null
      subtotal: number
      tax: number
      total: number
      status: $Enums.OrderStatus
      shippingAddress: string | null
      fulfilledAt: Date | null
      squareOrderId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Order$customerArgs<ExtArgs> = {}>(args?: Subset<T, Order$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly locationId: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly subtotal: FieldRef<"Order", 'Float'>
    readonly tax: FieldRef<"Order", 'Float'>
    readonly total: FieldRef<"Order", 'Float'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly shippingAddress: FieldRef<"Order", 'String'>
    readonly fulfilledAt: FieldRef<"Order", 'DateTime'>
    readonly squareOrderId: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.customer
   */
  export type Order$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    discount: string | null
    quantity: number | null
    price: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    discount: string | null
    quantity: number | null
    price: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    discount: number
    quantity: number
    price: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    discount?: true
    quantity?: true
    price?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    discount?: true
    quantity?: true
    price?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    discount?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    discount: string | null
    quantity: number
    price: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    discount?: boolean
    quantity?: boolean
    price?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    discount?: boolean
    quantity?: boolean
    price?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    discount?: boolean
    quantity?: boolean
    price?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    discount?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "discount" | "quantity" | "price", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      discount: string | null
      quantity: number
      price: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly discount: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model GithubCallback
   */

  export type AggregateGithubCallback = {
    _count: GithubCallbackCountAggregateOutputType | null
    _min: GithubCallbackMinAggregateOutputType | null
    _max: GithubCallbackMaxAggregateOutputType | null
  }

  export type GithubCallbackMinAggregateOutputType = {
    id: string | null
    callbackId: string | null
    streamUrl: string | null
    streamStatus: string | null
    pluginId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GithubCallbackMaxAggregateOutputType = {
    id: string | null
    callbackId: string | null
    streamUrl: string | null
    streamStatus: string | null
    pluginId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GithubCallbackCountAggregateOutputType = {
    id: number
    callbackId: number
    streamUrl: number
    streamStatus: number
    data: number
    pluginId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GithubCallbackMinAggregateInputType = {
    id?: true
    callbackId?: true
    streamUrl?: true
    streamStatus?: true
    pluginId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GithubCallbackMaxAggregateInputType = {
    id?: true
    callbackId?: true
    streamUrl?: true
    streamStatus?: true
    pluginId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GithubCallbackCountAggregateInputType = {
    id?: true
    callbackId?: true
    streamUrl?: true
    streamStatus?: true
    data?: true
    pluginId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GithubCallbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GithubCallback to aggregate.
     */
    where?: GithubCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubCallbacks to fetch.
     */
    orderBy?: GithubCallbackOrderByWithRelationInput | GithubCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GithubCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubCallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GithubCallbacks
    **/
    _count?: true | GithubCallbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GithubCallbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GithubCallbackMaxAggregateInputType
  }

  export type GetGithubCallbackAggregateType<T extends GithubCallbackAggregateArgs> = {
        [P in keyof T & keyof AggregateGithubCallback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGithubCallback[P]>
      : GetScalarType<T[P], AggregateGithubCallback[P]>
  }




  export type GithubCallbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubCallbackWhereInput
    orderBy?: GithubCallbackOrderByWithAggregationInput | GithubCallbackOrderByWithAggregationInput[]
    by: GithubCallbackScalarFieldEnum[] | GithubCallbackScalarFieldEnum
    having?: GithubCallbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GithubCallbackCountAggregateInputType | true
    _min?: GithubCallbackMinAggregateInputType
    _max?: GithubCallbackMaxAggregateInputType
  }

  export type GithubCallbackGroupByOutputType = {
    id: string
    callbackId: string
    streamUrl: string | null
    streamStatus: string | null
    data: JsonValue | null
    pluginId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GithubCallbackCountAggregateOutputType | null
    _min: GithubCallbackMinAggregateOutputType | null
    _max: GithubCallbackMaxAggregateOutputType | null
  }

  type GetGithubCallbackGroupByPayload<T extends GithubCallbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GithubCallbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GithubCallbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GithubCallbackGroupByOutputType[P]>
            : GetScalarType<T[P], GithubCallbackGroupByOutputType[P]>
        }
      >
    >


  export type GithubCallbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callbackId?: boolean
    streamUrl?: boolean
    streamStatus?: boolean
    data?: boolean
    pluginId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plugin?: boolean | GithubCallback$pluginArgs<ExtArgs>
  }, ExtArgs["result"]["githubCallback"]>

  export type GithubCallbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callbackId?: boolean
    streamUrl?: boolean
    streamStatus?: boolean
    data?: boolean
    pluginId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plugin?: boolean | GithubCallback$pluginArgs<ExtArgs>
  }, ExtArgs["result"]["githubCallback"]>

  export type GithubCallbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callbackId?: boolean
    streamUrl?: boolean
    streamStatus?: boolean
    data?: boolean
    pluginId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plugin?: boolean | GithubCallback$pluginArgs<ExtArgs>
  }, ExtArgs["result"]["githubCallback"]>

  export type GithubCallbackSelectScalar = {
    id?: boolean
    callbackId?: boolean
    streamUrl?: boolean
    streamStatus?: boolean
    data?: boolean
    pluginId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GithubCallbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "callbackId" | "streamUrl" | "streamStatus" | "data" | "pluginId" | "createdAt" | "updatedAt", ExtArgs["result"]["githubCallback"]>
  export type GithubCallbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plugin?: boolean | GithubCallback$pluginArgs<ExtArgs>
  }
  export type GithubCallbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plugin?: boolean | GithubCallback$pluginArgs<ExtArgs>
  }
  export type GithubCallbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plugin?: boolean | GithubCallback$pluginArgs<ExtArgs>
  }

  export type $GithubCallbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GithubCallback"
    objects: {
      plugin: Prisma.$PluginPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      callbackId: string
      streamUrl: string | null
      streamStatus: string | null
      data: Prisma.JsonValue | null
      pluginId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["githubCallback"]>
    composites: {}
  }

  type GithubCallbackGetPayload<S extends boolean | null | undefined | GithubCallbackDefaultArgs> = $Result.GetResult<Prisma.$GithubCallbackPayload, S>

  type GithubCallbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GithubCallbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GithubCallbackCountAggregateInputType | true
    }

  export interface GithubCallbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GithubCallback'], meta: { name: 'GithubCallback' } }
    /**
     * Find zero or one GithubCallback that matches the filter.
     * @param {GithubCallbackFindUniqueArgs} args - Arguments to find a GithubCallback
     * @example
     * // Get one GithubCallback
     * const githubCallback = await prisma.githubCallback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GithubCallbackFindUniqueArgs>(args: SelectSubset<T, GithubCallbackFindUniqueArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GithubCallback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GithubCallbackFindUniqueOrThrowArgs} args - Arguments to find a GithubCallback
     * @example
     * // Get one GithubCallback
     * const githubCallback = await prisma.githubCallback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GithubCallbackFindUniqueOrThrowArgs>(args: SelectSubset<T, GithubCallbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GithubCallback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubCallbackFindFirstArgs} args - Arguments to find a GithubCallback
     * @example
     * // Get one GithubCallback
     * const githubCallback = await prisma.githubCallback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GithubCallbackFindFirstArgs>(args?: SelectSubset<T, GithubCallbackFindFirstArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GithubCallback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubCallbackFindFirstOrThrowArgs} args - Arguments to find a GithubCallback
     * @example
     * // Get one GithubCallback
     * const githubCallback = await prisma.githubCallback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GithubCallbackFindFirstOrThrowArgs>(args?: SelectSubset<T, GithubCallbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GithubCallbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubCallbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GithubCallbacks
     * const githubCallbacks = await prisma.githubCallback.findMany()
     * 
     * // Get first 10 GithubCallbacks
     * const githubCallbacks = await prisma.githubCallback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const githubCallbackWithIdOnly = await prisma.githubCallback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GithubCallbackFindManyArgs>(args?: SelectSubset<T, GithubCallbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GithubCallback.
     * @param {GithubCallbackCreateArgs} args - Arguments to create a GithubCallback.
     * @example
     * // Create one GithubCallback
     * const GithubCallback = await prisma.githubCallback.create({
     *   data: {
     *     // ... data to create a GithubCallback
     *   }
     * })
     * 
     */
    create<T extends GithubCallbackCreateArgs>(args: SelectSubset<T, GithubCallbackCreateArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GithubCallbacks.
     * @param {GithubCallbackCreateManyArgs} args - Arguments to create many GithubCallbacks.
     * @example
     * // Create many GithubCallbacks
     * const githubCallback = await prisma.githubCallback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GithubCallbackCreateManyArgs>(args?: SelectSubset<T, GithubCallbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GithubCallbacks and returns the data saved in the database.
     * @param {GithubCallbackCreateManyAndReturnArgs} args - Arguments to create many GithubCallbacks.
     * @example
     * // Create many GithubCallbacks
     * const githubCallback = await prisma.githubCallback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GithubCallbacks and only return the `id`
     * const githubCallbackWithIdOnly = await prisma.githubCallback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GithubCallbackCreateManyAndReturnArgs>(args?: SelectSubset<T, GithubCallbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GithubCallback.
     * @param {GithubCallbackDeleteArgs} args - Arguments to delete one GithubCallback.
     * @example
     * // Delete one GithubCallback
     * const GithubCallback = await prisma.githubCallback.delete({
     *   where: {
     *     // ... filter to delete one GithubCallback
     *   }
     * })
     * 
     */
    delete<T extends GithubCallbackDeleteArgs>(args: SelectSubset<T, GithubCallbackDeleteArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GithubCallback.
     * @param {GithubCallbackUpdateArgs} args - Arguments to update one GithubCallback.
     * @example
     * // Update one GithubCallback
     * const githubCallback = await prisma.githubCallback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GithubCallbackUpdateArgs>(args: SelectSubset<T, GithubCallbackUpdateArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GithubCallbacks.
     * @param {GithubCallbackDeleteManyArgs} args - Arguments to filter GithubCallbacks to delete.
     * @example
     * // Delete a few GithubCallbacks
     * const { count } = await prisma.githubCallback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GithubCallbackDeleteManyArgs>(args?: SelectSubset<T, GithubCallbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GithubCallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubCallbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GithubCallbacks
     * const githubCallback = await prisma.githubCallback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GithubCallbackUpdateManyArgs>(args: SelectSubset<T, GithubCallbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GithubCallbacks and returns the data updated in the database.
     * @param {GithubCallbackUpdateManyAndReturnArgs} args - Arguments to update many GithubCallbacks.
     * @example
     * // Update many GithubCallbacks
     * const githubCallback = await prisma.githubCallback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GithubCallbacks and only return the `id`
     * const githubCallbackWithIdOnly = await prisma.githubCallback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GithubCallbackUpdateManyAndReturnArgs>(args: SelectSubset<T, GithubCallbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GithubCallback.
     * @param {GithubCallbackUpsertArgs} args - Arguments to update or create a GithubCallback.
     * @example
     * // Update or create a GithubCallback
     * const githubCallback = await prisma.githubCallback.upsert({
     *   create: {
     *     // ... data to create a GithubCallback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GithubCallback we want to update
     *   }
     * })
     */
    upsert<T extends GithubCallbackUpsertArgs>(args: SelectSubset<T, GithubCallbackUpsertArgs<ExtArgs>>): Prisma__GithubCallbackClient<$Result.GetResult<Prisma.$GithubCallbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GithubCallbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubCallbackCountArgs} args - Arguments to filter GithubCallbacks to count.
     * @example
     * // Count the number of GithubCallbacks
     * const count = await prisma.githubCallback.count({
     *   where: {
     *     // ... the filter for the GithubCallbacks we want to count
     *   }
     * })
    **/
    count<T extends GithubCallbackCountArgs>(
      args?: Subset<T, GithubCallbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GithubCallbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GithubCallback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubCallbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GithubCallbackAggregateArgs>(args: Subset<T, GithubCallbackAggregateArgs>): Prisma.PrismaPromise<GetGithubCallbackAggregateType<T>>

    /**
     * Group by GithubCallback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubCallbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GithubCallbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GithubCallbackGroupByArgs['orderBy'] }
        : { orderBy?: GithubCallbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GithubCallbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGithubCallbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GithubCallback model
   */
  readonly fields: GithubCallbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GithubCallback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GithubCallbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plugin<T extends GithubCallback$pluginArgs<ExtArgs> = {}>(args?: Subset<T, GithubCallback$pluginArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GithubCallback model
   */
  interface GithubCallbackFieldRefs {
    readonly id: FieldRef<"GithubCallback", 'String'>
    readonly callbackId: FieldRef<"GithubCallback", 'String'>
    readonly streamUrl: FieldRef<"GithubCallback", 'String'>
    readonly streamStatus: FieldRef<"GithubCallback", 'String'>
    readonly data: FieldRef<"GithubCallback", 'Json'>
    readonly pluginId: FieldRef<"GithubCallback", 'String'>
    readonly createdAt: FieldRef<"GithubCallback", 'DateTime'>
    readonly updatedAt: FieldRef<"GithubCallback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GithubCallback findUnique
   */
  export type GithubCallbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * Filter, which GithubCallback to fetch.
     */
    where: GithubCallbackWhereUniqueInput
  }

  /**
   * GithubCallback findUniqueOrThrow
   */
  export type GithubCallbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * Filter, which GithubCallback to fetch.
     */
    where: GithubCallbackWhereUniqueInput
  }

  /**
   * GithubCallback findFirst
   */
  export type GithubCallbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * Filter, which GithubCallback to fetch.
     */
    where?: GithubCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubCallbacks to fetch.
     */
    orderBy?: GithubCallbackOrderByWithRelationInput | GithubCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GithubCallbacks.
     */
    cursor?: GithubCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubCallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GithubCallbacks.
     */
    distinct?: GithubCallbackScalarFieldEnum | GithubCallbackScalarFieldEnum[]
  }

  /**
   * GithubCallback findFirstOrThrow
   */
  export type GithubCallbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * Filter, which GithubCallback to fetch.
     */
    where?: GithubCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubCallbacks to fetch.
     */
    orderBy?: GithubCallbackOrderByWithRelationInput | GithubCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GithubCallbacks.
     */
    cursor?: GithubCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubCallbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GithubCallbacks.
     */
    distinct?: GithubCallbackScalarFieldEnum | GithubCallbackScalarFieldEnum[]
  }

  /**
   * GithubCallback findMany
   */
  export type GithubCallbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * Filter, which GithubCallbacks to fetch.
     */
    where?: GithubCallbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubCallbacks to fetch.
     */
    orderBy?: GithubCallbackOrderByWithRelationInput | GithubCallbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GithubCallbacks.
     */
    cursor?: GithubCallbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubCallbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubCallbacks.
     */
    skip?: number
    distinct?: GithubCallbackScalarFieldEnum | GithubCallbackScalarFieldEnum[]
  }

  /**
   * GithubCallback create
   */
  export type GithubCallbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * The data needed to create a GithubCallback.
     */
    data: XOR<GithubCallbackCreateInput, GithubCallbackUncheckedCreateInput>
  }

  /**
   * GithubCallback createMany
   */
  export type GithubCallbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GithubCallbacks.
     */
    data: GithubCallbackCreateManyInput | GithubCallbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GithubCallback createManyAndReturn
   */
  export type GithubCallbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * The data used to create many GithubCallbacks.
     */
    data: GithubCallbackCreateManyInput | GithubCallbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GithubCallback update
   */
  export type GithubCallbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * The data needed to update a GithubCallback.
     */
    data: XOR<GithubCallbackUpdateInput, GithubCallbackUncheckedUpdateInput>
    /**
     * Choose, which GithubCallback to update.
     */
    where: GithubCallbackWhereUniqueInput
  }

  /**
   * GithubCallback updateMany
   */
  export type GithubCallbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GithubCallbacks.
     */
    data: XOR<GithubCallbackUpdateManyMutationInput, GithubCallbackUncheckedUpdateManyInput>
    /**
     * Filter which GithubCallbacks to update
     */
    where?: GithubCallbackWhereInput
    /**
     * Limit how many GithubCallbacks to update.
     */
    limit?: number
  }

  /**
   * GithubCallback updateManyAndReturn
   */
  export type GithubCallbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * The data used to update GithubCallbacks.
     */
    data: XOR<GithubCallbackUpdateManyMutationInput, GithubCallbackUncheckedUpdateManyInput>
    /**
     * Filter which GithubCallbacks to update
     */
    where?: GithubCallbackWhereInput
    /**
     * Limit how many GithubCallbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GithubCallback upsert
   */
  export type GithubCallbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * The filter to search for the GithubCallback to update in case it exists.
     */
    where: GithubCallbackWhereUniqueInput
    /**
     * In case the GithubCallback found by the `where` argument doesn't exist, create a new GithubCallback with this data.
     */
    create: XOR<GithubCallbackCreateInput, GithubCallbackUncheckedCreateInput>
    /**
     * In case the GithubCallback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GithubCallbackUpdateInput, GithubCallbackUncheckedUpdateInput>
  }

  /**
   * GithubCallback delete
   */
  export type GithubCallbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
    /**
     * Filter which GithubCallback to delete.
     */
    where: GithubCallbackWhereUniqueInput
  }

  /**
   * GithubCallback deleteMany
   */
  export type GithubCallbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GithubCallbacks to delete
     */
    where?: GithubCallbackWhereInput
    /**
     * Limit how many GithubCallbacks to delete.
     */
    limit?: number
  }

  /**
   * GithubCallback.plugin
   */
  export type GithubCallback$pluginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    where?: PluginWhereInput
  }

  /**
   * GithubCallback without action
   */
  export type GithubCallbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubCallback
     */
    select?: GithubCallbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GithubCallback
     */
    omit?: GithubCallbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GithubCallbackInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    clerkUserId: 'clerkUserId',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hasCustomerAccount: 'hasCustomerAccount'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PluginScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    name: 'name',
    description: 'description',
    category: 'category',
    templateId: 'templateId',
    template: 'template',
    gitRepo: 'gitRepo',
    pricingModel: 'pricingModel',
    oneTimePrice: 'oneTimePrice',
    subscriptionTier: 'subscriptionTier',
    usagePrice: 'usagePrice',
    whiteLabel: 'whiteLabel',
    isPublished: 'isPublished',
    isActive: 'isActive',
    deploymentStatus: 'deploymentStatus',
    deploymentUrl: 'deploymentUrl',
    apiEndpoint: 'apiEndpoint',
    totalInstalls: 'totalInstalls',
    monthlyActiveUsers: 'monthlyActiveUsers',
    totalRevenue: 'totalRevenue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt'
  };

  export type PluginScalarFieldEnum = (typeof PluginScalarFieldEnum)[keyof typeof PluginScalarFieldEnum]


  export const PluginPurchaseScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    pluginId: 'pluginId',
    purchaseType: 'purchaseType',
    amount: 'amount',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionStartDate: 'subscriptionStartDate',
    subscriptionEndDate: 'subscriptionEndDate',
    nextBillingDate: 'nextBillingDate',
    isActive: 'isActive',
    apiKey: 'apiKey',
    usageLimit: 'usageLimit',
    usageCount: 'usageCount',
    purchasedAt: 'purchasedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type PluginPurchaseScalarFieldEnum = (typeof PluginPurchaseScalarFieldEnum)[keyof typeof PluginPurchaseScalarFieldEnum]


  export const PluginUsageScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    pluginId: 'pluginId',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    responseTime: 'responseTime',
    requestSize: 'requestSize',
    responseSize: 'responseSize',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    timestamp: 'timestamp'
  };

  export type PluginUsageScalarFieldEnum = (typeof PluginUsageScalarFieldEnum)[keyof typeof PluginUsageScalarFieldEnum]


  export const UserAdministratorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    canViewFinancials: 'canViewFinancials',
    canManageStaff: 'canManageStaff',
    canEditAppointments: 'canEditAppointments',
    canViewReports: 'canViewReports',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type UserAdministratorScalarFieldEnum = (typeof UserAdministratorScalarFieldEnum)[keyof typeof UserAdministratorScalarFieldEnum]


  export const TerritoryScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    territoryCode: 'territoryCode',
    territoryName: 'territoryName',
    territoryAddress: 'territoryAddress',
    territoryCity: 'territoryCity',
    territoryState: 'territoryState',
    territoryZipCode: 'territoryZipCode',
    territoryPhone: 'territoryPhone',
    territoryEmail: 'territoryEmail',
    exclusiveRadius: 'exclusiveRadius',
    populationServed: 'populationServed',
    marketPenetration: 'marketPenetration',
    assignedAt: 'assignedAt'
  };

  export type TerritoryScalarFieldEnum = (typeof TerritoryScalarFieldEnum)[keyof typeof TerritoryScalarFieldEnum]


  export const CSIScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    score: 'score',
    comment: 'comment',
    source: 'source',
    surveyType: 'surveyType',
    customerId: 'customerId',
    recordedAt: 'recordedAt',
    recordedBy: 'recordedBy'
  };

  export type CSIScalarFieldEnum = (typeof CSIScalarFieldEnum)[keyof typeof CSIScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    email: 'email',
    isActive: 'isActive',
    franchiseId: 'franchiseId',
    ownerId: 'ownerId',
    franchiseFeeRate: 'franchiseFeeRate',
    royaltyRate: 'royaltyRate',
    timezone: 'timezone',
    businessHours: 'businessHours',
    currentCSIAverage: 'currentCSIAverage',
    lastCSIUpdate: 'lastCSIUpdate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const TerritoriesAvailableScalarFieldEnum: {
    id: 'id',
    territoryCode: 'territoryCode',
    territoryName: 'territoryName',
    state: 'state',
    city: 'city',
    zipCodes: 'zipCodes',
    county: 'county',
    estimatedPopulation: 'estimatedPopulation',
    averageIncome: 'averageIncome',
    competitorCount: 'competitorCount',
    marketPotential: 'marketPotential',
    franchiseFee: 'franchiseFee',
    minimumInvestment: 'minimumInvestment',
    exclusiveRadius: 'exclusiveRadius',
    isAvailable: 'isAvailable',
    reservedUntil: 'reservedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TerritoriesAvailableScalarFieldEnum = (typeof TerritoriesAvailableScalarFieldEnum)[keyof typeof TerritoriesAvailableScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    role: 'role',
    dogName: 'dogName',
    dogBreed: 'dogBreed',
    dogAge: 'dogAge',
    dogWeight: 'dogWeight',
    allergies: 'allergies',
    preferredGroomer: 'preferredGroomer',
    notes: 'notes',
    squareCustomerId: 'squareCustomerId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const FranchiseFeeScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    month: 'month',
    year: 'year',
    serviceRevenue: 'serviceRevenue',
    productRevenue: 'productRevenue',
    subscriptionRevenue: 'subscriptionRevenue',
    totalRevenue: 'totalRevenue',
    franchiseFee: 'franchiseFee',
    royaltyFee: 'royaltyFee',
    totalFees: 'totalFees',
    isPaid: 'isPaid',
    paidAt: 'paidAt',
    dueDate: 'dueDate',
    createdAt: 'createdAt'
  };

  export type FranchiseFeeScalarFieldEnum = (typeof FranchiseFeeScalarFieldEnum)[keyof typeof FranchiseFeeScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    customerId: 'customerId',
    serviceType: 'serviceType',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    price: 'price',
    notes: 'notes',
    assignedTo: 'assignedTo',
    status: 'status',
    completedAt: 'completedAt',
    squareOrderId: 'squareOrderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    customerId: 'customerId',
    packageType: 'packageType',
    price: 'price',
    billingInterval: 'billingInterval',
    status: 'status',
    startDate: 'startDate',
    nextBillingDate: 'nextBillingDate',
    canceledAt: 'canceledAt',
    squareSubscriptionId: 'squareSubscriptionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    name: 'name',
    description: 'description',
    category: 'category',
    price: 'price',
    cost: 'cost',
    stockQuantity: 'stockQuantity',
    lowStockThreshold: 'lowStockThreshold',
    squareItemId: 'squareItemId',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    customerId: 'customerId',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    status: 'status',
    shippingAddress: 'shippingAddress',
    fulfilledAt: 'fulfilledAt',
    squareOrderId: 'squareOrderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    discount: 'discount',
    quantity: 'quantity',
    price: 'price'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const GithubCallbackScalarFieldEnum: {
    id: 'id',
    callbackId: 'callbackId',
    streamUrl: 'streamUrl',
    streamStatus: 'streamStatus',
    data: 'data',
    pluginId: 'pluginId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GithubCallbackScalarFieldEnum = (typeof GithubCallbackScalarFieldEnum)[keyof typeof GithubCallbackScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PluginCategory'
   */
  export type EnumPluginCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PluginCategory'>
    


  /**
   * Reference to a field of type 'PluginCategory[]'
   */
  export type ListEnumPluginCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PluginCategory[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PricingModel'
   */
  export type EnumPricingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingModel'>
    


  /**
   * Reference to a field of type 'PricingModel[]'
   */
  export type ListEnumPricingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingModel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DeploymentStatus'
   */
  export type EnumDeploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeploymentStatus'>
    


  /**
   * Reference to a field of type 'DeploymentStatus[]'
   */
  export type ListEnumDeploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeploymentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PurchaseType'
   */
  export type EnumPurchaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseType'>
    


  /**
   * Reference to a field of type 'PurchaseType[]'
   */
  export type ListEnumPurchaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseType[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'CSISource'
   */
  export type EnumCSISourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CSISource'>
    


  /**
   * Reference to a field of type 'CSISource[]'
   */
  export type ListEnumCSISourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CSISource[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    clerkUserId?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    hasCustomerAccount?: BoolFilter<"User"> | boolean
    ownedLocations?: LocationListRelationFilter
    locationAccess?: UserAdministratorListRelationFilter
    customerAccount?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdPlugins?: PluginListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasCustomerAccount?: SortOrder
    ownedLocations?: LocationOrderByRelationAggregateInput
    locationAccess?: UserAdministratorOrderByRelationAggregateInput
    customerAccount?: CustomerOrderByWithRelationInput
    createdPlugins?: PluginOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    clerkUserId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    hasCustomerAccount?: BoolFilter<"User"> | boolean
    ownedLocations?: LocationListRelationFilter
    locationAccess?: UserAdministratorListRelationFilter
    customerAccount?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdPlugins?: PluginListRelationFilter
  }, "id" | "email" | "clerkUserId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasCustomerAccount?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    clerkUserId?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    hasCustomerAccount?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type PluginWhereInput = {
    AND?: PluginWhereInput | PluginWhereInput[]
    OR?: PluginWhereInput[]
    NOT?: PluginWhereInput | PluginWhereInput[]
    id?: StringFilter<"Plugin"> | string
    creatorId?: StringFilter<"Plugin"> | string
    name?: StringFilter<"Plugin"> | string
    description?: StringFilter<"Plugin"> | string
    category?: EnumPluginCategoryFilter<"Plugin"> | $Enums.PluginCategory
    templateId?: StringFilter<"Plugin"> | string
    template?: JsonFilter<"Plugin">
    gitRepo?: StringNullableFilter<"Plugin"> | string | null
    pricingModel?: EnumPricingModelFilter<"Plugin"> | $Enums.PricingModel
    oneTimePrice?: FloatNullableFilter<"Plugin"> | number | null
    subscriptionTier?: StringNullableFilter<"Plugin"> | string | null
    usagePrice?: FloatNullableFilter<"Plugin"> | number | null
    whiteLabel?: BoolFilter<"Plugin"> | boolean
    isPublished?: BoolFilter<"Plugin"> | boolean
    isActive?: BoolFilter<"Plugin"> | boolean
    deploymentStatus?: EnumDeploymentStatusFilter<"Plugin"> | $Enums.DeploymentStatus
    deploymentUrl?: StringNullableFilter<"Plugin"> | string | null
    apiEndpoint?: StringNullableFilter<"Plugin"> | string | null
    totalInstalls?: IntFilter<"Plugin"> | number
    monthlyActiveUsers?: IntFilter<"Plugin"> | number
    totalRevenue?: FloatFilter<"Plugin"> | number
    createdAt?: DateTimeFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeFilter<"Plugin"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Plugin"> | Date | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchases?: PluginPurchaseListRelationFilter
    usageRecords?: PluginUsageListRelationFilter
    githubCallbacks?: GithubCallbackListRelationFilter
  }

  export type PluginOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
    template?: SortOrder
    gitRepo?: SortOrderInput | SortOrder
    pricingModel?: SortOrder
    oneTimePrice?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrderInput | SortOrder
    usagePrice?: SortOrderInput | SortOrder
    whiteLabel?: SortOrder
    isPublished?: SortOrder
    isActive?: SortOrder
    deploymentStatus?: SortOrder
    deploymentUrl?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    totalInstalls?: SortOrder
    monthlyActiveUsers?: SortOrder
    totalRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    purchases?: PluginPurchaseOrderByRelationAggregateInput
    usageRecords?: PluginUsageOrderByRelationAggregateInput
    githubCallbacks?: GithubCallbackOrderByRelationAggregateInput
  }

  export type PluginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PluginWhereInput | PluginWhereInput[]
    OR?: PluginWhereInput[]
    NOT?: PluginWhereInput | PluginWhereInput[]
    creatorId?: StringFilter<"Plugin"> | string
    name?: StringFilter<"Plugin"> | string
    description?: StringFilter<"Plugin"> | string
    category?: EnumPluginCategoryFilter<"Plugin"> | $Enums.PluginCategory
    templateId?: StringFilter<"Plugin"> | string
    template?: JsonFilter<"Plugin">
    gitRepo?: StringNullableFilter<"Plugin"> | string | null
    pricingModel?: EnumPricingModelFilter<"Plugin"> | $Enums.PricingModel
    oneTimePrice?: FloatNullableFilter<"Plugin"> | number | null
    subscriptionTier?: StringNullableFilter<"Plugin"> | string | null
    usagePrice?: FloatNullableFilter<"Plugin"> | number | null
    whiteLabel?: BoolFilter<"Plugin"> | boolean
    isPublished?: BoolFilter<"Plugin"> | boolean
    isActive?: BoolFilter<"Plugin"> | boolean
    deploymentStatus?: EnumDeploymentStatusFilter<"Plugin"> | $Enums.DeploymentStatus
    deploymentUrl?: StringNullableFilter<"Plugin"> | string | null
    apiEndpoint?: StringNullableFilter<"Plugin"> | string | null
    totalInstalls?: IntFilter<"Plugin"> | number
    monthlyActiveUsers?: IntFilter<"Plugin"> | number
    totalRevenue?: FloatFilter<"Plugin"> | number
    createdAt?: DateTimeFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeFilter<"Plugin"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Plugin"> | Date | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchases?: PluginPurchaseListRelationFilter
    usageRecords?: PluginUsageListRelationFilter
    githubCallbacks?: GithubCallbackListRelationFilter
  }, "id">

  export type PluginOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
    template?: SortOrder
    gitRepo?: SortOrderInput | SortOrder
    pricingModel?: SortOrder
    oneTimePrice?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrderInput | SortOrder
    usagePrice?: SortOrderInput | SortOrder
    whiteLabel?: SortOrder
    isPublished?: SortOrder
    isActive?: SortOrder
    deploymentStatus?: SortOrder
    deploymentUrl?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    totalInstalls?: SortOrder
    monthlyActiveUsers?: SortOrder
    totalRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: PluginCountOrderByAggregateInput
    _avg?: PluginAvgOrderByAggregateInput
    _max?: PluginMaxOrderByAggregateInput
    _min?: PluginMinOrderByAggregateInput
    _sum?: PluginSumOrderByAggregateInput
  }

  export type PluginScalarWhereWithAggregatesInput = {
    AND?: PluginScalarWhereWithAggregatesInput | PluginScalarWhereWithAggregatesInput[]
    OR?: PluginScalarWhereWithAggregatesInput[]
    NOT?: PluginScalarWhereWithAggregatesInput | PluginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plugin"> | string
    creatorId?: StringWithAggregatesFilter<"Plugin"> | string
    name?: StringWithAggregatesFilter<"Plugin"> | string
    description?: StringWithAggregatesFilter<"Plugin"> | string
    category?: EnumPluginCategoryWithAggregatesFilter<"Plugin"> | $Enums.PluginCategory
    templateId?: StringWithAggregatesFilter<"Plugin"> | string
    template?: JsonWithAggregatesFilter<"Plugin">
    gitRepo?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    pricingModel?: EnumPricingModelWithAggregatesFilter<"Plugin"> | $Enums.PricingModel
    oneTimePrice?: FloatNullableWithAggregatesFilter<"Plugin"> | number | null
    subscriptionTier?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    usagePrice?: FloatNullableWithAggregatesFilter<"Plugin"> | number | null
    whiteLabel?: BoolWithAggregatesFilter<"Plugin"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Plugin"> | boolean
    isActive?: BoolWithAggregatesFilter<"Plugin"> | boolean
    deploymentStatus?: EnumDeploymentStatusWithAggregatesFilter<"Plugin"> | $Enums.DeploymentStatus
    deploymentUrl?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    apiEndpoint?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    totalInstalls?: IntWithAggregatesFilter<"Plugin"> | number
    monthlyActiveUsers?: IntWithAggregatesFilter<"Plugin"> | number
    totalRevenue?: FloatWithAggregatesFilter<"Plugin"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plugin"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Plugin"> | Date | string | null
  }

  export type PluginPurchaseWhereInput = {
    AND?: PluginPurchaseWhereInput | PluginPurchaseWhereInput[]
    OR?: PluginPurchaseWhereInput[]
    NOT?: PluginPurchaseWhereInput | PluginPurchaseWhereInput[]
    id?: StringFilter<"PluginPurchase"> | string
    customerId?: StringFilter<"PluginPurchase"> | string
    pluginId?: StringFilter<"PluginPurchase"> | string
    purchaseType?: EnumPurchaseTypeFilter<"PluginPurchase"> | $Enums.PurchaseType
    amount?: FloatFilter<"PluginPurchase"> | number
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"PluginPurchase"> | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    isActive?: BoolFilter<"PluginPurchase"> | boolean
    apiKey?: StringNullableFilter<"PluginPurchase"> | string | null
    usageLimit?: IntNullableFilter<"PluginPurchase"> | number | null
    usageCount?: IntFilter<"PluginPurchase"> | number
    purchasedAt?: DateTimeFilter<"PluginPurchase"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plugin?: XOR<PluginScalarRelationFilter, PluginWhereInput>
    usageRecords?: PluginUsageListRelationFilter
  }

  export type PluginPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    pluginId?: SortOrder
    purchaseType?: SortOrder
    amount?: SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionStartDate?: SortOrderInput | SortOrder
    subscriptionEndDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    purchasedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    plugin?: PluginOrderByWithRelationInput
    usageRecords?: PluginUsageOrderByRelationAggregateInput
  }

  export type PluginPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apiKey?: string
    customerId_pluginId?: PluginPurchaseCustomerIdPluginIdCompoundUniqueInput
    AND?: PluginPurchaseWhereInput | PluginPurchaseWhereInput[]
    OR?: PluginPurchaseWhereInput[]
    NOT?: PluginPurchaseWhereInput | PluginPurchaseWhereInput[]
    customerId?: StringFilter<"PluginPurchase"> | string
    pluginId?: StringFilter<"PluginPurchase"> | string
    purchaseType?: EnumPurchaseTypeFilter<"PluginPurchase"> | $Enums.PurchaseType
    amount?: FloatFilter<"PluginPurchase"> | number
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"PluginPurchase"> | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    isActive?: BoolFilter<"PluginPurchase"> | boolean
    usageLimit?: IntNullableFilter<"PluginPurchase"> | number | null
    usageCount?: IntFilter<"PluginPurchase"> | number
    purchasedAt?: DateTimeFilter<"PluginPurchase"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plugin?: XOR<PluginScalarRelationFilter, PluginWhereInput>
    usageRecords?: PluginUsageListRelationFilter
  }, "id" | "apiKey" | "customerId_pluginId">

  export type PluginPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    pluginId?: SortOrder
    purchaseType?: SortOrder
    amount?: SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    subscriptionStartDate?: SortOrderInput | SortOrder
    subscriptionEndDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    purchasedAt?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    _count?: PluginPurchaseCountOrderByAggregateInput
    _avg?: PluginPurchaseAvgOrderByAggregateInput
    _max?: PluginPurchaseMaxOrderByAggregateInput
    _min?: PluginPurchaseMinOrderByAggregateInput
    _sum?: PluginPurchaseSumOrderByAggregateInput
  }

  export type PluginPurchaseScalarWhereWithAggregatesInput = {
    AND?: PluginPurchaseScalarWhereWithAggregatesInput | PluginPurchaseScalarWhereWithAggregatesInput[]
    OR?: PluginPurchaseScalarWhereWithAggregatesInput[]
    NOT?: PluginPurchaseScalarWhereWithAggregatesInput | PluginPurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PluginPurchase"> | string
    customerId?: StringWithAggregatesFilter<"PluginPurchase"> | string
    pluginId?: StringWithAggregatesFilter<"PluginPurchase"> | string
    purchaseType?: EnumPurchaseTypeWithAggregatesFilter<"PluginPurchase"> | $Enums.PurchaseType
    amount?: FloatWithAggregatesFilter<"PluginPurchase"> | number
    subscriptionStatus?: EnumSubscriptionStatusNullableWithAggregatesFilter<"PluginPurchase"> | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: DateTimeNullableWithAggregatesFilter<"PluginPurchase"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableWithAggregatesFilter<"PluginPurchase"> | Date | string | null
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"PluginPurchase"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"PluginPurchase"> | boolean
    apiKey?: StringNullableWithAggregatesFilter<"PluginPurchase"> | string | null
    usageLimit?: IntNullableWithAggregatesFilter<"PluginPurchase"> | number | null
    usageCount?: IntWithAggregatesFilter<"PluginPurchase"> | number
    purchasedAt?: DateTimeWithAggregatesFilter<"PluginPurchase"> | Date | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"PluginPurchase"> | Date | string | null
  }

  export type PluginUsageWhereInput = {
    AND?: PluginUsageWhereInput | PluginUsageWhereInput[]
    OR?: PluginUsageWhereInput[]
    NOT?: PluginUsageWhereInput | PluginUsageWhereInput[]
    id?: StringFilter<"PluginUsage"> | string
    purchaseId?: StringFilter<"PluginUsage"> | string
    pluginId?: StringFilter<"PluginUsage"> | string
    endpoint?: StringFilter<"PluginUsage"> | string
    method?: StringFilter<"PluginUsage"> | string
    statusCode?: IntFilter<"PluginUsage"> | number
    responseTime?: IntFilter<"PluginUsage"> | number
    requestSize?: IntNullableFilter<"PluginUsage"> | number | null
    responseSize?: IntNullableFilter<"PluginUsage"> | number | null
    userAgent?: StringNullableFilter<"PluginUsage"> | string | null
    ipAddress?: StringNullableFilter<"PluginUsage"> | string | null
    timestamp?: DateTimeFilter<"PluginUsage"> | Date | string
    purchase?: XOR<PluginPurchaseScalarRelationFilter, PluginPurchaseWhereInput>
    plugin?: XOR<PluginScalarRelationFilter, PluginWhereInput>
  }

  export type PluginUsageOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    pluginId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestSize?: SortOrderInput | SortOrder
    responseSize?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    purchase?: PluginPurchaseOrderByWithRelationInput
    plugin?: PluginOrderByWithRelationInput
  }

  export type PluginUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PluginUsageWhereInput | PluginUsageWhereInput[]
    OR?: PluginUsageWhereInput[]
    NOT?: PluginUsageWhereInput | PluginUsageWhereInput[]
    purchaseId?: StringFilter<"PluginUsage"> | string
    pluginId?: StringFilter<"PluginUsage"> | string
    endpoint?: StringFilter<"PluginUsage"> | string
    method?: StringFilter<"PluginUsage"> | string
    statusCode?: IntFilter<"PluginUsage"> | number
    responseTime?: IntFilter<"PluginUsage"> | number
    requestSize?: IntNullableFilter<"PluginUsage"> | number | null
    responseSize?: IntNullableFilter<"PluginUsage"> | number | null
    userAgent?: StringNullableFilter<"PluginUsage"> | string | null
    ipAddress?: StringNullableFilter<"PluginUsage"> | string | null
    timestamp?: DateTimeFilter<"PluginUsage"> | Date | string
    purchase?: XOR<PluginPurchaseScalarRelationFilter, PluginPurchaseWhereInput>
    plugin?: XOR<PluginScalarRelationFilter, PluginWhereInput>
  }, "id">

  export type PluginUsageOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    pluginId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestSize?: SortOrderInput | SortOrder
    responseSize?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: PluginUsageCountOrderByAggregateInput
    _avg?: PluginUsageAvgOrderByAggregateInput
    _max?: PluginUsageMaxOrderByAggregateInput
    _min?: PluginUsageMinOrderByAggregateInput
    _sum?: PluginUsageSumOrderByAggregateInput
  }

  export type PluginUsageScalarWhereWithAggregatesInput = {
    AND?: PluginUsageScalarWhereWithAggregatesInput | PluginUsageScalarWhereWithAggregatesInput[]
    OR?: PluginUsageScalarWhereWithAggregatesInput[]
    NOT?: PluginUsageScalarWhereWithAggregatesInput | PluginUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PluginUsage"> | string
    purchaseId?: StringWithAggregatesFilter<"PluginUsage"> | string
    pluginId?: StringWithAggregatesFilter<"PluginUsage"> | string
    endpoint?: StringWithAggregatesFilter<"PluginUsage"> | string
    method?: StringWithAggregatesFilter<"PluginUsage"> | string
    statusCode?: IntWithAggregatesFilter<"PluginUsage"> | number
    responseTime?: IntWithAggregatesFilter<"PluginUsage"> | number
    requestSize?: IntNullableWithAggregatesFilter<"PluginUsage"> | number | null
    responseSize?: IntNullableWithAggregatesFilter<"PluginUsage"> | number | null
    userAgent?: StringNullableWithAggregatesFilter<"PluginUsage"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PluginUsage"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"PluginUsage"> | Date | string
  }

  export type UserAdministratorWhereInput = {
    AND?: UserAdministratorWhereInput | UserAdministratorWhereInput[]
    OR?: UserAdministratorWhereInput[]
    NOT?: UserAdministratorWhereInput | UserAdministratorWhereInput[]
    id?: StringFilter<"UserAdministrator"> | string
    userId?: StringFilter<"UserAdministrator"> | string
    locationId?: StringFilter<"UserAdministrator"> | string
    canViewFinancials?: BoolFilter<"UserAdministrator"> | boolean
    canManageStaff?: BoolFilter<"UserAdministrator"> | boolean
    canEditAppointments?: BoolFilter<"UserAdministrator"> | boolean
    canViewReports?: BoolFilter<"UserAdministrator"> | boolean
    assignedAt?: DateTimeFilter<"UserAdministrator"> | Date | string
    assignedBy?: StringNullableFilter<"UserAdministrator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type UserAdministratorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    canViewFinancials?: SortOrder
    canManageStaff?: SortOrder
    canEditAppointments?: SortOrder
    canViewReports?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type UserAdministratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_locationId?: UserAdministratorUserIdLocationIdCompoundUniqueInput
    AND?: UserAdministratorWhereInput | UserAdministratorWhereInput[]
    OR?: UserAdministratorWhereInput[]
    NOT?: UserAdministratorWhereInput | UserAdministratorWhereInput[]
    userId?: StringFilter<"UserAdministrator"> | string
    locationId?: StringFilter<"UserAdministrator"> | string
    canViewFinancials?: BoolFilter<"UserAdministrator"> | boolean
    canManageStaff?: BoolFilter<"UserAdministrator"> | boolean
    canEditAppointments?: BoolFilter<"UserAdministrator"> | boolean
    canViewReports?: BoolFilter<"UserAdministrator"> | boolean
    assignedAt?: DateTimeFilter<"UserAdministrator"> | Date | string
    assignedBy?: StringNullableFilter<"UserAdministrator"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "userId_locationId">

  export type UserAdministratorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    canViewFinancials?: SortOrder
    canManageStaff?: SortOrder
    canEditAppointments?: SortOrder
    canViewReports?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    _count?: UserAdministratorCountOrderByAggregateInput
    _max?: UserAdministratorMaxOrderByAggregateInput
    _min?: UserAdministratorMinOrderByAggregateInput
  }

  export type UserAdministratorScalarWhereWithAggregatesInput = {
    AND?: UserAdministratorScalarWhereWithAggregatesInput | UserAdministratorScalarWhereWithAggregatesInput[]
    OR?: UserAdministratorScalarWhereWithAggregatesInput[]
    NOT?: UserAdministratorScalarWhereWithAggregatesInput | UserAdministratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAdministrator"> | string
    userId?: StringWithAggregatesFilter<"UserAdministrator"> | string
    locationId?: StringWithAggregatesFilter<"UserAdministrator"> | string
    canViewFinancials?: BoolWithAggregatesFilter<"UserAdministrator"> | boolean
    canManageStaff?: BoolWithAggregatesFilter<"UserAdministrator"> | boolean
    canEditAppointments?: BoolWithAggregatesFilter<"UserAdministrator"> | boolean
    canViewReports?: BoolWithAggregatesFilter<"UserAdministrator"> | boolean
    assignedAt?: DateTimeWithAggregatesFilter<"UserAdministrator"> | Date | string
    assignedBy?: StringNullableWithAggregatesFilter<"UserAdministrator"> | string | null
  }

  export type TerritoryWhereInput = {
    AND?: TerritoryWhereInput | TerritoryWhereInput[]
    OR?: TerritoryWhereInput[]
    NOT?: TerritoryWhereInput | TerritoryWhereInput[]
    id?: StringFilter<"Territory"> | string
    locationId?: StringFilter<"Territory"> | string
    territoryCode?: StringFilter<"Territory"> | string
    territoryName?: StringFilter<"Territory"> | string
    territoryAddress?: StringNullableFilter<"Territory"> | string | null
    territoryCity?: StringNullableFilter<"Territory"> | string | null
    territoryState?: StringNullableFilter<"Territory"> | string | null
    territoryZipCode?: StringNullableFilter<"Territory"> | string | null
    territoryPhone?: StringNullableFilter<"Territory"> | string | null
    territoryEmail?: StringNullableFilter<"Territory"> | string | null
    exclusiveRadius?: FloatNullableFilter<"Territory"> | number | null
    populationServed?: IntNullableFilter<"Territory"> | number | null
    marketPenetration?: FloatNullableFilter<"Territory"> | number | null
    assignedAt?: DateTimeFilter<"Territory"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type TerritoryOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    territoryAddress?: SortOrderInput | SortOrder
    territoryCity?: SortOrderInput | SortOrder
    territoryState?: SortOrderInput | SortOrder
    territoryZipCode?: SortOrderInput | SortOrder
    territoryPhone?: SortOrderInput | SortOrder
    territoryEmail?: SortOrderInput | SortOrder
    exclusiveRadius?: SortOrderInput | SortOrder
    populationServed?: SortOrderInput | SortOrder
    marketPenetration?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
  }

  export type TerritoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    territoryCode?: string
    AND?: TerritoryWhereInput | TerritoryWhereInput[]
    OR?: TerritoryWhereInput[]
    NOT?: TerritoryWhereInput | TerritoryWhereInput[]
    territoryName?: StringFilter<"Territory"> | string
    territoryAddress?: StringNullableFilter<"Territory"> | string | null
    territoryCity?: StringNullableFilter<"Territory"> | string | null
    territoryState?: StringNullableFilter<"Territory"> | string | null
    territoryZipCode?: StringNullableFilter<"Territory"> | string | null
    territoryPhone?: StringNullableFilter<"Territory"> | string | null
    territoryEmail?: StringNullableFilter<"Territory"> | string | null
    exclusiveRadius?: FloatNullableFilter<"Territory"> | number | null
    populationServed?: IntNullableFilter<"Territory"> | number | null
    marketPenetration?: FloatNullableFilter<"Territory"> | number | null
    assignedAt?: DateTimeFilter<"Territory"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "locationId" | "territoryCode">

  export type TerritoryOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    territoryAddress?: SortOrderInput | SortOrder
    territoryCity?: SortOrderInput | SortOrder
    territoryState?: SortOrderInput | SortOrder
    territoryZipCode?: SortOrderInput | SortOrder
    territoryPhone?: SortOrderInput | SortOrder
    territoryEmail?: SortOrderInput | SortOrder
    exclusiveRadius?: SortOrderInput | SortOrder
    populationServed?: SortOrderInput | SortOrder
    marketPenetration?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    _count?: TerritoryCountOrderByAggregateInput
    _avg?: TerritoryAvgOrderByAggregateInput
    _max?: TerritoryMaxOrderByAggregateInput
    _min?: TerritoryMinOrderByAggregateInput
    _sum?: TerritorySumOrderByAggregateInput
  }

  export type TerritoryScalarWhereWithAggregatesInput = {
    AND?: TerritoryScalarWhereWithAggregatesInput | TerritoryScalarWhereWithAggregatesInput[]
    OR?: TerritoryScalarWhereWithAggregatesInput[]
    NOT?: TerritoryScalarWhereWithAggregatesInput | TerritoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Territory"> | string
    locationId?: StringWithAggregatesFilter<"Territory"> | string
    territoryCode?: StringWithAggregatesFilter<"Territory"> | string
    territoryName?: StringWithAggregatesFilter<"Territory"> | string
    territoryAddress?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    territoryCity?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    territoryState?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    territoryZipCode?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    territoryPhone?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    territoryEmail?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    exclusiveRadius?: FloatNullableWithAggregatesFilter<"Territory"> | number | null
    populationServed?: IntNullableWithAggregatesFilter<"Territory"> | number | null
    marketPenetration?: FloatNullableWithAggregatesFilter<"Territory"> | number | null
    assignedAt?: DateTimeWithAggregatesFilter<"Territory"> | Date | string
  }

  export type CSIWhereInput = {
    AND?: CSIWhereInput | CSIWhereInput[]
    OR?: CSIWhereInput[]
    NOT?: CSIWhereInput | CSIWhereInput[]
    id?: StringFilter<"CSI"> | string
    locationId?: StringFilter<"CSI"> | string
    score?: IntFilter<"CSI"> | number
    comment?: StringNullableFilter<"CSI"> | string | null
    source?: EnumCSISourceFilter<"CSI"> | $Enums.CSISource
    surveyType?: StringNullableFilter<"CSI"> | string | null
    customerId?: StringNullableFilter<"CSI"> | string | null
    recordedAt?: DateTimeFilter<"CSI"> | Date | string
    recordedBy?: StringNullableFilter<"CSI"> | string | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type CSIOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    score?: SortOrder
    comment?: SortOrderInput | SortOrder
    source?: SortOrder
    surveyType?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    recordedBy?: SortOrderInput | SortOrder
    location?: LocationOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type CSIWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CSIWhereInput | CSIWhereInput[]
    OR?: CSIWhereInput[]
    NOT?: CSIWhereInput | CSIWhereInput[]
    locationId?: StringFilter<"CSI"> | string
    score?: IntFilter<"CSI"> | number
    comment?: StringNullableFilter<"CSI"> | string | null
    source?: EnumCSISourceFilter<"CSI"> | $Enums.CSISource
    surveyType?: StringNullableFilter<"CSI"> | string | null
    customerId?: StringNullableFilter<"CSI"> | string | null
    recordedAt?: DateTimeFilter<"CSI"> | Date | string
    recordedBy?: StringNullableFilter<"CSI"> | string | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type CSIOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    score?: SortOrder
    comment?: SortOrderInput | SortOrder
    source?: SortOrder
    surveyType?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    recordedBy?: SortOrderInput | SortOrder
    _count?: CSICountOrderByAggregateInput
    _avg?: CSIAvgOrderByAggregateInput
    _max?: CSIMaxOrderByAggregateInput
    _min?: CSIMinOrderByAggregateInput
    _sum?: CSISumOrderByAggregateInput
  }

  export type CSIScalarWhereWithAggregatesInput = {
    AND?: CSIScalarWhereWithAggregatesInput | CSIScalarWhereWithAggregatesInput[]
    OR?: CSIScalarWhereWithAggregatesInput[]
    NOT?: CSIScalarWhereWithAggregatesInput | CSIScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CSI"> | string
    locationId?: StringWithAggregatesFilter<"CSI"> | string
    score?: IntWithAggregatesFilter<"CSI"> | number
    comment?: StringNullableWithAggregatesFilter<"CSI"> | string | null
    source?: EnumCSISourceWithAggregatesFilter<"CSI"> | $Enums.CSISource
    surveyType?: StringNullableWithAggregatesFilter<"CSI"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"CSI"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"CSI"> | Date | string
    recordedBy?: StringNullableWithAggregatesFilter<"CSI"> | string | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    city?: StringFilter<"Location"> | string
    state?: StringFilter<"Location"> | string
    zipCode?: StringFilter<"Location"> | string
    phone?: StringFilter<"Location"> | string
    email?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    franchiseId?: StringNullableFilter<"Location"> | string | null
    ownerId?: StringNullableFilter<"Location"> | string | null
    franchiseFeeRate?: FloatNullableFilter<"Location"> | number | null
    royaltyRate?: FloatNullableFilter<"Location"> | number | null
    timezone?: StringFilter<"Location"> | string
    businessHours?: JsonNullableFilter<"Location">
    currentCSIAverage?: FloatNullableFilter<"Location"> | number | null
    lastCSIUpdate?: DateTimeNullableFilter<"Location"> | Date | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    territory?: XOR<TerritoryNullableScalarRelationFilter, TerritoryWhereInput> | null
    csiRecords?: CSIListRelationFilter
    adminUsers?: UserAdministratorListRelationFilter
    customers?: CustomerListRelationFilter
    appointments?: AppointmentListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
    franchiseFees?: FranchiseFeeListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    franchiseId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    franchiseFeeRate?: SortOrderInput | SortOrder
    royaltyRate?: SortOrderInput | SortOrder
    timezone?: SortOrder
    businessHours?: SortOrderInput | SortOrder
    currentCSIAverage?: SortOrderInput | SortOrder
    lastCSIUpdate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    territory?: TerritoryOrderByWithRelationInput
    csiRecords?: CSIOrderByRelationAggregateInput
    adminUsers?: UserAdministratorOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    franchiseFees?: FranchiseFeeOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    city?: StringFilter<"Location"> | string
    state?: StringFilter<"Location"> | string
    zipCode?: StringFilter<"Location"> | string
    phone?: StringFilter<"Location"> | string
    email?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    franchiseId?: StringNullableFilter<"Location"> | string | null
    ownerId?: StringNullableFilter<"Location"> | string | null
    franchiseFeeRate?: FloatNullableFilter<"Location"> | number | null
    royaltyRate?: FloatNullableFilter<"Location"> | number | null
    timezone?: StringFilter<"Location"> | string
    businessHours?: JsonNullableFilter<"Location">
    currentCSIAverage?: FloatNullableFilter<"Location"> | number | null
    lastCSIUpdate?: DateTimeNullableFilter<"Location"> | Date | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    territory?: XOR<TerritoryNullableScalarRelationFilter, TerritoryWhereInput> | null
    csiRecords?: CSIListRelationFilter
    adminUsers?: UserAdministratorListRelationFilter
    customers?: CustomerListRelationFilter
    appointments?: AppointmentListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
    franchiseFees?: FranchiseFeeListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    franchiseId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    franchiseFeeRate?: SortOrderInput | SortOrder
    royaltyRate?: SortOrderInput | SortOrder
    timezone?: SortOrder
    businessHours?: SortOrderInput | SortOrder
    currentCSIAverage?: SortOrderInput | SortOrder
    lastCSIUpdate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringWithAggregatesFilter<"Location"> | string
    city?: StringWithAggregatesFilter<"Location"> | string
    state?: StringWithAggregatesFilter<"Location"> | string
    zipCode?: StringWithAggregatesFilter<"Location"> | string
    phone?: StringWithAggregatesFilter<"Location"> | string
    email?: StringWithAggregatesFilter<"Location"> | string
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    franchiseId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    franchiseFeeRate?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    royaltyRate?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    timezone?: StringWithAggregatesFilter<"Location"> | string
    businessHours?: JsonNullableWithAggregatesFilter<"Location">
    currentCSIAverage?: FloatNullableWithAggregatesFilter<"Location"> | number | null
    lastCSIUpdate?: DateTimeNullableWithAggregatesFilter<"Location"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type TerritoriesAvailableWhereInput = {
    AND?: TerritoriesAvailableWhereInput | TerritoriesAvailableWhereInput[]
    OR?: TerritoriesAvailableWhereInput[]
    NOT?: TerritoriesAvailableWhereInput | TerritoriesAvailableWhereInput[]
    id?: StringFilter<"TerritoriesAvailable"> | string
    territoryCode?: StringFilter<"TerritoriesAvailable"> | string
    territoryName?: StringFilter<"TerritoriesAvailable"> | string
    state?: StringFilter<"TerritoriesAvailable"> | string
    city?: StringNullableFilter<"TerritoriesAvailable"> | string | null
    zipCodes?: StringNullableListFilter<"TerritoriesAvailable">
    county?: StringNullableFilter<"TerritoriesAvailable"> | string | null
    estimatedPopulation?: IntNullableFilter<"TerritoriesAvailable"> | number | null
    averageIncome?: FloatNullableFilter<"TerritoriesAvailable"> | number | null
    competitorCount?: IntNullableFilter<"TerritoriesAvailable"> | number | null
    marketPotential?: StringNullableFilter<"TerritoriesAvailable"> | string | null
    franchiseFee?: FloatFilter<"TerritoriesAvailable"> | number
    minimumInvestment?: FloatNullableFilter<"TerritoriesAvailable"> | number | null
    exclusiveRadius?: FloatNullableFilter<"TerritoriesAvailable"> | number | null
    isAvailable?: BoolFilter<"TerritoriesAvailable"> | boolean
    reservedUntil?: DateTimeNullableFilter<"TerritoriesAvailable"> | Date | string | null
    createdAt?: DateTimeFilter<"TerritoriesAvailable"> | Date | string
    updatedAt?: DateTimeFilter<"TerritoriesAvailable"> | Date | string
  }

  export type TerritoriesAvailableOrderByWithRelationInput = {
    id?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    state?: SortOrder
    city?: SortOrderInput | SortOrder
    zipCodes?: SortOrder
    county?: SortOrderInput | SortOrder
    estimatedPopulation?: SortOrderInput | SortOrder
    averageIncome?: SortOrderInput | SortOrder
    competitorCount?: SortOrderInput | SortOrder
    marketPotential?: SortOrderInput | SortOrder
    franchiseFee?: SortOrder
    minimumInvestment?: SortOrderInput | SortOrder
    exclusiveRadius?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    reservedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerritoriesAvailableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    territoryCode?: string
    AND?: TerritoriesAvailableWhereInput | TerritoriesAvailableWhereInput[]
    OR?: TerritoriesAvailableWhereInput[]
    NOT?: TerritoriesAvailableWhereInput | TerritoriesAvailableWhereInput[]
    territoryName?: StringFilter<"TerritoriesAvailable"> | string
    state?: StringFilter<"TerritoriesAvailable"> | string
    city?: StringNullableFilter<"TerritoriesAvailable"> | string | null
    zipCodes?: StringNullableListFilter<"TerritoriesAvailable">
    county?: StringNullableFilter<"TerritoriesAvailable"> | string | null
    estimatedPopulation?: IntNullableFilter<"TerritoriesAvailable"> | number | null
    averageIncome?: FloatNullableFilter<"TerritoriesAvailable"> | number | null
    competitorCount?: IntNullableFilter<"TerritoriesAvailable"> | number | null
    marketPotential?: StringNullableFilter<"TerritoriesAvailable"> | string | null
    franchiseFee?: FloatFilter<"TerritoriesAvailable"> | number
    minimumInvestment?: FloatNullableFilter<"TerritoriesAvailable"> | number | null
    exclusiveRadius?: FloatNullableFilter<"TerritoriesAvailable"> | number | null
    isAvailable?: BoolFilter<"TerritoriesAvailable"> | boolean
    reservedUntil?: DateTimeNullableFilter<"TerritoriesAvailable"> | Date | string | null
    createdAt?: DateTimeFilter<"TerritoriesAvailable"> | Date | string
    updatedAt?: DateTimeFilter<"TerritoriesAvailable"> | Date | string
  }, "id" | "territoryCode">

  export type TerritoriesAvailableOrderByWithAggregationInput = {
    id?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    state?: SortOrder
    city?: SortOrderInput | SortOrder
    zipCodes?: SortOrder
    county?: SortOrderInput | SortOrder
    estimatedPopulation?: SortOrderInput | SortOrder
    averageIncome?: SortOrderInput | SortOrder
    competitorCount?: SortOrderInput | SortOrder
    marketPotential?: SortOrderInput | SortOrder
    franchiseFee?: SortOrder
    minimumInvestment?: SortOrderInput | SortOrder
    exclusiveRadius?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    reservedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TerritoriesAvailableCountOrderByAggregateInput
    _avg?: TerritoriesAvailableAvgOrderByAggregateInput
    _max?: TerritoriesAvailableMaxOrderByAggregateInput
    _min?: TerritoriesAvailableMinOrderByAggregateInput
    _sum?: TerritoriesAvailableSumOrderByAggregateInput
  }

  export type TerritoriesAvailableScalarWhereWithAggregatesInput = {
    AND?: TerritoriesAvailableScalarWhereWithAggregatesInput | TerritoriesAvailableScalarWhereWithAggregatesInput[]
    OR?: TerritoriesAvailableScalarWhereWithAggregatesInput[]
    NOT?: TerritoriesAvailableScalarWhereWithAggregatesInput | TerritoriesAvailableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TerritoriesAvailable"> | string
    territoryCode?: StringWithAggregatesFilter<"TerritoriesAvailable"> | string
    territoryName?: StringWithAggregatesFilter<"TerritoriesAvailable"> | string
    state?: StringWithAggregatesFilter<"TerritoriesAvailable"> | string
    city?: StringNullableWithAggregatesFilter<"TerritoriesAvailable"> | string | null
    zipCodes?: StringNullableListFilter<"TerritoriesAvailable">
    county?: StringNullableWithAggregatesFilter<"TerritoriesAvailable"> | string | null
    estimatedPopulation?: IntNullableWithAggregatesFilter<"TerritoriesAvailable"> | number | null
    averageIncome?: FloatNullableWithAggregatesFilter<"TerritoriesAvailable"> | number | null
    competitorCount?: IntNullableWithAggregatesFilter<"TerritoriesAvailable"> | number | null
    marketPotential?: StringNullableWithAggregatesFilter<"TerritoriesAvailable"> | string | null
    franchiseFee?: FloatWithAggregatesFilter<"TerritoriesAvailable"> | number
    minimumInvestment?: FloatNullableWithAggregatesFilter<"TerritoriesAvailable"> | number | null
    exclusiveRadius?: FloatNullableWithAggregatesFilter<"TerritoriesAvailable"> | number | null
    isAvailable?: BoolWithAggregatesFilter<"TerritoriesAvailable"> | boolean
    reservedUntil?: DateTimeNullableWithAggregatesFilter<"TerritoriesAvailable"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TerritoriesAvailable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TerritoriesAvailable"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    locationId?: StringNullableFilter<"Customer"> | string | null
    userId?: StringNullableFilter<"Customer"> | string | null
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    role?: EnumUserRoleFilter<"Customer"> | $Enums.UserRole
    dogName?: StringNullableFilter<"Customer"> | string | null
    dogBreed?: StringNullableFilter<"Customer"> | string | null
    dogAge?: IntNullableFilter<"Customer"> | number | null
    dogWeight?: FloatNullableFilter<"Customer"> | number | null
    allergies?: StringNullableFilter<"Customer"> | string | null
    preferredGroomer?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    squareCustomerId?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    userAccount?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    appointments?: AppointmentListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    orders?: OrderListRelationFilter
    csiRecords?: CSIListRelationFilter
    pluginPurchases?: PluginPurchaseListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    dogName?: SortOrderInput | SortOrder
    dogBreed?: SortOrderInput | SortOrder
    dogAge?: SortOrderInput | SortOrder
    dogWeight?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    preferredGroomer?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    squareCustomerId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    userAccount?: UserOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    csiRecords?: CSIOrderByRelationAggregateInput
    pluginPurchases?: PluginPurchaseOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    squareCustomerId?: string
    email_locationId?: CustomerEmailLocationIdCompoundUniqueInput
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    locationId?: StringNullableFilter<"Customer"> | string | null
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    role?: EnumUserRoleFilter<"Customer"> | $Enums.UserRole
    dogName?: StringNullableFilter<"Customer"> | string | null
    dogBreed?: StringNullableFilter<"Customer"> | string | null
    dogAge?: IntNullableFilter<"Customer"> | number | null
    dogWeight?: FloatNullableFilter<"Customer"> | number | null
    allergies?: StringNullableFilter<"Customer"> | string | null
    preferredGroomer?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    userAccount?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    appointments?: AppointmentListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    orders?: OrderListRelationFilter
    csiRecords?: CSIListRelationFilter
    pluginPurchases?: PluginPurchaseListRelationFilter
  }, "id" | "userId" | "squareCustomerId" | "email_locationId">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    dogName?: SortOrderInput | SortOrder
    dogBreed?: SortOrderInput | SortOrder
    dogAge?: SortOrderInput | SortOrder
    dogWeight?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    preferredGroomer?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    squareCustomerId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    locationId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    firstName?: StringWithAggregatesFilter<"Customer"> | string
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    role?: EnumUserRoleWithAggregatesFilter<"Customer"> | $Enums.UserRole
    dogName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    dogBreed?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    dogAge?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    dogWeight?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    allergies?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    preferredGroomer?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    squareCustomerId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type FranchiseFeeWhereInput = {
    AND?: FranchiseFeeWhereInput | FranchiseFeeWhereInput[]
    OR?: FranchiseFeeWhereInput[]
    NOT?: FranchiseFeeWhereInput | FranchiseFeeWhereInput[]
    id?: StringFilter<"FranchiseFee"> | string
    locationId?: StringFilter<"FranchiseFee"> | string
    month?: IntFilter<"FranchiseFee"> | number
    year?: IntFilter<"FranchiseFee"> | number
    serviceRevenue?: FloatFilter<"FranchiseFee"> | number
    productRevenue?: FloatFilter<"FranchiseFee"> | number
    subscriptionRevenue?: FloatFilter<"FranchiseFee"> | number
    totalRevenue?: FloatFilter<"FranchiseFee"> | number
    franchiseFee?: FloatFilter<"FranchiseFee"> | number
    royaltyFee?: FloatFilter<"FranchiseFee"> | number
    totalFees?: FloatFilter<"FranchiseFee"> | number
    isPaid?: BoolFilter<"FranchiseFee"> | boolean
    paidAt?: DateTimeNullableFilter<"FranchiseFee"> | Date | string | null
    dueDate?: DateTimeFilter<"FranchiseFee"> | Date | string
    createdAt?: DateTimeFilter<"FranchiseFee"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type FranchiseFeeOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    serviceRevenue?: SortOrder
    productRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    totalRevenue?: SortOrder
    franchiseFee?: SortOrder
    royaltyFee?: SortOrder
    totalFees?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    location?: LocationOrderByWithRelationInput
  }

  export type FranchiseFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId_month_year?: FranchiseFeeLocationIdMonthYearCompoundUniqueInput
    AND?: FranchiseFeeWhereInput | FranchiseFeeWhereInput[]
    OR?: FranchiseFeeWhereInput[]
    NOT?: FranchiseFeeWhereInput | FranchiseFeeWhereInput[]
    locationId?: StringFilter<"FranchiseFee"> | string
    month?: IntFilter<"FranchiseFee"> | number
    year?: IntFilter<"FranchiseFee"> | number
    serviceRevenue?: FloatFilter<"FranchiseFee"> | number
    productRevenue?: FloatFilter<"FranchiseFee"> | number
    subscriptionRevenue?: FloatFilter<"FranchiseFee"> | number
    totalRevenue?: FloatFilter<"FranchiseFee"> | number
    franchiseFee?: FloatFilter<"FranchiseFee"> | number
    royaltyFee?: FloatFilter<"FranchiseFee"> | number
    totalFees?: FloatFilter<"FranchiseFee"> | number
    isPaid?: BoolFilter<"FranchiseFee"> | boolean
    paidAt?: DateTimeNullableFilter<"FranchiseFee"> | Date | string | null
    dueDate?: DateTimeFilter<"FranchiseFee"> | Date | string
    createdAt?: DateTimeFilter<"FranchiseFee"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "locationId_month_year">

  export type FranchiseFeeOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    serviceRevenue?: SortOrder
    productRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    totalRevenue?: SortOrder
    franchiseFee?: SortOrder
    royaltyFee?: SortOrder
    totalFees?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    _count?: FranchiseFeeCountOrderByAggregateInput
    _avg?: FranchiseFeeAvgOrderByAggregateInput
    _max?: FranchiseFeeMaxOrderByAggregateInput
    _min?: FranchiseFeeMinOrderByAggregateInput
    _sum?: FranchiseFeeSumOrderByAggregateInput
  }

  export type FranchiseFeeScalarWhereWithAggregatesInput = {
    AND?: FranchiseFeeScalarWhereWithAggregatesInput | FranchiseFeeScalarWhereWithAggregatesInput[]
    OR?: FranchiseFeeScalarWhereWithAggregatesInput[]
    NOT?: FranchiseFeeScalarWhereWithAggregatesInput | FranchiseFeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FranchiseFee"> | string
    locationId?: StringWithAggregatesFilter<"FranchiseFee"> | string
    month?: IntWithAggregatesFilter<"FranchiseFee"> | number
    year?: IntWithAggregatesFilter<"FranchiseFee"> | number
    serviceRevenue?: FloatWithAggregatesFilter<"FranchiseFee"> | number
    productRevenue?: FloatWithAggregatesFilter<"FranchiseFee"> | number
    subscriptionRevenue?: FloatWithAggregatesFilter<"FranchiseFee"> | number
    totalRevenue?: FloatWithAggregatesFilter<"FranchiseFee"> | number
    franchiseFee?: FloatWithAggregatesFilter<"FranchiseFee"> | number
    royaltyFee?: FloatWithAggregatesFilter<"FranchiseFee"> | number
    totalFees?: FloatWithAggregatesFilter<"FranchiseFee"> | number
    isPaid?: BoolWithAggregatesFilter<"FranchiseFee"> | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter<"FranchiseFee"> | Date | string | null
    dueDate?: DateTimeWithAggregatesFilter<"FranchiseFee"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"FranchiseFee"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    locationId?: StringFilter<"Appointment"> | string
    customerId?: StringFilter<"Appointment"> | string
    serviceType?: StringFilter<"Appointment"> | string
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    duration?: IntFilter<"Appointment"> | number
    price?: FloatFilter<"Appointment"> | number
    notes?: StringNullableFilter<"Appointment"> | string | null
    assignedTo?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    completedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    squareOrderId?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    serviceType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    squareOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    squareOrderId?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    locationId?: StringFilter<"Appointment"> | string
    customerId?: StringFilter<"Appointment"> | string
    serviceType?: StringFilter<"Appointment"> | string
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    duration?: IntFilter<"Appointment"> | number
    price?: FloatFilter<"Appointment"> | number
    notes?: StringNullableFilter<"Appointment"> | string | null
    assignedTo?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    completedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "squareOrderId">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    serviceType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    squareOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    locationId?: StringWithAggregatesFilter<"Appointment"> | string
    customerId?: StringWithAggregatesFilter<"Appointment"> | string
    serviceType?: StringWithAggregatesFilter<"Appointment"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    duration?: IntWithAggregatesFilter<"Appointment"> | number
    price?: FloatWithAggregatesFilter<"Appointment"> | number
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    squareOrderId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    locationId?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    packageType?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    billingInterval?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    squareSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    packageType?: SortOrder
    price?: SortOrder
    billingInterval?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    squareSubscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    squareSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    locationId?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    packageType?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    billingInterval?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "squareSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    packageType?: SortOrder
    price?: SortOrder
    billingInterval?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    squareSubscriptionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    locationId?: StringWithAggregatesFilter<"Subscription"> | string
    customerId?: StringWithAggregatesFilter<"Subscription"> | string
    packageType?: StringWithAggregatesFilter<"Subscription"> | string
    price?: FloatWithAggregatesFilter<"Subscription"> | number
    billingInterval?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    squareSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    locationId?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    cost?: FloatNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    lowStockThreshold?: IntFilter<"Product"> | number
    squareItemId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    orderItems?: OrderItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    lowStockThreshold?: SortOrder
    squareItemId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    squareItemId?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    locationId?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    cost?: FloatNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    lowStockThreshold?: IntFilter<"Product"> | number
    imageUrl?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    orderItems?: OrderItemListRelationFilter
  }, "id" | "squareItemId">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrder
    cost?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    lowStockThreshold?: SortOrder
    squareItemId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    locationId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    cost?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    stockQuantity?: IntWithAggregatesFilter<"Product"> | number
    lowStockThreshold?: IntWithAggregatesFilter<"Product"> | number
    squareItemId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    fulfilledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    squareOrderId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: OrderItemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    fulfilledAt?: SortOrderInput | SortOrder
    squareOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    squareOrderId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    locationId?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    fulfilledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: OrderItemListRelationFilter
  }, "id" | "squareOrderId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    fulfilledAt?: SortOrderInput | SortOrder
    squareOrderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    locationId?: StringWithAggregatesFilter<"Order"> | string
    customerId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    subtotal?: FloatWithAggregatesFilter<"Order"> | number
    tax?: FloatWithAggregatesFilter<"Order"> | number
    total?: FloatWithAggregatesFilter<"Order"> | number
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    shippingAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    fulfilledAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    squareOrderId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    discount?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    discount?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    discount?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    discount?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    discount?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatWithAggregatesFilter<"OrderItem"> | number
  }

  export type GithubCallbackWhereInput = {
    AND?: GithubCallbackWhereInput | GithubCallbackWhereInput[]
    OR?: GithubCallbackWhereInput[]
    NOT?: GithubCallbackWhereInput | GithubCallbackWhereInput[]
    id?: StringFilter<"GithubCallback"> | string
    callbackId?: StringFilter<"GithubCallback"> | string
    streamUrl?: StringNullableFilter<"GithubCallback"> | string | null
    streamStatus?: StringNullableFilter<"GithubCallback"> | string | null
    data?: JsonNullableFilter<"GithubCallback">
    pluginId?: StringNullableFilter<"GithubCallback"> | string | null
    createdAt?: DateTimeFilter<"GithubCallback"> | Date | string
    updatedAt?: DateTimeFilter<"GithubCallback"> | Date | string
    plugin?: XOR<PluginNullableScalarRelationFilter, PluginWhereInput> | null
  }

  export type GithubCallbackOrderByWithRelationInput = {
    id?: SortOrder
    callbackId?: SortOrder
    streamUrl?: SortOrderInput | SortOrder
    streamStatus?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    pluginId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plugin?: PluginOrderByWithRelationInput
  }

  export type GithubCallbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    callbackId?: string
    AND?: GithubCallbackWhereInput | GithubCallbackWhereInput[]
    OR?: GithubCallbackWhereInput[]
    NOT?: GithubCallbackWhereInput | GithubCallbackWhereInput[]
    streamUrl?: StringNullableFilter<"GithubCallback"> | string | null
    streamStatus?: StringNullableFilter<"GithubCallback"> | string | null
    data?: JsonNullableFilter<"GithubCallback">
    pluginId?: StringNullableFilter<"GithubCallback"> | string | null
    createdAt?: DateTimeFilter<"GithubCallback"> | Date | string
    updatedAt?: DateTimeFilter<"GithubCallback"> | Date | string
    plugin?: XOR<PluginNullableScalarRelationFilter, PluginWhereInput> | null
  }, "id" | "callbackId">

  export type GithubCallbackOrderByWithAggregationInput = {
    id?: SortOrder
    callbackId?: SortOrder
    streamUrl?: SortOrderInput | SortOrder
    streamStatus?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    pluginId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GithubCallbackCountOrderByAggregateInput
    _max?: GithubCallbackMaxOrderByAggregateInput
    _min?: GithubCallbackMinOrderByAggregateInput
  }

  export type GithubCallbackScalarWhereWithAggregatesInput = {
    AND?: GithubCallbackScalarWhereWithAggregatesInput | GithubCallbackScalarWhereWithAggregatesInput[]
    OR?: GithubCallbackScalarWhereWithAggregatesInput[]
    NOT?: GithubCallbackScalarWhereWithAggregatesInput | GithubCallbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GithubCallback"> | string
    callbackId?: StringWithAggregatesFilter<"GithubCallback"> | string
    streamUrl?: StringNullableWithAggregatesFilter<"GithubCallback"> | string | null
    streamStatus?: StringNullableWithAggregatesFilter<"GithubCallback"> | string | null
    data?: JsonNullableWithAggregatesFilter<"GithubCallback">
    pluginId?: StringNullableWithAggregatesFilter<"GithubCallback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GithubCallback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GithubCallback"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationCreateNestedManyWithoutOwnerInput
    locationAccess?: UserAdministratorCreateNestedManyWithoutUserInput
    customerAccount?: CustomerCreateNestedOneWithoutUserAccountInput
    createdPlugins?: PluginCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationUncheckedCreateNestedManyWithoutOwnerInput
    locationAccess?: UserAdministratorUncheckedCreateNestedManyWithoutUserInput
    customerAccount?: CustomerUncheckedCreateNestedOneWithoutUserAccountInput
    createdPlugins?: PluginUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUpdateManyWithoutOwnerNestedInput
    locationAccess?: UserAdministratorUpdateManyWithoutUserNestedInput
    customerAccount?: CustomerUpdateOneWithoutUserAccountNestedInput
    createdPlugins?: PluginUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUncheckedUpdateManyWithoutOwnerNestedInput
    locationAccess?: UserAdministratorUncheckedUpdateManyWithoutUserNestedInput
    customerAccount?: CustomerUncheckedUpdateOneWithoutUserAccountNestedInput
    createdPlugins?: PluginUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PluginCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCreatedPluginsInput
    purchases?: PluginPurchaseCreateNestedManyWithoutPluginInput
    usageRecords?: PluginUsageCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackCreateNestedManyWithoutPluginInput
  }

  export type PluginUncheckedCreateInput = {
    id?: string
    creatorId: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    purchases?: PluginPurchaseUncheckedCreateNestedManyWithoutPluginInput
    usageRecords?: PluginUsageUncheckedCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackUncheckedCreateNestedManyWithoutPluginInput
  }

  export type PluginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedPluginsNestedInput
    purchases?: PluginPurchaseUpdateManyWithoutPluginNestedInput
    usageRecords?: PluginUsageUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchases?: PluginPurchaseUncheckedUpdateManyWithoutPluginNestedInput
    usageRecords?: PluginUsageUncheckedUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUncheckedUpdateManyWithoutPluginNestedInput
  }

  export type PluginCreateManyInput = {
    id?: string
    creatorId: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type PluginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginPurchaseCreateInput = {
    id?: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutPluginPurchasesInput
    plugin: PluginCreateNestedOneWithoutPurchasesInput
    usageRecords?: PluginUsageCreateNestedManyWithoutPurchaseInput
  }

  export type PluginPurchaseUncheckedCreateInput = {
    id?: string
    customerId: string
    pluginId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
    usageRecords?: PluginUsageUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PluginPurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutPluginPurchasesNestedInput
    plugin?: PluginUpdateOneRequiredWithoutPurchasesNestedInput
    usageRecords?: PluginUsageUpdateManyWithoutPurchaseNestedInput
  }

  export type PluginPurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageRecords?: PluginUsageUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PluginPurchaseCreateManyInput = {
    id?: string
    customerId: string
    pluginId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PluginPurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginPurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginUsageCreateInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
    purchase: PluginPurchaseCreateNestedOneWithoutUsageRecordsInput
    plugin: PluginCreateNestedOneWithoutUsageRecordsInput
  }

  export type PluginUsageUncheckedCreateInput = {
    id?: string
    purchaseId: string
    pluginId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type PluginUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PluginPurchaseUpdateOneRequiredWithoutUsageRecordsNestedInput
    plugin?: PluginUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type PluginUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginUsageCreateManyInput = {
    id?: string
    purchaseId: string
    pluginId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type PluginUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAdministratorCreateInput = {
    id?: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
    user: UserCreateNestedOneWithoutLocationAccessInput
    location: LocationCreateNestedOneWithoutAdminUsersInput
  }

  export type UserAdministratorUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserAdministratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutLocationAccessNestedInput
    location?: LocationUpdateOneRequiredWithoutAdminUsersNestedInput
  }

  export type UserAdministratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdministratorCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserAdministratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdministratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TerritoryCreateInput = {
    id?: string
    territoryCode: string
    territoryName: string
    territoryAddress?: string | null
    territoryCity?: string | null
    territoryState?: string | null
    territoryZipCode?: string | null
    territoryPhone?: string | null
    territoryEmail?: string | null
    exclusiveRadius?: number | null
    populationServed?: number | null
    marketPenetration?: number | null
    assignedAt?: Date | string
    location: LocationCreateNestedOneWithoutTerritoryInput
  }

  export type TerritoryUncheckedCreateInput = {
    id?: string
    locationId: string
    territoryCode: string
    territoryName: string
    territoryAddress?: string | null
    territoryCity?: string | null
    territoryState?: string | null
    territoryZipCode?: string | null
    territoryPhone?: string | null
    territoryEmail?: string | null
    exclusiveRadius?: number | null
    populationServed?: number | null
    marketPenetration?: number | null
    assignedAt?: Date | string
  }

  export type TerritoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    territoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    territoryCity?: NullableStringFieldUpdateOperationsInput | string | null
    territoryState?: NullableStringFieldUpdateOperationsInput | string | null
    territoryZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    territoryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    territoryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    populationServed?: NullableIntFieldUpdateOperationsInput | number | null
    marketPenetration?: NullableFloatFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    territoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    territoryCity?: NullableStringFieldUpdateOperationsInput | string | null
    territoryState?: NullableStringFieldUpdateOperationsInput | string | null
    territoryZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    territoryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    territoryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    populationServed?: NullableIntFieldUpdateOperationsInput | number | null
    marketPenetration?: NullableFloatFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryCreateManyInput = {
    id?: string
    locationId: string
    territoryCode: string
    territoryName: string
    territoryAddress?: string | null
    territoryCity?: string | null
    territoryState?: string | null
    territoryZipCode?: string | null
    territoryPhone?: string | null
    territoryEmail?: string | null
    exclusiveRadius?: number | null
    populationServed?: number | null
    marketPenetration?: number | null
    assignedAt?: Date | string
  }

  export type TerritoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    territoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    territoryCity?: NullableStringFieldUpdateOperationsInput | string | null
    territoryState?: NullableStringFieldUpdateOperationsInput | string | null
    territoryZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    territoryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    territoryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    populationServed?: NullableIntFieldUpdateOperationsInput | number | null
    marketPenetration?: NullableFloatFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    territoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    territoryCity?: NullableStringFieldUpdateOperationsInput | string | null
    territoryState?: NullableStringFieldUpdateOperationsInput | string | null
    territoryZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    territoryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    territoryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    populationServed?: NullableIntFieldUpdateOperationsInput | number | null
    marketPenetration?: NullableFloatFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CSICreateInput = {
    id?: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
    location: LocationCreateNestedOneWithoutCsiRecordsInput
    customer?: CustomerCreateNestedOneWithoutCsiRecordsInput
  }

  export type CSIUncheckedCreateInput = {
    id?: string
    locationId: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    customerId?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
  }

  export type CSIUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneRequiredWithoutCsiRecordsNestedInput
    customer?: CustomerUpdateOneWithoutCsiRecordsNestedInput
  }

  export type CSIUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CSICreateManyInput = {
    id?: string
    locationId: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    customerId?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
  }

  export type CSIUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CSIUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoriesAvailableCreateInput = {
    id?: string
    territoryCode: string
    territoryName: string
    state: string
    city?: string | null
    zipCodes?: TerritoriesAvailableCreatezipCodesInput | string[]
    county?: string | null
    estimatedPopulation?: number | null
    averageIncome?: number | null
    competitorCount?: number | null
    marketPotential?: string | null
    franchiseFee?: number
    minimumInvestment?: number | null
    exclusiveRadius?: number | null
    isAvailable?: boolean
    reservedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerritoriesAvailableUncheckedCreateInput = {
    id?: string
    territoryCode: string
    territoryName: string
    state: string
    city?: string | null
    zipCodes?: TerritoriesAvailableCreatezipCodesInput | string[]
    county?: string | null
    estimatedPopulation?: number | null
    averageIncome?: number | null
    competitorCount?: number | null
    marketPotential?: string | null
    franchiseFee?: number
    minimumInvestment?: number | null
    exclusiveRadius?: number | null
    isAvailable?: boolean
    reservedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerritoriesAvailableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipCodes?: TerritoriesAvailableUpdatezipCodesInput | string[]
    county?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPopulation?: NullableIntFieldUpdateOperationsInput | number | null
    averageIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    competitorCount?: NullableIntFieldUpdateOperationsInput | number | null
    marketPotential?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    minimumInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reservedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoriesAvailableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipCodes?: TerritoriesAvailableUpdatezipCodesInput | string[]
    county?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPopulation?: NullableIntFieldUpdateOperationsInput | number | null
    averageIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    competitorCount?: NullableIntFieldUpdateOperationsInput | number | null
    marketPotential?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    minimumInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reservedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoriesAvailableCreateManyInput = {
    id?: string
    territoryCode: string
    territoryName: string
    state: string
    city?: string | null
    zipCodes?: TerritoriesAvailableCreatezipCodesInput | string[]
    county?: string | null
    estimatedPopulation?: number | null
    averageIncome?: number | null
    competitorCount?: number | null
    marketPotential?: string | null
    franchiseFee?: number
    minimumInvestment?: number | null
    exclusiveRadius?: number | null
    isAvailable?: boolean
    reservedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerritoriesAvailableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipCodes?: TerritoriesAvailableUpdatezipCodesInput | string[]
    county?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPopulation?: NullableIntFieldUpdateOperationsInput | number | null
    averageIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    competitorCount?: NullableIntFieldUpdateOperationsInput | number | null
    marketPotential?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    minimumInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reservedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoriesAvailableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zipCodes?: TerritoriesAvailableUpdatezipCodesInput | string[]
    county?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPopulation?: NullableIntFieldUpdateOperationsInput | number | null
    averageIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    competitorCount?: NullableIntFieldUpdateOperationsInput | number | null
    marketPotential?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    minimumInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reservedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCustomersInput
    userAccount?: UserCreateNestedOneWithoutCustomerAccountInput
    appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    csiRecords?: CSICreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    locationId?: string | null
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCustomersNestedInput
    userAccount?: UserUpdateOneWithoutCustomerAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    locationId?: string | null
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseFeeCreateInput = {
    id?: string
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid?: boolean
    paidAt?: Date | string | null
    dueDate: Date | string
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutFranchiseFeesInput
  }

  export type FranchiseFeeUncheckedCreateInput = {
    id?: string
    locationId: string
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid?: boolean
    paidAt?: Date | string | null
    dueDate: Date | string
    createdAt?: Date | string
  }

  export type FranchiseFeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    productRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    royaltyFee?: FloatFieldUpdateOperationsInput | number
    totalFees?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutFranchiseFeesNestedInput
  }

  export type FranchiseFeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    productRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    royaltyFee?: FloatFieldUpdateOperationsInput | number
    totalFees?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseFeeCreateManyInput = {
    id?: string
    locationId: string
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid?: boolean
    paidAt?: Date | string | null
    dueDate: Date | string
    createdAt?: Date | string
  }

  export type FranchiseFeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    productRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    royaltyFee?: FloatFieldUpdateOperationsInput | number
    totalFees?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseFeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    productRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    royaltyFee?: FloatFieldUpdateOperationsInput | number
    totalFees?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutAppointmentsInput
    customer: CustomerCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    locationId: string
    customerId: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutAppointmentsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: string
    locationId: string
    customerId: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSubscriptionsInput
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    locationId: string
    customerId: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSubscriptionsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    locationId: string
    customerId: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    locationId?: string | null
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    locationId?: string | null
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    locationId: string
    customerId?: string | null
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    locationId: string
    customerId?: string | null
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    discount?: string | null
    quantity: number
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    discount?: string | null
    quantity: number
    price: number
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    discount?: string | null
    quantity: number
    price: number
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type GithubCallbackCreateInput = {
    id?: string
    callbackId: string
    streamUrl?: string | null
    streamStatus?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plugin?: PluginCreateNestedOneWithoutGithubCallbacksInput
  }

  export type GithubCallbackUncheckedCreateInput = {
    id?: string
    callbackId: string
    streamUrl?: string | null
    streamStatus?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    pluginId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GithubCallbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callbackId?: StringFieldUpdateOperationsInput | string
    streamUrl?: NullableStringFieldUpdateOperationsInput | string | null
    streamStatus?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plugin?: PluginUpdateOneWithoutGithubCallbacksNestedInput
  }

  export type GithubCallbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callbackId?: StringFieldUpdateOperationsInput | string
    streamUrl?: NullableStringFieldUpdateOperationsInput | string | null
    streamStatus?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    pluginId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GithubCallbackCreateManyInput = {
    id?: string
    callbackId: string
    streamUrl?: string | null
    streamStatus?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    pluginId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GithubCallbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    callbackId?: StringFieldUpdateOperationsInput | string
    streamUrl?: NullableStringFieldUpdateOperationsInput | string | null
    streamStatus?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GithubCallbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    callbackId?: StringFieldUpdateOperationsInput | string
    streamUrl?: NullableStringFieldUpdateOperationsInput | string | null
    streamStatus?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    pluginId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type UserAdministratorListRelationFilter = {
    every?: UserAdministratorWhereInput
    some?: UserAdministratorWhereInput
    none?: UserAdministratorWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type PluginListRelationFilter = {
    every?: PluginWhereInput
    some?: PluginWhereInput
    none?: PluginWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAdministratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PluginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasCustomerAccount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasCustomerAccount?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    clerkUserId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasCustomerAccount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPluginCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryFilter<$PrismaModel> | $Enums.PluginCategory
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumDeploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusFilter<$PrismaModel> | $Enums.DeploymentStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PluginPurchaseListRelationFilter = {
    every?: PluginPurchaseWhereInput
    some?: PluginPurchaseWhereInput
    none?: PluginPurchaseWhereInput
  }

  export type PluginUsageListRelationFilter = {
    every?: PluginUsageWhereInput
    some?: PluginUsageWhereInput
    none?: PluginUsageWhereInput
  }

  export type GithubCallbackListRelationFilter = {
    every?: GithubCallbackWhereInput
    some?: GithubCallbackWhereInput
    none?: GithubCallbackWhereInput
  }

  export type PluginPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PluginUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GithubCallbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PluginCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
    template?: SortOrder
    gitRepo?: SortOrder
    pricingModel?: SortOrder
    oneTimePrice?: SortOrder
    subscriptionTier?: SortOrder
    usagePrice?: SortOrder
    whiteLabel?: SortOrder
    isPublished?: SortOrder
    isActive?: SortOrder
    deploymentStatus?: SortOrder
    deploymentUrl?: SortOrder
    apiEndpoint?: SortOrder
    totalInstalls?: SortOrder
    monthlyActiveUsers?: SortOrder
    totalRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type PluginAvgOrderByAggregateInput = {
    oneTimePrice?: SortOrder
    usagePrice?: SortOrder
    totalInstalls?: SortOrder
    monthlyActiveUsers?: SortOrder
    totalRevenue?: SortOrder
  }

  export type PluginMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
    gitRepo?: SortOrder
    pricingModel?: SortOrder
    oneTimePrice?: SortOrder
    subscriptionTier?: SortOrder
    usagePrice?: SortOrder
    whiteLabel?: SortOrder
    isPublished?: SortOrder
    isActive?: SortOrder
    deploymentStatus?: SortOrder
    deploymentUrl?: SortOrder
    apiEndpoint?: SortOrder
    totalInstalls?: SortOrder
    monthlyActiveUsers?: SortOrder
    totalRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type PluginMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    templateId?: SortOrder
    gitRepo?: SortOrder
    pricingModel?: SortOrder
    oneTimePrice?: SortOrder
    subscriptionTier?: SortOrder
    usagePrice?: SortOrder
    whiteLabel?: SortOrder
    isPublished?: SortOrder
    isActive?: SortOrder
    deploymentStatus?: SortOrder
    deploymentUrl?: SortOrder
    apiEndpoint?: SortOrder
    totalInstalls?: SortOrder
    monthlyActiveUsers?: SortOrder
    totalRevenue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type PluginSumOrderByAggregateInput = {
    oneTimePrice?: SortOrder
    usagePrice?: SortOrder
    totalInstalls?: SortOrder
    monthlyActiveUsers?: SortOrder
    totalRevenue?: SortOrder
  }

  export type EnumPluginCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PluginCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPluginCategoryFilter<$PrismaModel>
    _max?: NestedEnumPluginCategoryFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDeploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumDeploymentStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPurchaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeFilter<$PrismaModel> | $Enums.PurchaseType
  }

  export type EnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type PluginScalarRelationFilter = {
    is?: PluginWhereInput
    isNot?: PluginWhereInput
  }

  export type PluginPurchaseCustomerIdPluginIdCompoundUniqueInput = {
    customerId: string
    pluginId: string
  }

  export type PluginPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    pluginId?: SortOrder
    purchaseType?: SortOrder
    amount?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
    nextBillingDate?: SortOrder
    isActive?: SortOrder
    apiKey?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    purchasedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PluginPurchaseAvgOrderByAggregateInput = {
    amount?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type PluginPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    pluginId?: SortOrder
    purchaseType?: SortOrder
    amount?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
    nextBillingDate?: SortOrder
    isActive?: SortOrder
    apiKey?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    purchasedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PluginPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    pluginId?: SortOrder
    purchaseType?: SortOrder
    amount?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
    nextBillingDate?: SortOrder
    isActive?: SortOrder
    apiKey?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    purchasedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PluginPurchaseSumOrderByAggregateInput = {
    amount?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type EnumPurchaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseTypeFilter<$PrismaModel>
    _max?: NestedEnumPurchaseTypeFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PluginPurchaseScalarRelationFilter = {
    is?: PluginPurchaseWhereInput
    isNot?: PluginPurchaseWhereInput
  }

  export type PluginUsageCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    pluginId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestSize?: SortOrder
    responseSize?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type PluginUsageAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestSize?: SortOrder
    responseSize?: SortOrder
  }

  export type PluginUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    pluginId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestSize?: SortOrder
    responseSize?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type PluginUsageMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    pluginId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestSize?: SortOrder
    responseSize?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type PluginUsageSumOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
    requestSize?: SortOrder
    responseSize?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type UserAdministratorUserIdLocationIdCompoundUniqueInput = {
    userId: string
    locationId: string
  }

  export type UserAdministratorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    canViewFinancials?: SortOrder
    canManageStaff?: SortOrder
    canEditAppointments?: SortOrder
    canViewReports?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserAdministratorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    canViewFinancials?: SortOrder
    canManageStaff?: SortOrder
    canEditAppointments?: SortOrder
    canViewReports?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserAdministratorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    canViewFinancials?: SortOrder
    canManageStaff?: SortOrder
    canEditAppointments?: SortOrder
    canViewReports?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type TerritoryCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    territoryAddress?: SortOrder
    territoryCity?: SortOrder
    territoryState?: SortOrder
    territoryZipCode?: SortOrder
    territoryPhone?: SortOrder
    territoryEmail?: SortOrder
    exclusiveRadius?: SortOrder
    populationServed?: SortOrder
    marketPenetration?: SortOrder
    assignedAt?: SortOrder
  }

  export type TerritoryAvgOrderByAggregateInput = {
    exclusiveRadius?: SortOrder
    populationServed?: SortOrder
    marketPenetration?: SortOrder
  }

  export type TerritoryMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    territoryAddress?: SortOrder
    territoryCity?: SortOrder
    territoryState?: SortOrder
    territoryZipCode?: SortOrder
    territoryPhone?: SortOrder
    territoryEmail?: SortOrder
    exclusiveRadius?: SortOrder
    populationServed?: SortOrder
    marketPenetration?: SortOrder
    assignedAt?: SortOrder
  }

  export type TerritoryMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    territoryAddress?: SortOrder
    territoryCity?: SortOrder
    territoryState?: SortOrder
    territoryZipCode?: SortOrder
    territoryPhone?: SortOrder
    territoryEmail?: SortOrder
    exclusiveRadius?: SortOrder
    populationServed?: SortOrder
    marketPenetration?: SortOrder
    assignedAt?: SortOrder
  }

  export type TerritorySumOrderByAggregateInput = {
    exclusiveRadius?: SortOrder
    populationServed?: SortOrder
    marketPenetration?: SortOrder
  }

  export type EnumCSISourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CSISource | EnumCSISourceFieldRefInput<$PrismaModel>
    in?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCSISourceFilter<$PrismaModel> | $Enums.CSISource
  }

  export type CSICountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    source?: SortOrder
    surveyType?: SortOrder
    customerId?: SortOrder
    recordedAt?: SortOrder
    recordedBy?: SortOrder
  }

  export type CSIAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CSIMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    source?: SortOrder
    surveyType?: SortOrder
    customerId?: SortOrder
    recordedAt?: SortOrder
    recordedBy?: SortOrder
  }

  export type CSIMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    source?: SortOrder
    surveyType?: SortOrder
    customerId?: SortOrder
    recordedAt?: SortOrder
    recordedBy?: SortOrder
  }

  export type CSISumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumCSISourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CSISource | EnumCSISourceFieldRefInput<$PrismaModel>
    in?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCSISourceWithAggregatesFilter<$PrismaModel> | $Enums.CSISource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCSISourceFilter<$PrismaModel>
    _max?: NestedEnumCSISourceFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TerritoryNullableScalarRelationFilter = {
    is?: TerritoryWhereInput | null
    isNot?: TerritoryWhereInput | null
  }

  export type CSIListRelationFilter = {
    every?: CSIWhereInput
    some?: CSIWhereInput
    none?: CSIWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type FranchiseFeeListRelationFilter = {
    every?: FranchiseFeeWhereInput
    some?: FranchiseFeeWhereInput
    none?: FranchiseFeeWhereInput
  }

  export type CSIOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FranchiseFeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    franchiseId?: SortOrder
    ownerId?: SortOrder
    franchiseFeeRate?: SortOrder
    royaltyRate?: SortOrder
    timezone?: SortOrder
    businessHours?: SortOrder
    currentCSIAverage?: SortOrder
    lastCSIUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    franchiseFeeRate?: SortOrder
    royaltyRate?: SortOrder
    currentCSIAverage?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    franchiseId?: SortOrder
    ownerId?: SortOrder
    franchiseFeeRate?: SortOrder
    royaltyRate?: SortOrder
    timezone?: SortOrder
    currentCSIAverage?: SortOrder
    lastCSIUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    franchiseId?: SortOrder
    ownerId?: SortOrder
    franchiseFeeRate?: SortOrder
    royaltyRate?: SortOrder
    timezone?: SortOrder
    currentCSIAverage?: SortOrder
    lastCSIUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    franchiseFeeRate?: SortOrder
    royaltyRate?: SortOrder
    currentCSIAverage?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TerritoriesAvailableCountOrderByAggregateInput = {
    id?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCodes?: SortOrder
    county?: SortOrder
    estimatedPopulation?: SortOrder
    averageIncome?: SortOrder
    competitorCount?: SortOrder
    marketPotential?: SortOrder
    franchiseFee?: SortOrder
    minimumInvestment?: SortOrder
    exclusiveRadius?: SortOrder
    isAvailable?: SortOrder
    reservedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerritoriesAvailableAvgOrderByAggregateInput = {
    estimatedPopulation?: SortOrder
    averageIncome?: SortOrder
    competitorCount?: SortOrder
    franchiseFee?: SortOrder
    minimumInvestment?: SortOrder
    exclusiveRadius?: SortOrder
  }

  export type TerritoriesAvailableMaxOrderByAggregateInput = {
    id?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    state?: SortOrder
    city?: SortOrder
    county?: SortOrder
    estimatedPopulation?: SortOrder
    averageIncome?: SortOrder
    competitorCount?: SortOrder
    marketPotential?: SortOrder
    franchiseFee?: SortOrder
    minimumInvestment?: SortOrder
    exclusiveRadius?: SortOrder
    isAvailable?: SortOrder
    reservedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerritoriesAvailableMinOrderByAggregateInput = {
    id?: SortOrder
    territoryCode?: SortOrder
    territoryName?: SortOrder
    state?: SortOrder
    city?: SortOrder
    county?: SortOrder
    estimatedPopulation?: SortOrder
    averageIncome?: SortOrder
    competitorCount?: SortOrder
    marketPotential?: SortOrder
    franchiseFee?: SortOrder
    minimumInvestment?: SortOrder
    exclusiveRadius?: SortOrder
    isAvailable?: SortOrder
    reservedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerritoriesAvailableSumOrderByAggregateInput = {
    estimatedPopulation?: SortOrder
    averageIncome?: SortOrder
    competitorCount?: SortOrder
    franchiseFee?: SortOrder
    minimumInvestment?: SortOrder
    exclusiveRadius?: SortOrder
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type CustomerEmailLocationIdCompoundUniqueInput = {
    email: string
    locationId: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    dogName?: SortOrder
    dogBreed?: SortOrder
    dogAge?: SortOrder
    dogWeight?: SortOrder
    allergies?: SortOrder
    preferredGroomer?: SortOrder
    notes?: SortOrder
    squareCustomerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    dogAge?: SortOrder
    dogWeight?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    dogName?: SortOrder
    dogBreed?: SortOrder
    dogAge?: SortOrder
    dogWeight?: SortOrder
    allergies?: SortOrder
    preferredGroomer?: SortOrder
    notes?: SortOrder
    squareCustomerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    dogName?: SortOrder
    dogBreed?: SortOrder
    dogAge?: SortOrder
    dogWeight?: SortOrder
    allergies?: SortOrder
    preferredGroomer?: SortOrder
    notes?: SortOrder
    squareCustomerId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    dogAge?: SortOrder
    dogWeight?: SortOrder
  }

  export type FranchiseFeeLocationIdMonthYearCompoundUniqueInput = {
    locationId: string
    month: number
    year: number
  }

  export type FranchiseFeeCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    serviceRevenue?: SortOrder
    productRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    totalRevenue?: SortOrder
    franchiseFee?: SortOrder
    royaltyFee?: SortOrder
    totalFees?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
  }

  export type FranchiseFeeAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    serviceRevenue?: SortOrder
    productRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    totalRevenue?: SortOrder
    franchiseFee?: SortOrder
    royaltyFee?: SortOrder
    totalFees?: SortOrder
  }

  export type FranchiseFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    serviceRevenue?: SortOrder
    productRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    totalRevenue?: SortOrder
    franchiseFee?: SortOrder
    royaltyFee?: SortOrder
    totalFees?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
  }

  export type FranchiseFeeMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    serviceRevenue?: SortOrder
    productRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    totalRevenue?: SortOrder
    franchiseFee?: SortOrder
    royaltyFee?: SortOrder
    totalFees?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
  }

  export type FranchiseFeeSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    serviceRevenue?: SortOrder
    productRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    totalRevenue?: SortOrder
    franchiseFee?: SortOrder
    royaltyFee?: SortOrder
    totalFees?: SortOrder
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    serviceType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    squareOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    serviceType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    squareOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    serviceType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    squareOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    packageType?: SortOrder
    price?: SortOrder
    billingInterval?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    canceledAt?: SortOrder
    squareSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    packageType?: SortOrder
    price?: SortOrder
    billingInterval?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    canceledAt?: SortOrder
    squareSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    packageType?: SortOrder
    price?: SortOrder
    billingInterval?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    nextBillingDate?: SortOrder
    canceledAt?: SortOrder
    squareSubscriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stockQuantity?: SortOrder
    lowStockThreshold?: SortOrder
    squareItemId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    stockQuantity?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stockQuantity?: SortOrder
    lowStockThreshold?: SortOrder
    squareItemId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stockQuantity?: SortOrder
    lowStockThreshold?: SortOrder
    squareItemId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    stockQuantity?: SortOrder
    lowStockThreshold?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrder
    fulfilledAt?: SortOrder
    squareOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrder
    fulfilledAt?: SortOrder
    squareOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    customerId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    shippingAddress?: SortOrder
    fulfilledAt?: SortOrder
    squareOrderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    discount?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type PluginNullableScalarRelationFilter = {
    is?: PluginWhereInput | null
    isNot?: PluginWhereInput | null
  }

  export type GithubCallbackCountOrderByAggregateInput = {
    id?: SortOrder
    callbackId?: SortOrder
    streamUrl?: SortOrder
    streamStatus?: SortOrder
    data?: SortOrder
    pluginId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GithubCallbackMaxOrderByAggregateInput = {
    id?: SortOrder
    callbackId?: SortOrder
    streamUrl?: SortOrder
    streamStatus?: SortOrder
    pluginId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GithubCallbackMinOrderByAggregateInput = {
    id?: SortOrder
    callbackId?: SortOrder
    streamUrl?: SortOrder
    streamStatus?: SortOrder
    pluginId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LocationCreateWithoutOwnerInput, LocationUncheckedCreateWithoutOwnerInput> | LocationCreateWithoutOwnerInput[] | LocationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOwnerInput | LocationCreateOrConnectWithoutOwnerInput[]
    createMany?: LocationCreateManyOwnerInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type UserAdministratorCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAdministratorCreateWithoutUserInput, UserAdministratorUncheckedCreateWithoutUserInput> | UserAdministratorCreateWithoutUserInput[] | UserAdministratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutUserInput | UserAdministratorCreateOrConnectWithoutUserInput[]
    createMany?: UserAdministratorCreateManyUserInputEnvelope
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutUserAccountInput = {
    create?: XOR<CustomerCreateWithoutUserAccountInput, CustomerUncheckedCreateWithoutUserAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserAccountInput
    connect?: CustomerWhereUniqueInput
  }

  export type PluginCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PluginCreateWithoutCreatorInput, PluginUncheckedCreateWithoutCreatorInput> | PluginCreateWithoutCreatorInput[] | PluginUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PluginCreateOrConnectWithoutCreatorInput | PluginCreateOrConnectWithoutCreatorInput[]
    createMany?: PluginCreateManyCreatorInputEnvelope
    connect?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LocationCreateWithoutOwnerInput, LocationUncheckedCreateWithoutOwnerInput> | LocationCreateWithoutOwnerInput[] | LocationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOwnerInput | LocationCreateOrConnectWithoutOwnerInput[]
    createMany?: LocationCreateManyOwnerInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type UserAdministratorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAdministratorCreateWithoutUserInput, UserAdministratorUncheckedCreateWithoutUserInput> | UserAdministratorCreateWithoutUserInput[] | UserAdministratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutUserInput | UserAdministratorCreateOrConnectWithoutUserInput[]
    createMany?: UserAdministratorCreateManyUserInputEnvelope
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedOneWithoutUserAccountInput = {
    create?: XOR<CustomerCreateWithoutUserAccountInput, CustomerUncheckedCreateWithoutUserAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserAccountInput
    connect?: CustomerWhereUniqueInput
  }

  export type PluginUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PluginCreateWithoutCreatorInput, PluginUncheckedCreateWithoutCreatorInput> | PluginCreateWithoutCreatorInput[] | PluginUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PluginCreateOrConnectWithoutCreatorInput | PluginCreateOrConnectWithoutCreatorInput[]
    createMany?: PluginCreateManyCreatorInputEnvelope
    connect?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LocationUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LocationCreateWithoutOwnerInput, LocationUncheckedCreateWithoutOwnerInput> | LocationCreateWithoutOwnerInput[] | LocationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOwnerInput | LocationCreateOrConnectWithoutOwnerInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOwnerInput | LocationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LocationCreateManyOwnerInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOwnerInput | LocationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOwnerInput | LocationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type UserAdministratorUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAdministratorCreateWithoutUserInput, UserAdministratorUncheckedCreateWithoutUserInput> | UserAdministratorCreateWithoutUserInput[] | UserAdministratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutUserInput | UserAdministratorCreateOrConnectWithoutUserInput[]
    upsert?: UserAdministratorUpsertWithWhereUniqueWithoutUserInput | UserAdministratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAdministratorCreateManyUserInputEnvelope
    set?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    disconnect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    delete?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    update?: UserAdministratorUpdateWithWhereUniqueWithoutUserInput | UserAdministratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAdministratorUpdateManyWithWhereWithoutUserInput | UserAdministratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAdministratorScalarWhereInput | UserAdministratorScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutUserAccountNestedInput = {
    create?: XOR<CustomerCreateWithoutUserAccountInput, CustomerUncheckedCreateWithoutUserAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserAccountInput
    upsert?: CustomerUpsertWithoutUserAccountInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserAccountInput, CustomerUpdateWithoutUserAccountInput>, CustomerUncheckedUpdateWithoutUserAccountInput>
  }

  export type PluginUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PluginCreateWithoutCreatorInput, PluginUncheckedCreateWithoutCreatorInput> | PluginCreateWithoutCreatorInput[] | PluginUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PluginCreateOrConnectWithoutCreatorInput | PluginCreateOrConnectWithoutCreatorInput[]
    upsert?: PluginUpsertWithWhereUniqueWithoutCreatorInput | PluginUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PluginCreateManyCreatorInputEnvelope
    set?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    disconnect?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    delete?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    connect?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    update?: PluginUpdateWithWhereUniqueWithoutCreatorInput | PluginUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PluginUpdateManyWithWhereWithoutCreatorInput | PluginUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PluginScalarWhereInput | PluginScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LocationCreateWithoutOwnerInput, LocationUncheckedCreateWithoutOwnerInput> | LocationCreateWithoutOwnerInput[] | LocationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOwnerInput | LocationCreateOrConnectWithoutOwnerInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOwnerInput | LocationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LocationCreateManyOwnerInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOwnerInput | LocationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOwnerInput | LocationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type UserAdministratorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAdministratorCreateWithoutUserInput, UserAdministratorUncheckedCreateWithoutUserInput> | UserAdministratorCreateWithoutUserInput[] | UserAdministratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutUserInput | UserAdministratorCreateOrConnectWithoutUserInput[]
    upsert?: UserAdministratorUpsertWithWhereUniqueWithoutUserInput | UserAdministratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAdministratorCreateManyUserInputEnvelope
    set?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    disconnect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    delete?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    update?: UserAdministratorUpdateWithWhereUniqueWithoutUserInput | UserAdministratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAdministratorUpdateManyWithWhereWithoutUserInput | UserAdministratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAdministratorScalarWhereInput | UserAdministratorScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateOneWithoutUserAccountNestedInput = {
    create?: XOR<CustomerCreateWithoutUserAccountInput, CustomerUncheckedCreateWithoutUserAccountInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutUserAccountInput
    upsert?: CustomerUpsertWithoutUserAccountInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutUserAccountInput, CustomerUpdateWithoutUserAccountInput>, CustomerUncheckedUpdateWithoutUserAccountInput>
  }

  export type PluginUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PluginCreateWithoutCreatorInput, PluginUncheckedCreateWithoutCreatorInput> | PluginCreateWithoutCreatorInput[] | PluginUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PluginCreateOrConnectWithoutCreatorInput | PluginCreateOrConnectWithoutCreatorInput[]
    upsert?: PluginUpsertWithWhereUniqueWithoutCreatorInput | PluginUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PluginCreateManyCreatorInputEnvelope
    set?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    disconnect?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    delete?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    connect?: PluginWhereUniqueInput | PluginWhereUniqueInput[]
    update?: PluginUpdateWithWhereUniqueWithoutCreatorInput | PluginUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PluginUpdateManyWithWhereWithoutCreatorInput | PluginUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PluginScalarWhereInput | PluginScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedPluginsInput = {
    create?: XOR<UserCreateWithoutCreatedPluginsInput, UserUncheckedCreateWithoutCreatedPluginsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPluginsInput
    connect?: UserWhereUniqueInput
  }

  export type PluginPurchaseCreateNestedManyWithoutPluginInput = {
    create?: XOR<PluginPurchaseCreateWithoutPluginInput, PluginPurchaseUncheckedCreateWithoutPluginInput> | PluginPurchaseCreateWithoutPluginInput[] | PluginPurchaseUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutPluginInput | PluginPurchaseCreateOrConnectWithoutPluginInput[]
    createMany?: PluginPurchaseCreateManyPluginInputEnvelope
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
  }

  export type PluginUsageCreateNestedManyWithoutPluginInput = {
    create?: XOR<PluginUsageCreateWithoutPluginInput, PluginUsageUncheckedCreateWithoutPluginInput> | PluginUsageCreateWithoutPluginInput[] | PluginUsageUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPluginInput | PluginUsageCreateOrConnectWithoutPluginInput[]
    createMany?: PluginUsageCreateManyPluginInputEnvelope
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
  }

  export type GithubCallbackCreateNestedManyWithoutPluginInput = {
    create?: XOR<GithubCallbackCreateWithoutPluginInput, GithubCallbackUncheckedCreateWithoutPluginInput> | GithubCallbackCreateWithoutPluginInput[] | GithubCallbackUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: GithubCallbackCreateOrConnectWithoutPluginInput | GithubCallbackCreateOrConnectWithoutPluginInput[]
    createMany?: GithubCallbackCreateManyPluginInputEnvelope
    connect?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
  }

  export type PluginPurchaseUncheckedCreateNestedManyWithoutPluginInput = {
    create?: XOR<PluginPurchaseCreateWithoutPluginInput, PluginPurchaseUncheckedCreateWithoutPluginInput> | PluginPurchaseCreateWithoutPluginInput[] | PluginPurchaseUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutPluginInput | PluginPurchaseCreateOrConnectWithoutPluginInput[]
    createMany?: PluginPurchaseCreateManyPluginInputEnvelope
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
  }

  export type PluginUsageUncheckedCreateNestedManyWithoutPluginInput = {
    create?: XOR<PluginUsageCreateWithoutPluginInput, PluginUsageUncheckedCreateWithoutPluginInput> | PluginUsageCreateWithoutPluginInput[] | PluginUsageUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPluginInput | PluginUsageCreateOrConnectWithoutPluginInput[]
    createMany?: PluginUsageCreateManyPluginInputEnvelope
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
  }

  export type GithubCallbackUncheckedCreateNestedManyWithoutPluginInput = {
    create?: XOR<GithubCallbackCreateWithoutPluginInput, GithubCallbackUncheckedCreateWithoutPluginInput> | GithubCallbackCreateWithoutPluginInput[] | GithubCallbackUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: GithubCallbackCreateOrConnectWithoutPluginInput | GithubCallbackCreateOrConnectWithoutPluginInput[]
    createMany?: GithubCallbackCreateManyPluginInputEnvelope
    connect?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
  }

  export type EnumPluginCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PluginCategory
  }

  export type EnumPricingModelFieldUpdateOperationsInput = {
    set?: $Enums.PricingModel
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDeploymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeploymentStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCreatedPluginsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPluginsInput, UserUncheckedCreateWithoutCreatedPluginsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPluginsInput
    upsert?: UserUpsertWithoutCreatedPluginsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPluginsInput, UserUpdateWithoutCreatedPluginsInput>, UserUncheckedUpdateWithoutCreatedPluginsInput>
  }

  export type PluginPurchaseUpdateManyWithoutPluginNestedInput = {
    create?: XOR<PluginPurchaseCreateWithoutPluginInput, PluginPurchaseUncheckedCreateWithoutPluginInput> | PluginPurchaseCreateWithoutPluginInput[] | PluginPurchaseUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutPluginInput | PluginPurchaseCreateOrConnectWithoutPluginInput[]
    upsert?: PluginPurchaseUpsertWithWhereUniqueWithoutPluginInput | PluginPurchaseUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: PluginPurchaseCreateManyPluginInputEnvelope
    set?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    disconnect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    delete?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    update?: PluginPurchaseUpdateWithWhereUniqueWithoutPluginInput | PluginPurchaseUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: PluginPurchaseUpdateManyWithWhereWithoutPluginInput | PluginPurchaseUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: PluginPurchaseScalarWhereInput | PluginPurchaseScalarWhereInput[]
  }

  export type PluginUsageUpdateManyWithoutPluginNestedInput = {
    create?: XOR<PluginUsageCreateWithoutPluginInput, PluginUsageUncheckedCreateWithoutPluginInput> | PluginUsageCreateWithoutPluginInput[] | PluginUsageUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPluginInput | PluginUsageCreateOrConnectWithoutPluginInput[]
    upsert?: PluginUsageUpsertWithWhereUniqueWithoutPluginInput | PluginUsageUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: PluginUsageCreateManyPluginInputEnvelope
    set?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    disconnect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    delete?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    update?: PluginUsageUpdateWithWhereUniqueWithoutPluginInput | PluginUsageUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: PluginUsageUpdateManyWithWhereWithoutPluginInput | PluginUsageUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: PluginUsageScalarWhereInput | PluginUsageScalarWhereInput[]
  }

  export type GithubCallbackUpdateManyWithoutPluginNestedInput = {
    create?: XOR<GithubCallbackCreateWithoutPluginInput, GithubCallbackUncheckedCreateWithoutPluginInput> | GithubCallbackCreateWithoutPluginInput[] | GithubCallbackUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: GithubCallbackCreateOrConnectWithoutPluginInput | GithubCallbackCreateOrConnectWithoutPluginInput[]
    upsert?: GithubCallbackUpsertWithWhereUniqueWithoutPluginInput | GithubCallbackUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: GithubCallbackCreateManyPluginInputEnvelope
    set?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    disconnect?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    delete?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    connect?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    update?: GithubCallbackUpdateWithWhereUniqueWithoutPluginInput | GithubCallbackUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: GithubCallbackUpdateManyWithWhereWithoutPluginInput | GithubCallbackUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: GithubCallbackScalarWhereInput | GithubCallbackScalarWhereInput[]
  }

  export type PluginPurchaseUncheckedUpdateManyWithoutPluginNestedInput = {
    create?: XOR<PluginPurchaseCreateWithoutPluginInput, PluginPurchaseUncheckedCreateWithoutPluginInput> | PluginPurchaseCreateWithoutPluginInput[] | PluginPurchaseUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutPluginInput | PluginPurchaseCreateOrConnectWithoutPluginInput[]
    upsert?: PluginPurchaseUpsertWithWhereUniqueWithoutPluginInput | PluginPurchaseUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: PluginPurchaseCreateManyPluginInputEnvelope
    set?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    disconnect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    delete?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    update?: PluginPurchaseUpdateWithWhereUniqueWithoutPluginInput | PluginPurchaseUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: PluginPurchaseUpdateManyWithWhereWithoutPluginInput | PluginPurchaseUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: PluginPurchaseScalarWhereInput | PluginPurchaseScalarWhereInput[]
  }

  export type PluginUsageUncheckedUpdateManyWithoutPluginNestedInput = {
    create?: XOR<PluginUsageCreateWithoutPluginInput, PluginUsageUncheckedCreateWithoutPluginInput> | PluginUsageCreateWithoutPluginInput[] | PluginUsageUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPluginInput | PluginUsageCreateOrConnectWithoutPluginInput[]
    upsert?: PluginUsageUpsertWithWhereUniqueWithoutPluginInput | PluginUsageUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: PluginUsageCreateManyPluginInputEnvelope
    set?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    disconnect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    delete?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    update?: PluginUsageUpdateWithWhereUniqueWithoutPluginInput | PluginUsageUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: PluginUsageUpdateManyWithWhereWithoutPluginInput | PluginUsageUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: PluginUsageScalarWhereInput | PluginUsageScalarWhereInput[]
  }

  export type GithubCallbackUncheckedUpdateManyWithoutPluginNestedInput = {
    create?: XOR<GithubCallbackCreateWithoutPluginInput, GithubCallbackUncheckedCreateWithoutPluginInput> | GithubCallbackCreateWithoutPluginInput[] | GithubCallbackUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: GithubCallbackCreateOrConnectWithoutPluginInput | GithubCallbackCreateOrConnectWithoutPluginInput[]
    upsert?: GithubCallbackUpsertWithWhereUniqueWithoutPluginInput | GithubCallbackUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: GithubCallbackCreateManyPluginInputEnvelope
    set?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    disconnect?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    delete?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    connect?: GithubCallbackWhereUniqueInput | GithubCallbackWhereUniqueInput[]
    update?: GithubCallbackUpdateWithWhereUniqueWithoutPluginInput | GithubCallbackUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: GithubCallbackUpdateManyWithWhereWithoutPluginInput | GithubCallbackUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: GithubCallbackScalarWhereInput | GithubCallbackScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutPluginPurchasesInput = {
    create?: XOR<CustomerCreateWithoutPluginPurchasesInput, CustomerUncheckedCreateWithoutPluginPurchasesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPluginPurchasesInput
    connect?: CustomerWhereUniqueInput
  }

  export type PluginCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<PluginCreateWithoutPurchasesInput, PluginUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: PluginCreateOrConnectWithoutPurchasesInput
    connect?: PluginWhereUniqueInput
  }

  export type PluginUsageCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PluginUsageCreateWithoutPurchaseInput, PluginUsageUncheckedCreateWithoutPurchaseInput> | PluginUsageCreateWithoutPurchaseInput[] | PluginUsageUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPurchaseInput | PluginUsageCreateOrConnectWithoutPurchaseInput[]
    createMany?: PluginUsageCreateManyPurchaseInputEnvelope
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
  }

  export type PluginUsageUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PluginUsageCreateWithoutPurchaseInput, PluginUsageUncheckedCreateWithoutPurchaseInput> | PluginUsageCreateWithoutPurchaseInput[] | PluginUsageUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPurchaseInput | PluginUsageCreateOrConnectWithoutPurchaseInput[]
    createMany?: PluginUsageCreateManyPurchaseInputEnvelope
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
  }

  export type EnumPurchaseTypeFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseType
  }

  export type NullableEnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutPluginPurchasesNestedInput = {
    create?: XOR<CustomerCreateWithoutPluginPurchasesInput, CustomerUncheckedCreateWithoutPluginPurchasesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPluginPurchasesInput
    upsert?: CustomerUpsertWithoutPluginPurchasesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPluginPurchasesInput, CustomerUpdateWithoutPluginPurchasesInput>, CustomerUncheckedUpdateWithoutPluginPurchasesInput>
  }

  export type PluginUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<PluginCreateWithoutPurchasesInput, PluginUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: PluginCreateOrConnectWithoutPurchasesInput
    upsert?: PluginUpsertWithoutPurchasesInput
    connect?: PluginWhereUniqueInput
    update?: XOR<XOR<PluginUpdateToOneWithWhereWithoutPurchasesInput, PluginUpdateWithoutPurchasesInput>, PluginUncheckedUpdateWithoutPurchasesInput>
  }

  export type PluginUsageUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PluginUsageCreateWithoutPurchaseInput, PluginUsageUncheckedCreateWithoutPurchaseInput> | PluginUsageCreateWithoutPurchaseInput[] | PluginUsageUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPurchaseInput | PluginUsageCreateOrConnectWithoutPurchaseInput[]
    upsert?: PluginUsageUpsertWithWhereUniqueWithoutPurchaseInput | PluginUsageUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PluginUsageCreateManyPurchaseInputEnvelope
    set?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    disconnect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    delete?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    update?: PluginUsageUpdateWithWhereUniqueWithoutPurchaseInput | PluginUsageUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PluginUsageUpdateManyWithWhereWithoutPurchaseInput | PluginUsageUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PluginUsageScalarWhereInput | PluginUsageScalarWhereInput[]
  }

  export type PluginUsageUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PluginUsageCreateWithoutPurchaseInput, PluginUsageUncheckedCreateWithoutPurchaseInput> | PluginUsageCreateWithoutPurchaseInput[] | PluginUsageUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PluginUsageCreateOrConnectWithoutPurchaseInput | PluginUsageCreateOrConnectWithoutPurchaseInput[]
    upsert?: PluginUsageUpsertWithWhereUniqueWithoutPurchaseInput | PluginUsageUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PluginUsageCreateManyPurchaseInputEnvelope
    set?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    disconnect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    delete?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    connect?: PluginUsageWhereUniqueInput | PluginUsageWhereUniqueInput[]
    update?: PluginUsageUpdateWithWhereUniqueWithoutPurchaseInput | PluginUsageUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PluginUsageUpdateManyWithWhereWithoutPurchaseInput | PluginUsageUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PluginUsageScalarWhereInput | PluginUsageScalarWhereInput[]
  }

  export type PluginPurchaseCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<PluginPurchaseCreateWithoutUsageRecordsInput, PluginPurchaseUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutUsageRecordsInput
    connect?: PluginPurchaseWhereUniqueInput
  }

  export type PluginCreateNestedOneWithoutUsageRecordsInput = {
    create?: XOR<PluginCreateWithoutUsageRecordsInput, PluginUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: PluginCreateOrConnectWithoutUsageRecordsInput
    connect?: PluginWhereUniqueInput
  }

  export type PluginPurchaseUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<PluginPurchaseCreateWithoutUsageRecordsInput, PluginPurchaseUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutUsageRecordsInput
    upsert?: PluginPurchaseUpsertWithoutUsageRecordsInput
    connect?: PluginPurchaseWhereUniqueInput
    update?: XOR<XOR<PluginPurchaseUpdateToOneWithWhereWithoutUsageRecordsInput, PluginPurchaseUpdateWithoutUsageRecordsInput>, PluginPurchaseUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type PluginUpdateOneRequiredWithoutUsageRecordsNestedInput = {
    create?: XOR<PluginCreateWithoutUsageRecordsInput, PluginUncheckedCreateWithoutUsageRecordsInput>
    connectOrCreate?: PluginCreateOrConnectWithoutUsageRecordsInput
    upsert?: PluginUpsertWithoutUsageRecordsInput
    connect?: PluginWhereUniqueInput
    update?: XOR<XOR<PluginUpdateToOneWithWhereWithoutUsageRecordsInput, PluginUpdateWithoutUsageRecordsInput>, PluginUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type UserCreateNestedOneWithoutLocationAccessInput = {
    create?: XOR<UserCreateWithoutLocationAccessInput, UserUncheckedCreateWithoutLocationAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationAccessInput
    connect?: UserWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutAdminUsersInput = {
    create?: XOR<LocationCreateWithoutAdminUsersInput, LocationUncheckedCreateWithoutAdminUsersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAdminUsersInput
    connect?: LocationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLocationAccessNestedInput = {
    create?: XOR<UserCreateWithoutLocationAccessInput, UserUncheckedCreateWithoutLocationAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationAccessInput
    upsert?: UserUpsertWithoutLocationAccessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLocationAccessInput, UserUpdateWithoutLocationAccessInput>, UserUncheckedUpdateWithoutLocationAccessInput>
  }

  export type LocationUpdateOneRequiredWithoutAdminUsersNestedInput = {
    create?: XOR<LocationCreateWithoutAdminUsersInput, LocationUncheckedCreateWithoutAdminUsersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAdminUsersInput
    upsert?: LocationUpsertWithoutAdminUsersInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAdminUsersInput, LocationUpdateWithoutAdminUsersInput>, LocationUncheckedUpdateWithoutAdminUsersInput>
  }

  export type LocationCreateNestedOneWithoutTerritoryInput = {
    create?: XOR<LocationCreateWithoutTerritoryInput, LocationUncheckedCreateWithoutTerritoryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTerritoryInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationUpdateOneRequiredWithoutTerritoryNestedInput = {
    create?: XOR<LocationCreateWithoutTerritoryInput, LocationUncheckedCreateWithoutTerritoryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTerritoryInput
    upsert?: LocationUpsertWithoutTerritoryInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutTerritoryInput, LocationUpdateWithoutTerritoryInput>, LocationUncheckedUpdateWithoutTerritoryInput>
  }

  export type LocationCreateNestedOneWithoutCsiRecordsInput = {
    create?: XOR<LocationCreateWithoutCsiRecordsInput, LocationUncheckedCreateWithoutCsiRecordsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCsiRecordsInput
    connect?: LocationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCsiRecordsInput = {
    create?: XOR<CustomerCreateWithoutCsiRecordsInput, CustomerUncheckedCreateWithoutCsiRecordsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCsiRecordsInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumCSISourceFieldUpdateOperationsInput = {
    set?: $Enums.CSISource
  }

  export type LocationUpdateOneRequiredWithoutCsiRecordsNestedInput = {
    create?: XOR<LocationCreateWithoutCsiRecordsInput, LocationUncheckedCreateWithoutCsiRecordsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCsiRecordsInput
    upsert?: LocationUpsertWithoutCsiRecordsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutCsiRecordsInput, LocationUpdateWithoutCsiRecordsInput>, LocationUncheckedUpdateWithoutCsiRecordsInput>
  }

  export type CustomerUpdateOneWithoutCsiRecordsNestedInput = {
    create?: XOR<CustomerCreateWithoutCsiRecordsInput, CustomerUncheckedCreateWithoutCsiRecordsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCsiRecordsInput
    upsert?: CustomerUpsertWithoutCsiRecordsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCsiRecordsInput, CustomerUpdateWithoutCsiRecordsInput>, CustomerUncheckedUpdateWithoutCsiRecordsInput>
  }

  export type UserCreateNestedOneWithoutOwnedLocationsInput = {
    create?: XOR<UserCreateWithoutOwnedLocationsInput, UserUncheckedCreateWithoutOwnedLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLocationsInput
    connect?: UserWhereUniqueInput
  }

  export type TerritoryCreateNestedOneWithoutLocationInput = {
    create?: XOR<TerritoryCreateWithoutLocationInput, TerritoryUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TerritoryCreateOrConnectWithoutLocationInput
    connect?: TerritoryWhereUniqueInput
  }

  export type CSICreateNestedManyWithoutLocationInput = {
    create?: XOR<CSICreateWithoutLocationInput, CSIUncheckedCreateWithoutLocationInput> | CSICreateWithoutLocationInput[] | CSIUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CSICreateOrConnectWithoutLocationInput | CSICreateOrConnectWithoutLocationInput[]
    createMany?: CSICreateManyLocationInputEnvelope
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
  }

  export type UserAdministratorCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserAdministratorCreateWithoutLocationInput, UserAdministratorUncheckedCreateWithoutLocationInput> | UserAdministratorCreateWithoutLocationInput[] | UserAdministratorUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutLocationInput | UserAdministratorCreateOrConnectWithoutLocationInput[]
    createMany?: UserAdministratorCreateManyLocationInputEnvelope
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutLocationInput = {
    create?: XOR<CustomerCreateWithoutLocationInput, CustomerUncheckedCreateWithoutLocationInput> | CustomerCreateWithoutLocationInput[] | CustomerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutLocationInput | CustomerCreateOrConnectWithoutLocationInput[]
    createMany?: CustomerCreateManyLocationInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutLocationInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutLocationInput = {
    create?: XOR<SubscriptionCreateWithoutLocationInput, SubscriptionUncheckedCreateWithoutLocationInput> | SubscriptionCreateWithoutLocationInput[] | SubscriptionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutLocationInput | SubscriptionCreateOrConnectWithoutLocationInput[]
    createMany?: SubscriptionCreateManyLocationInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FranchiseFeeCreateNestedManyWithoutLocationInput = {
    create?: XOR<FranchiseFeeCreateWithoutLocationInput, FranchiseFeeUncheckedCreateWithoutLocationInput> | FranchiseFeeCreateWithoutLocationInput[] | FranchiseFeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: FranchiseFeeCreateOrConnectWithoutLocationInput | FranchiseFeeCreateOrConnectWithoutLocationInput[]
    createMany?: FranchiseFeeCreateManyLocationInputEnvelope
    connect?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
  }

  export type TerritoryUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<TerritoryCreateWithoutLocationInput, TerritoryUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TerritoryCreateOrConnectWithoutLocationInput
    connect?: TerritoryWhereUniqueInput
  }

  export type CSIUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<CSICreateWithoutLocationInput, CSIUncheckedCreateWithoutLocationInput> | CSICreateWithoutLocationInput[] | CSIUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CSICreateOrConnectWithoutLocationInput | CSICreateOrConnectWithoutLocationInput[]
    createMany?: CSICreateManyLocationInputEnvelope
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
  }

  export type UserAdministratorUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserAdministratorCreateWithoutLocationInput, UserAdministratorUncheckedCreateWithoutLocationInput> | UserAdministratorCreateWithoutLocationInput[] | UserAdministratorUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutLocationInput | UserAdministratorCreateOrConnectWithoutLocationInput[]
    createMany?: UserAdministratorCreateManyLocationInputEnvelope
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<CustomerCreateWithoutLocationInput, CustomerUncheckedCreateWithoutLocationInput> | CustomerCreateWithoutLocationInput[] | CustomerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutLocationInput | CustomerCreateOrConnectWithoutLocationInput[]
    createMany?: CustomerCreateManyLocationInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<SubscriptionCreateWithoutLocationInput, SubscriptionUncheckedCreateWithoutLocationInput> | SubscriptionCreateWithoutLocationInput[] | SubscriptionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutLocationInput | SubscriptionCreateOrConnectWithoutLocationInput[]
    createMany?: SubscriptionCreateManyLocationInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<FranchiseFeeCreateWithoutLocationInput, FranchiseFeeUncheckedCreateWithoutLocationInput> | FranchiseFeeCreateWithoutLocationInput[] | FranchiseFeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: FranchiseFeeCreateOrConnectWithoutLocationInput | FranchiseFeeCreateOrConnectWithoutLocationInput[]
    createMany?: FranchiseFeeCreateManyLocationInputEnvelope
    connect?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutOwnedLocationsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedLocationsInput, UserUncheckedCreateWithoutOwnedLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedLocationsInput
    upsert?: UserUpsertWithoutOwnedLocationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedLocationsInput, UserUpdateWithoutOwnedLocationsInput>, UserUncheckedUpdateWithoutOwnedLocationsInput>
  }

  export type TerritoryUpdateOneWithoutLocationNestedInput = {
    create?: XOR<TerritoryCreateWithoutLocationInput, TerritoryUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TerritoryCreateOrConnectWithoutLocationInput
    upsert?: TerritoryUpsertWithoutLocationInput
    disconnect?: TerritoryWhereInput | boolean
    delete?: TerritoryWhereInput | boolean
    connect?: TerritoryWhereUniqueInput
    update?: XOR<XOR<TerritoryUpdateToOneWithWhereWithoutLocationInput, TerritoryUpdateWithoutLocationInput>, TerritoryUncheckedUpdateWithoutLocationInput>
  }

  export type CSIUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CSICreateWithoutLocationInput, CSIUncheckedCreateWithoutLocationInput> | CSICreateWithoutLocationInput[] | CSIUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CSICreateOrConnectWithoutLocationInput | CSICreateOrConnectWithoutLocationInput[]
    upsert?: CSIUpsertWithWhereUniqueWithoutLocationInput | CSIUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CSICreateManyLocationInputEnvelope
    set?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    disconnect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    delete?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    update?: CSIUpdateWithWhereUniqueWithoutLocationInput | CSIUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CSIUpdateManyWithWhereWithoutLocationInput | CSIUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CSIScalarWhereInput | CSIScalarWhereInput[]
  }

  export type UserAdministratorUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserAdministratorCreateWithoutLocationInput, UserAdministratorUncheckedCreateWithoutLocationInput> | UserAdministratorCreateWithoutLocationInput[] | UserAdministratorUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutLocationInput | UserAdministratorCreateOrConnectWithoutLocationInput[]
    upsert?: UserAdministratorUpsertWithWhereUniqueWithoutLocationInput | UserAdministratorUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserAdministratorCreateManyLocationInputEnvelope
    set?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    disconnect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    delete?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    update?: UserAdministratorUpdateWithWhereUniqueWithoutLocationInput | UserAdministratorUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserAdministratorUpdateManyWithWhereWithoutLocationInput | UserAdministratorUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserAdministratorScalarWhereInput | UserAdministratorScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CustomerCreateWithoutLocationInput, CustomerUncheckedCreateWithoutLocationInput> | CustomerCreateWithoutLocationInput[] | CustomerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutLocationInput | CustomerCreateOrConnectWithoutLocationInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutLocationInput | CustomerUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CustomerCreateManyLocationInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutLocationInput | CustomerUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutLocationInput | CustomerUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutLocationInput | AppointmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutLocationInput | AppointmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutLocationInput | AppointmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SubscriptionCreateWithoutLocationInput, SubscriptionUncheckedCreateWithoutLocationInput> | SubscriptionCreateWithoutLocationInput[] | SubscriptionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutLocationInput | SubscriptionCreateOrConnectWithoutLocationInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutLocationInput | SubscriptionUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SubscriptionCreateManyLocationInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutLocationInput | SubscriptionUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutLocationInput | SubscriptionUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLocationInput | ProductUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLocationInput | ProductUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLocationInput | ProductUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type FranchiseFeeUpdateManyWithoutLocationNestedInput = {
    create?: XOR<FranchiseFeeCreateWithoutLocationInput, FranchiseFeeUncheckedCreateWithoutLocationInput> | FranchiseFeeCreateWithoutLocationInput[] | FranchiseFeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: FranchiseFeeCreateOrConnectWithoutLocationInput | FranchiseFeeCreateOrConnectWithoutLocationInput[]
    upsert?: FranchiseFeeUpsertWithWhereUniqueWithoutLocationInput | FranchiseFeeUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: FranchiseFeeCreateManyLocationInputEnvelope
    set?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    disconnect?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    delete?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    connect?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    update?: FranchiseFeeUpdateWithWhereUniqueWithoutLocationInput | FranchiseFeeUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: FranchiseFeeUpdateManyWithWhereWithoutLocationInput | FranchiseFeeUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: FranchiseFeeScalarWhereInput | FranchiseFeeScalarWhereInput[]
  }

  export type TerritoryUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<TerritoryCreateWithoutLocationInput, TerritoryUncheckedCreateWithoutLocationInput>
    connectOrCreate?: TerritoryCreateOrConnectWithoutLocationInput
    upsert?: TerritoryUpsertWithoutLocationInput
    disconnect?: TerritoryWhereInput | boolean
    delete?: TerritoryWhereInput | boolean
    connect?: TerritoryWhereUniqueInput
    update?: XOR<XOR<TerritoryUpdateToOneWithWhereWithoutLocationInput, TerritoryUpdateWithoutLocationInput>, TerritoryUncheckedUpdateWithoutLocationInput>
  }

  export type CSIUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CSICreateWithoutLocationInput, CSIUncheckedCreateWithoutLocationInput> | CSICreateWithoutLocationInput[] | CSIUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CSICreateOrConnectWithoutLocationInput | CSICreateOrConnectWithoutLocationInput[]
    upsert?: CSIUpsertWithWhereUniqueWithoutLocationInput | CSIUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CSICreateManyLocationInputEnvelope
    set?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    disconnect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    delete?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    update?: CSIUpdateWithWhereUniqueWithoutLocationInput | CSIUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CSIUpdateManyWithWhereWithoutLocationInput | CSIUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CSIScalarWhereInput | CSIScalarWhereInput[]
  }

  export type UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserAdministratorCreateWithoutLocationInput, UserAdministratorUncheckedCreateWithoutLocationInput> | UserAdministratorCreateWithoutLocationInput[] | UserAdministratorUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserAdministratorCreateOrConnectWithoutLocationInput | UserAdministratorCreateOrConnectWithoutLocationInput[]
    upsert?: UserAdministratorUpsertWithWhereUniqueWithoutLocationInput | UserAdministratorUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserAdministratorCreateManyLocationInputEnvelope
    set?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    disconnect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    delete?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    connect?: UserAdministratorWhereUniqueInput | UserAdministratorWhereUniqueInput[]
    update?: UserAdministratorUpdateWithWhereUniqueWithoutLocationInput | UserAdministratorUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserAdministratorUpdateManyWithWhereWithoutLocationInput | UserAdministratorUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserAdministratorScalarWhereInput | UserAdministratorScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CustomerCreateWithoutLocationInput, CustomerUncheckedCreateWithoutLocationInput> | CustomerCreateWithoutLocationInput[] | CustomerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutLocationInput | CustomerCreateOrConnectWithoutLocationInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutLocationInput | CustomerUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CustomerCreateManyLocationInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutLocationInput | CustomerUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutLocationInput | CustomerUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput> | AppointmentCreateWithoutLocationInput[] | AppointmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutLocationInput | AppointmentCreateOrConnectWithoutLocationInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutLocationInput | AppointmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AppointmentCreateManyLocationInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutLocationInput | AppointmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutLocationInput | AppointmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SubscriptionCreateWithoutLocationInput, SubscriptionUncheckedCreateWithoutLocationInput> | SubscriptionCreateWithoutLocationInput[] | SubscriptionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutLocationInput | SubscriptionCreateOrConnectWithoutLocationInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutLocationInput | SubscriptionUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SubscriptionCreateManyLocationInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutLocationInput | SubscriptionUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutLocationInput | SubscriptionUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput> | ProductCreateWithoutLocationInput[] | ProductUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutLocationInput | ProductCreateOrConnectWithoutLocationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutLocationInput | ProductUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProductCreateManyLocationInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutLocationInput | ProductUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutLocationInput | ProductUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<FranchiseFeeCreateWithoutLocationInput, FranchiseFeeUncheckedCreateWithoutLocationInput> | FranchiseFeeCreateWithoutLocationInput[] | FranchiseFeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: FranchiseFeeCreateOrConnectWithoutLocationInput | FranchiseFeeCreateOrConnectWithoutLocationInput[]
    upsert?: FranchiseFeeUpsertWithWhereUniqueWithoutLocationInput | FranchiseFeeUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: FranchiseFeeCreateManyLocationInputEnvelope
    set?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    disconnect?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    delete?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    connect?: FranchiseFeeWhereUniqueInput | FranchiseFeeWhereUniqueInput[]
    update?: FranchiseFeeUpdateWithWhereUniqueWithoutLocationInput | FranchiseFeeUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: FranchiseFeeUpdateManyWithWhereWithoutLocationInput | FranchiseFeeUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: FranchiseFeeScalarWhereInput | FranchiseFeeScalarWhereInput[]
  }

  export type TerritoriesAvailableCreatezipCodesInput = {
    set: string[]
  }

  export type TerritoriesAvailableUpdatezipCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LocationCreateNestedOneWithoutCustomersInput = {
    create?: XOR<LocationCreateWithoutCustomersInput, LocationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCustomersInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCustomerAccountInput = {
    create?: XOR<UserCreateWithoutCustomerAccountInput, UserUncheckedCreateWithoutCustomerAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerAccountInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CSICreateNestedManyWithoutCustomerInput = {
    create?: XOR<CSICreateWithoutCustomerInput, CSIUncheckedCreateWithoutCustomerInput> | CSICreateWithoutCustomerInput[] | CSIUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CSICreateOrConnectWithoutCustomerInput | CSICreateOrConnectWithoutCustomerInput[]
    createMany?: CSICreateManyCustomerInputEnvelope
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
  }

  export type PluginPurchaseCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PluginPurchaseCreateWithoutCustomerInput, PluginPurchaseUncheckedCreateWithoutCustomerInput> | PluginPurchaseCreateWithoutCustomerInput[] | PluginPurchaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutCustomerInput | PluginPurchaseCreateOrConnectWithoutCustomerInput[]
    createMany?: PluginPurchaseCreateManyCustomerInputEnvelope
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CSIUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CSICreateWithoutCustomerInput, CSIUncheckedCreateWithoutCustomerInput> | CSICreateWithoutCustomerInput[] | CSIUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CSICreateOrConnectWithoutCustomerInput | CSICreateOrConnectWithoutCustomerInput[]
    createMany?: CSICreateManyCustomerInputEnvelope
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
  }

  export type PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PluginPurchaseCreateWithoutCustomerInput, PluginPurchaseUncheckedCreateWithoutCustomerInput> | PluginPurchaseCreateWithoutCustomerInput[] | PluginPurchaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutCustomerInput | PluginPurchaseCreateOrConnectWithoutCustomerInput[]
    createMany?: PluginPurchaseCreateManyCustomerInputEnvelope
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
  }

  export type LocationUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<LocationCreateWithoutCustomersInput, LocationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCustomersInput
    upsert?: LocationUpsertWithoutCustomersInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutCustomersInput, LocationUpdateWithoutCustomersInput>, LocationUncheckedUpdateWithoutCustomersInput>
  }

  export type UserUpdateOneWithoutCustomerAccountNestedInput = {
    create?: XOR<UserCreateWithoutCustomerAccountInput, UserUncheckedCreateWithoutCustomerAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerAccountInput
    upsert?: UserUpsertWithoutCustomerAccountInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerAccountInput, UserUpdateWithoutCustomerAccountInput>, UserUncheckedUpdateWithoutCustomerAccountInput>
  }

  export type AppointmentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCustomerInput | AppointmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCustomerInput | AppointmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCustomerInput | AppointmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CSIUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CSICreateWithoutCustomerInput, CSIUncheckedCreateWithoutCustomerInput> | CSICreateWithoutCustomerInput[] | CSIUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CSICreateOrConnectWithoutCustomerInput | CSICreateOrConnectWithoutCustomerInput[]
    upsert?: CSIUpsertWithWhereUniqueWithoutCustomerInput | CSIUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CSICreateManyCustomerInputEnvelope
    set?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    disconnect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    delete?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    update?: CSIUpdateWithWhereUniqueWithoutCustomerInput | CSIUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CSIUpdateManyWithWhereWithoutCustomerInput | CSIUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CSIScalarWhereInput | CSIScalarWhereInput[]
  }

  export type PluginPurchaseUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PluginPurchaseCreateWithoutCustomerInput, PluginPurchaseUncheckedCreateWithoutCustomerInput> | PluginPurchaseCreateWithoutCustomerInput[] | PluginPurchaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutCustomerInput | PluginPurchaseCreateOrConnectWithoutCustomerInput[]
    upsert?: PluginPurchaseUpsertWithWhereUniqueWithoutCustomerInput | PluginPurchaseUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PluginPurchaseCreateManyCustomerInputEnvelope
    set?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    disconnect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    delete?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    update?: PluginPurchaseUpdateWithWhereUniqueWithoutCustomerInput | PluginPurchaseUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PluginPurchaseUpdateManyWithWhereWithoutCustomerInput | PluginPurchaseUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PluginPurchaseScalarWhereInput | PluginPurchaseScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput> | AppointmentCreateWithoutCustomerInput[] | AppointmentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCustomerInput | AppointmentCreateOrConnectWithoutCustomerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCustomerInput | AppointmentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AppointmentCreateManyCustomerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCustomerInput | AppointmentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCustomerInput | AppointmentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CSIUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CSICreateWithoutCustomerInput, CSIUncheckedCreateWithoutCustomerInput> | CSICreateWithoutCustomerInput[] | CSIUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CSICreateOrConnectWithoutCustomerInput | CSICreateOrConnectWithoutCustomerInput[]
    upsert?: CSIUpsertWithWhereUniqueWithoutCustomerInput | CSIUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CSICreateManyCustomerInputEnvelope
    set?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    disconnect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    delete?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    connect?: CSIWhereUniqueInput | CSIWhereUniqueInput[]
    update?: CSIUpdateWithWhereUniqueWithoutCustomerInput | CSIUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CSIUpdateManyWithWhereWithoutCustomerInput | CSIUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CSIScalarWhereInput | CSIScalarWhereInput[]
  }

  export type PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PluginPurchaseCreateWithoutCustomerInput, PluginPurchaseUncheckedCreateWithoutCustomerInput> | PluginPurchaseCreateWithoutCustomerInput[] | PluginPurchaseUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PluginPurchaseCreateOrConnectWithoutCustomerInput | PluginPurchaseCreateOrConnectWithoutCustomerInput[]
    upsert?: PluginPurchaseUpsertWithWhereUniqueWithoutCustomerInput | PluginPurchaseUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PluginPurchaseCreateManyCustomerInputEnvelope
    set?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    disconnect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    delete?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    connect?: PluginPurchaseWhereUniqueInput | PluginPurchaseWhereUniqueInput[]
    update?: PluginPurchaseUpdateWithWhereUniqueWithoutCustomerInput | PluginPurchaseUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PluginPurchaseUpdateManyWithWhereWithoutCustomerInput | PluginPurchaseUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PluginPurchaseScalarWhereInput | PluginPurchaseScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutFranchiseFeesInput = {
    create?: XOR<LocationCreateWithoutFranchiseFeesInput, LocationUncheckedCreateWithoutFranchiseFeesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutFranchiseFeesInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationUpdateOneRequiredWithoutFranchiseFeesNestedInput = {
    create?: XOR<LocationCreateWithoutFranchiseFeesInput, LocationUncheckedCreateWithoutFranchiseFeesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutFranchiseFeesInput
    upsert?: LocationUpsertWithoutFranchiseFeesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutFranchiseFeesInput, LocationUpdateWithoutFranchiseFeesInput>, LocationUncheckedUpdateWithoutFranchiseFeesInput>
  }

  export type LocationCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<LocationCreateWithoutAppointmentsInput, LocationUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAppointmentsInput
    connect?: LocationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<CustomerCreateWithoutAppointmentsInput, CustomerUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAppointmentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type LocationUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<LocationCreateWithoutAppointmentsInput, LocationUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAppointmentsInput
    upsert?: LocationUpsertWithoutAppointmentsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAppointmentsInput, LocationUpdateWithoutAppointmentsInput>, LocationUncheckedUpdateWithoutAppointmentsInput>
  }

  export type CustomerUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<CustomerCreateWithoutAppointmentsInput, CustomerUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAppointmentsInput
    upsert?: CustomerUpsertWithoutAppointmentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAppointmentsInput, CustomerUpdateWithoutAppointmentsInput>, CustomerUncheckedUpdateWithoutAppointmentsInput>
  }

  export type LocationCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<LocationCreateWithoutSubscriptionsInput, LocationUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSubscriptionsInput
    connect?: LocationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type LocationUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<LocationCreateWithoutSubscriptionsInput, LocationUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSubscriptionsInput
    upsert?: LocationUpsertWithoutSubscriptionsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutSubscriptionsInput, LocationUpdateWithoutSubscriptionsInput>, LocationUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionsInput
    upsert?: CustomerUpsertWithoutSubscriptionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSubscriptionsInput, CustomerUpdateWithoutSubscriptionsInput>, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type LocationCreateNestedOneWithoutProductsInput = {
    create?: XOR<LocationCreateWithoutProductsInput, LocationUncheckedCreateWithoutProductsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductsInput
    connect?: LocationWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type LocationUpdateOneWithoutProductsNestedInput = {
    create?: XOR<LocationCreateWithoutProductsInput, LocationUncheckedCreateWithoutProductsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProductsInput
    upsert?: LocationUpsertWithoutProductsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutProductsInput, LocationUpdateWithoutProductsInput>, LocationUncheckedUpdateWithoutProductsInput>
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutOrdersInput = {
    create?: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrdersInput
    connect?: LocationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type LocationUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrdersInput
    upsert?: LocationUpsertWithoutOrdersInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutOrdersInput, LocationUpdateWithoutOrdersInput>, LocationUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type PluginCreateNestedOneWithoutGithubCallbacksInput = {
    create?: XOR<PluginCreateWithoutGithubCallbacksInput, PluginUncheckedCreateWithoutGithubCallbacksInput>
    connectOrCreate?: PluginCreateOrConnectWithoutGithubCallbacksInput
    connect?: PluginWhereUniqueInput
  }

  export type PluginUpdateOneWithoutGithubCallbacksNestedInput = {
    create?: XOR<PluginCreateWithoutGithubCallbacksInput, PluginUncheckedCreateWithoutGithubCallbacksInput>
    connectOrCreate?: PluginCreateOrConnectWithoutGithubCallbacksInput
    upsert?: PluginUpsertWithoutGithubCallbacksInput
    disconnect?: PluginWhereInput | boolean
    delete?: PluginWhereInput | boolean
    connect?: PluginWhereUniqueInput
    update?: XOR<XOR<PluginUpdateToOneWithWhereWithoutGithubCallbacksInput, PluginUpdateWithoutGithubCallbacksInput>, PluginUncheckedUpdateWithoutGithubCallbacksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPluginCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryFilter<$PrismaModel> | $Enums.PluginCategory
  }

  export type NestedEnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDeploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusFilter<$PrismaModel> | $Enums.DeploymentStatus
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PluginCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPluginCategoryFilter<$PrismaModel>
    _max?: NestedEnumPluginCategoryFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumDeploymentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeFilter<$PrismaModel> | $Enums.PurchaseType
  }

  export type NestedEnumSubscriptionStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
  }

  export type NestedEnumPurchaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseType | EnumPurchaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseType[] | ListEnumPurchaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseTypeFilter<$PrismaModel>
    _max?: NestedEnumPurchaseTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubscriptionStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumCSISourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CSISource | EnumCSISourceFieldRefInput<$PrismaModel>
    in?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCSISourceFilter<$PrismaModel> | $Enums.CSISource
  }

  export type NestedEnumCSISourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CSISource | EnumCSISourceFieldRefInput<$PrismaModel>
    in?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CSISource[] | ListEnumCSISourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCSISourceWithAggregatesFilter<$PrismaModel> | $Enums.CSISource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCSISourceFilter<$PrismaModel>
    _max?: NestedEnumCSISourceFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type LocationCreateWithoutOwnerInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOwnerInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOwnerInput, LocationUncheckedCreateWithoutOwnerInput>
  }

  export type LocationCreateManyOwnerInputEnvelope = {
    data: LocationCreateManyOwnerInput | LocationCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserAdministratorCreateWithoutUserInput = {
    id?: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
    location: LocationCreateNestedOneWithoutAdminUsersInput
  }

  export type UserAdministratorUncheckedCreateWithoutUserInput = {
    id?: string
    locationId: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserAdministratorCreateOrConnectWithoutUserInput = {
    where: UserAdministratorWhereUniqueInput
    create: XOR<UserAdministratorCreateWithoutUserInput, UserAdministratorUncheckedCreateWithoutUserInput>
  }

  export type UserAdministratorCreateManyUserInputEnvelope = {
    data: UserAdministratorCreateManyUserInput | UserAdministratorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutUserAccountInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCustomersInput
    appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    csiRecords?: CSICreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutUserAccountInput = {
    id?: string
    locationId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutUserAccountInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUserAccountInput, CustomerUncheckedCreateWithoutUserAccountInput>
  }

  export type PluginCreateWithoutCreatorInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    purchases?: PluginPurchaseCreateNestedManyWithoutPluginInput
    usageRecords?: PluginUsageCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackCreateNestedManyWithoutPluginInput
  }

  export type PluginUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    purchases?: PluginPurchaseUncheckedCreateNestedManyWithoutPluginInput
    usageRecords?: PluginUsageUncheckedCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackUncheckedCreateNestedManyWithoutPluginInput
  }

  export type PluginCreateOrConnectWithoutCreatorInput = {
    where: PluginWhereUniqueInput
    create: XOR<PluginCreateWithoutCreatorInput, PluginUncheckedCreateWithoutCreatorInput>
  }

  export type PluginCreateManyCreatorInputEnvelope = {
    data: PluginCreateManyCreatorInput | PluginCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithWhereUniqueWithoutOwnerInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutOwnerInput, LocationUncheckedUpdateWithoutOwnerInput>
    create: XOR<LocationCreateWithoutOwnerInput, LocationUncheckedCreateWithoutOwnerInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutOwnerInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutOwnerInput, LocationUncheckedUpdateWithoutOwnerInput>
  }

  export type LocationUpdateManyWithWhereWithoutOwnerInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutOwnerInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    city?: StringFilter<"Location"> | string
    state?: StringFilter<"Location"> | string
    zipCode?: StringFilter<"Location"> | string
    phone?: StringFilter<"Location"> | string
    email?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    franchiseId?: StringNullableFilter<"Location"> | string | null
    ownerId?: StringNullableFilter<"Location"> | string | null
    franchiseFeeRate?: FloatNullableFilter<"Location"> | number | null
    royaltyRate?: FloatNullableFilter<"Location"> | number | null
    timezone?: StringFilter<"Location"> | string
    businessHours?: JsonNullableFilter<"Location">
    currentCSIAverage?: FloatNullableFilter<"Location"> | number | null
    lastCSIUpdate?: DateTimeNullableFilter<"Location"> | Date | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type UserAdministratorUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAdministratorWhereUniqueInput
    update: XOR<UserAdministratorUpdateWithoutUserInput, UserAdministratorUncheckedUpdateWithoutUserInput>
    create: XOR<UserAdministratorCreateWithoutUserInput, UserAdministratorUncheckedCreateWithoutUserInput>
  }

  export type UserAdministratorUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAdministratorWhereUniqueInput
    data: XOR<UserAdministratorUpdateWithoutUserInput, UserAdministratorUncheckedUpdateWithoutUserInput>
  }

  export type UserAdministratorUpdateManyWithWhereWithoutUserInput = {
    where: UserAdministratorScalarWhereInput
    data: XOR<UserAdministratorUpdateManyMutationInput, UserAdministratorUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAdministratorScalarWhereInput = {
    AND?: UserAdministratorScalarWhereInput | UserAdministratorScalarWhereInput[]
    OR?: UserAdministratorScalarWhereInput[]
    NOT?: UserAdministratorScalarWhereInput | UserAdministratorScalarWhereInput[]
    id?: StringFilter<"UserAdministrator"> | string
    userId?: StringFilter<"UserAdministrator"> | string
    locationId?: StringFilter<"UserAdministrator"> | string
    canViewFinancials?: BoolFilter<"UserAdministrator"> | boolean
    canManageStaff?: BoolFilter<"UserAdministrator"> | boolean
    canEditAppointments?: BoolFilter<"UserAdministrator"> | boolean
    canViewReports?: BoolFilter<"UserAdministrator"> | boolean
    assignedAt?: DateTimeFilter<"UserAdministrator"> | Date | string
    assignedBy?: StringNullableFilter<"UserAdministrator"> | string | null
  }

  export type CustomerUpsertWithoutUserAccountInput = {
    update: XOR<CustomerUpdateWithoutUserAccountInput, CustomerUncheckedUpdateWithoutUserAccountInput>
    create: XOR<CustomerCreateWithoutUserAccountInput, CustomerUncheckedCreateWithoutUserAccountInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutUserAccountInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutUserAccountInput, CustomerUncheckedUpdateWithoutUserAccountInput>
  }

  export type CustomerUpdateWithoutUserAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCustomersNestedInput
    appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUserAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PluginUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PluginWhereUniqueInput
    update: XOR<PluginUpdateWithoutCreatorInput, PluginUncheckedUpdateWithoutCreatorInput>
    create: XOR<PluginCreateWithoutCreatorInput, PluginUncheckedCreateWithoutCreatorInput>
  }

  export type PluginUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PluginWhereUniqueInput
    data: XOR<PluginUpdateWithoutCreatorInput, PluginUncheckedUpdateWithoutCreatorInput>
  }

  export type PluginUpdateManyWithWhereWithoutCreatorInput = {
    where: PluginScalarWhereInput
    data: XOR<PluginUpdateManyMutationInput, PluginUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PluginScalarWhereInput = {
    AND?: PluginScalarWhereInput | PluginScalarWhereInput[]
    OR?: PluginScalarWhereInput[]
    NOT?: PluginScalarWhereInput | PluginScalarWhereInput[]
    id?: StringFilter<"Plugin"> | string
    creatorId?: StringFilter<"Plugin"> | string
    name?: StringFilter<"Plugin"> | string
    description?: StringFilter<"Plugin"> | string
    category?: EnumPluginCategoryFilter<"Plugin"> | $Enums.PluginCategory
    templateId?: StringFilter<"Plugin"> | string
    template?: JsonFilter<"Plugin">
    gitRepo?: StringNullableFilter<"Plugin"> | string | null
    pricingModel?: EnumPricingModelFilter<"Plugin"> | $Enums.PricingModel
    oneTimePrice?: FloatNullableFilter<"Plugin"> | number | null
    subscriptionTier?: StringNullableFilter<"Plugin"> | string | null
    usagePrice?: FloatNullableFilter<"Plugin"> | number | null
    whiteLabel?: BoolFilter<"Plugin"> | boolean
    isPublished?: BoolFilter<"Plugin"> | boolean
    isActive?: BoolFilter<"Plugin"> | boolean
    deploymentStatus?: EnumDeploymentStatusFilter<"Plugin"> | $Enums.DeploymentStatus
    deploymentUrl?: StringNullableFilter<"Plugin"> | string | null
    apiEndpoint?: StringNullableFilter<"Plugin"> | string | null
    totalInstalls?: IntFilter<"Plugin"> | number
    monthlyActiveUsers?: IntFilter<"Plugin"> | number
    totalRevenue?: FloatFilter<"Plugin"> | number
    createdAt?: DateTimeFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeFilter<"Plugin"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Plugin"> | Date | string | null
  }

  export type UserCreateWithoutCreatedPluginsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationCreateNestedManyWithoutOwnerInput
    locationAccess?: UserAdministratorCreateNestedManyWithoutUserInput
    customerAccount?: CustomerCreateNestedOneWithoutUserAccountInput
  }

  export type UserUncheckedCreateWithoutCreatedPluginsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationUncheckedCreateNestedManyWithoutOwnerInput
    locationAccess?: UserAdministratorUncheckedCreateNestedManyWithoutUserInput
    customerAccount?: CustomerUncheckedCreateNestedOneWithoutUserAccountInput
  }

  export type UserCreateOrConnectWithoutCreatedPluginsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPluginsInput, UserUncheckedCreateWithoutCreatedPluginsInput>
  }

  export type PluginPurchaseCreateWithoutPluginInput = {
    id?: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutPluginPurchasesInput
    usageRecords?: PluginUsageCreateNestedManyWithoutPurchaseInput
  }

  export type PluginPurchaseUncheckedCreateWithoutPluginInput = {
    id?: string
    customerId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
    usageRecords?: PluginUsageUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PluginPurchaseCreateOrConnectWithoutPluginInput = {
    where: PluginPurchaseWhereUniqueInput
    create: XOR<PluginPurchaseCreateWithoutPluginInput, PluginPurchaseUncheckedCreateWithoutPluginInput>
  }

  export type PluginPurchaseCreateManyPluginInputEnvelope = {
    data: PluginPurchaseCreateManyPluginInput | PluginPurchaseCreateManyPluginInput[]
    skipDuplicates?: boolean
  }

  export type PluginUsageCreateWithoutPluginInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
    purchase: PluginPurchaseCreateNestedOneWithoutUsageRecordsInput
  }

  export type PluginUsageUncheckedCreateWithoutPluginInput = {
    id?: string
    purchaseId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type PluginUsageCreateOrConnectWithoutPluginInput = {
    where: PluginUsageWhereUniqueInput
    create: XOR<PluginUsageCreateWithoutPluginInput, PluginUsageUncheckedCreateWithoutPluginInput>
  }

  export type PluginUsageCreateManyPluginInputEnvelope = {
    data: PluginUsageCreateManyPluginInput | PluginUsageCreateManyPluginInput[]
    skipDuplicates?: boolean
  }

  export type GithubCallbackCreateWithoutPluginInput = {
    id?: string
    callbackId: string
    streamUrl?: string | null
    streamStatus?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GithubCallbackUncheckedCreateWithoutPluginInput = {
    id?: string
    callbackId: string
    streamUrl?: string | null
    streamStatus?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GithubCallbackCreateOrConnectWithoutPluginInput = {
    where: GithubCallbackWhereUniqueInput
    create: XOR<GithubCallbackCreateWithoutPluginInput, GithubCallbackUncheckedCreateWithoutPluginInput>
  }

  export type GithubCallbackCreateManyPluginInputEnvelope = {
    data: GithubCallbackCreateManyPluginInput | GithubCallbackCreateManyPluginInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedPluginsInput = {
    update: XOR<UserUpdateWithoutCreatedPluginsInput, UserUncheckedUpdateWithoutCreatedPluginsInput>
    create: XOR<UserCreateWithoutCreatedPluginsInput, UserUncheckedCreateWithoutCreatedPluginsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPluginsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPluginsInput, UserUncheckedUpdateWithoutCreatedPluginsInput>
  }

  export type UserUpdateWithoutCreatedPluginsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUpdateManyWithoutOwnerNestedInput
    locationAccess?: UserAdministratorUpdateManyWithoutUserNestedInput
    customerAccount?: CustomerUpdateOneWithoutUserAccountNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPluginsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUncheckedUpdateManyWithoutOwnerNestedInput
    locationAccess?: UserAdministratorUncheckedUpdateManyWithoutUserNestedInput
    customerAccount?: CustomerUncheckedUpdateOneWithoutUserAccountNestedInput
  }

  export type PluginPurchaseUpsertWithWhereUniqueWithoutPluginInput = {
    where: PluginPurchaseWhereUniqueInput
    update: XOR<PluginPurchaseUpdateWithoutPluginInput, PluginPurchaseUncheckedUpdateWithoutPluginInput>
    create: XOR<PluginPurchaseCreateWithoutPluginInput, PluginPurchaseUncheckedCreateWithoutPluginInput>
  }

  export type PluginPurchaseUpdateWithWhereUniqueWithoutPluginInput = {
    where: PluginPurchaseWhereUniqueInput
    data: XOR<PluginPurchaseUpdateWithoutPluginInput, PluginPurchaseUncheckedUpdateWithoutPluginInput>
  }

  export type PluginPurchaseUpdateManyWithWhereWithoutPluginInput = {
    where: PluginPurchaseScalarWhereInput
    data: XOR<PluginPurchaseUpdateManyMutationInput, PluginPurchaseUncheckedUpdateManyWithoutPluginInput>
  }

  export type PluginPurchaseScalarWhereInput = {
    AND?: PluginPurchaseScalarWhereInput | PluginPurchaseScalarWhereInput[]
    OR?: PluginPurchaseScalarWhereInput[]
    NOT?: PluginPurchaseScalarWhereInput | PluginPurchaseScalarWhereInput[]
    id?: StringFilter<"PluginPurchase"> | string
    customerId?: StringFilter<"PluginPurchase"> | string
    pluginId?: StringFilter<"PluginPurchase"> | string
    purchaseType?: EnumPurchaseTypeFilter<"PluginPurchase"> | $Enums.PurchaseType
    amount?: FloatFilter<"PluginPurchase"> | number
    subscriptionStatus?: EnumSubscriptionStatusNullableFilter<"PluginPurchase"> | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
    isActive?: BoolFilter<"PluginPurchase"> | boolean
    apiKey?: StringNullableFilter<"PluginPurchase"> | string | null
    usageLimit?: IntNullableFilter<"PluginPurchase"> | number | null
    usageCount?: IntFilter<"PluginPurchase"> | number
    purchasedAt?: DateTimeFilter<"PluginPurchase"> | Date | string
    lastUsedAt?: DateTimeNullableFilter<"PluginPurchase"> | Date | string | null
  }

  export type PluginUsageUpsertWithWhereUniqueWithoutPluginInput = {
    where: PluginUsageWhereUniqueInput
    update: XOR<PluginUsageUpdateWithoutPluginInput, PluginUsageUncheckedUpdateWithoutPluginInput>
    create: XOR<PluginUsageCreateWithoutPluginInput, PluginUsageUncheckedCreateWithoutPluginInput>
  }

  export type PluginUsageUpdateWithWhereUniqueWithoutPluginInput = {
    where: PluginUsageWhereUniqueInput
    data: XOR<PluginUsageUpdateWithoutPluginInput, PluginUsageUncheckedUpdateWithoutPluginInput>
  }

  export type PluginUsageUpdateManyWithWhereWithoutPluginInput = {
    where: PluginUsageScalarWhereInput
    data: XOR<PluginUsageUpdateManyMutationInput, PluginUsageUncheckedUpdateManyWithoutPluginInput>
  }

  export type PluginUsageScalarWhereInput = {
    AND?: PluginUsageScalarWhereInput | PluginUsageScalarWhereInput[]
    OR?: PluginUsageScalarWhereInput[]
    NOT?: PluginUsageScalarWhereInput | PluginUsageScalarWhereInput[]
    id?: StringFilter<"PluginUsage"> | string
    purchaseId?: StringFilter<"PluginUsage"> | string
    pluginId?: StringFilter<"PluginUsage"> | string
    endpoint?: StringFilter<"PluginUsage"> | string
    method?: StringFilter<"PluginUsage"> | string
    statusCode?: IntFilter<"PluginUsage"> | number
    responseTime?: IntFilter<"PluginUsage"> | number
    requestSize?: IntNullableFilter<"PluginUsage"> | number | null
    responseSize?: IntNullableFilter<"PluginUsage"> | number | null
    userAgent?: StringNullableFilter<"PluginUsage"> | string | null
    ipAddress?: StringNullableFilter<"PluginUsage"> | string | null
    timestamp?: DateTimeFilter<"PluginUsage"> | Date | string
  }

  export type GithubCallbackUpsertWithWhereUniqueWithoutPluginInput = {
    where: GithubCallbackWhereUniqueInput
    update: XOR<GithubCallbackUpdateWithoutPluginInput, GithubCallbackUncheckedUpdateWithoutPluginInput>
    create: XOR<GithubCallbackCreateWithoutPluginInput, GithubCallbackUncheckedCreateWithoutPluginInput>
  }

  export type GithubCallbackUpdateWithWhereUniqueWithoutPluginInput = {
    where: GithubCallbackWhereUniqueInput
    data: XOR<GithubCallbackUpdateWithoutPluginInput, GithubCallbackUncheckedUpdateWithoutPluginInput>
  }

  export type GithubCallbackUpdateManyWithWhereWithoutPluginInput = {
    where: GithubCallbackScalarWhereInput
    data: XOR<GithubCallbackUpdateManyMutationInput, GithubCallbackUncheckedUpdateManyWithoutPluginInput>
  }

  export type GithubCallbackScalarWhereInput = {
    AND?: GithubCallbackScalarWhereInput | GithubCallbackScalarWhereInput[]
    OR?: GithubCallbackScalarWhereInput[]
    NOT?: GithubCallbackScalarWhereInput | GithubCallbackScalarWhereInput[]
    id?: StringFilter<"GithubCallback"> | string
    callbackId?: StringFilter<"GithubCallback"> | string
    streamUrl?: StringNullableFilter<"GithubCallback"> | string | null
    streamStatus?: StringNullableFilter<"GithubCallback"> | string | null
    data?: JsonNullableFilter<"GithubCallback">
    pluginId?: StringNullableFilter<"GithubCallback"> | string | null
    createdAt?: DateTimeFilter<"GithubCallback"> | Date | string
    updatedAt?: DateTimeFilter<"GithubCallback"> | Date | string
  }

  export type CustomerCreateWithoutPluginPurchasesInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCustomersInput
    userAccount?: UserCreateNestedOneWithoutCustomerAccountInput
    appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    csiRecords?: CSICreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPluginPurchasesInput = {
    id?: string
    locationId?: string | null
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPluginPurchasesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPluginPurchasesInput, CustomerUncheckedCreateWithoutPluginPurchasesInput>
  }

  export type PluginCreateWithoutPurchasesInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCreatedPluginsInput
    usageRecords?: PluginUsageCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackCreateNestedManyWithoutPluginInput
  }

  export type PluginUncheckedCreateWithoutPurchasesInput = {
    id?: string
    creatorId: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    usageRecords?: PluginUsageUncheckedCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackUncheckedCreateNestedManyWithoutPluginInput
  }

  export type PluginCreateOrConnectWithoutPurchasesInput = {
    where: PluginWhereUniqueInput
    create: XOR<PluginCreateWithoutPurchasesInput, PluginUncheckedCreateWithoutPurchasesInput>
  }

  export type PluginUsageCreateWithoutPurchaseInput = {
    id?: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
    plugin: PluginCreateNestedOneWithoutUsageRecordsInput
  }

  export type PluginUsageUncheckedCreateWithoutPurchaseInput = {
    id?: string
    pluginId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type PluginUsageCreateOrConnectWithoutPurchaseInput = {
    where: PluginUsageWhereUniqueInput
    create: XOR<PluginUsageCreateWithoutPurchaseInput, PluginUsageUncheckedCreateWithoutPurchaseInput>
  }

  export type PluginUsageCreateManyPurchaseInputEnvelope = {
    data: PluginUsageCreateManyPurchaseInput | PluginUsageCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutPluginPurchasesInput = {
    update: XOR<CustomerUpdateWithoutPluginPurchasesInput, CustomerUncheckedUpdateWithoutPluginPurchasesInput>
    create: XOR<CustomerCreateWithoutPluginPurchasesInput, CustomerUncheckedCreateWithoutPluginPurchasesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPluginPurchasesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPluginPurchasesInput, CustomerUncheckedUpdateWithoutPluginPurchasesInput>
  }

  export type CustomerUpdateWithoutPluginPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCustomersNestedInput
    userAccount?: UserUpdateOneWithoutCustomerAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPluginPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PluginUpsertWithoutPurchasesInput = {
    update: XOR<PluginUpdateWithoutPurchasesInput, PluginUncheckedUpdateWithoutPurchasesInput>
    create: XOR<PluginCreateWithoutPurchasesInput, PluginUncheckedCreateWithoutPurchasesInput>
    where?: PluginWhereInput
  }

  export type PluginUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: PluginWhereInput
    data: XOR<PluginUpdateWithoutPurchasesInput, PluginUncheckedUpdateWithoutPurchasesInput>
  }

  export type PluginUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedPluginsNestedInput
    usageRecords?: PluginUsageUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageRecords?: PluginUsageUncheckedUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUncheckedUpdateManyWithoutPluginNestedInput
  }

  export type PluginUsageUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PluginUsageWhereUniqueInput
    update: XOR<PluginUsageUpdateWithoutPurchaseInput, PluginUsageUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PluginUsageCreateWithoutPurchaseInput, PluginUsageUncheckedCreateWithoutPurchaseInput>
  }

  export type PluginUsageUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PluginUsageWhereUniqueInput
    data: XOR<PluginUsageUpdateWithoutPurchaseInput, PluginUsageUncheckedUpdateWithoutPurchaseInput>
  }

  export type PluginUsageUpdateManyWithWhereWithoutPurchaseInput = {
    where: PluginUsageScalarWhereInput
    data: XOR<PluginUsageUpdateManyMutationInput, PluginUsageUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PluginPurchaseCreateWithoutUsageRecordsInput = {
    id?: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
    customer: CustomerCreateNestedOneWithoutPluginPurchasesInput
    plugin: PluginCreateNestedOneWithoutPurchasesInput
  }

  export type PluginPurchaseUncheckedCreateWithoutUsageRecordsInput = {
    id?: string
    customerId: string
    pluginId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PluginPurchaseCreateOrConnectWithoutUsageRecordsInput = {
    where: PluginPurchaseWhereUniqueInput
    create: XOR<PluginPurchaseCreateWithoutUsageRecordsInput, PluginPurchaseUncheckedCreateWithoutUsageRecordsInput>
  }

  export type PluginCreateWithoutUsageRecordsInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCreatedPluginsInput
    purchases?: PluginPurchaseCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackCreateNestedManyWithoutPluginInput
  }

  export type PluginUncheckedCreateWithoutUsageRecordsInput = {
    id?: string
    creatorId: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    purchases?: PluginPurchaseUncheckedCreateNestedManyWithoutPluginInput
    githubCallbacks?: GithubCallbackUncheckedCreateNestedManyWithoutPluginInput
  }

  export type PluginCreateOrConnectWithoutUsageRecordsInput = {
    where: PluginWhereUniqueInput
    create: XOR<PluginCreateWithoutUsageRecordsInput, PluginUncheckedCreateWithoutUsageRecordsInput>
  }

  export type PluginPurchaseUpsertWithoutUsageRecordsInput = {
    update: XOR<PluginPurchaseUpdateWithoutUsageRecordsInput, PluginPurchaseUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<PluginPurchaseCreateWithoutUsageRecordsInput, PluginPurchaseUncheckedCreateWithoutUsageRecordsInput>
    where?: PluginPurchaseWhereInput
  }

  export type PluginPurchaseUpdateToOneWithWhereWithoutUsageRecordsInput = {
    where?: PluginPurchaseWhereInput
    data: XOR<PluginPurchaseUpdateWithoutUsageRecordsInput, PluginPurchaseUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type PluginPurchaseUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutPluginPurchasesNestedInput
    plugin?: PluginUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PluginPurchaseUncheckedUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginUpsertWithoutUsageRecordsInput = {
    update: XOR<PluginUpdateWithoutUsageRecordsInput, PluginUncheckedUpdateWithoutUsageRecordsInput>
    create: XOR<PluginCreateWithoutUsageRecordsInput, PluginUncheckedCreateWithoutUsageRecordsInput>
    where?: PluginWhereInput
  }

  export type PluginUpdateToOneWithWhereWithoutUsageRecordsInput = {
    where?: PluginWhereInput
    data: XOR<PluginUpdateWithoutUsageRecordsInput, PluginUncheckedUpdateWithoutUsageRecordsInput>
  }

  export type PluginUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedPluginsNestedInput
    purchases?: PluginPurchaseUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateWithoutUsageRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchases?: PluginPurchaseUncheckedUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUncheckedUpdateManyWithoutPluginNestedInput
  }

  export type UserCreateWithoutLocationAccessInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationCreateNestedManyWithoutOwnerInput
    customerAccount?: CustomerCreateNestedOneWithoutUserAccountInput
    createdPlugins?: PluginCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutLocationAccessInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationUncheckedCreateNestedManyWithoutOwnerInput
    customerAccount?: CustomerUncheckedCreateNestedOneWithoutUserAccountInput
    createdPlugins?: PluginUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutLocationAccessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationAccessInput, UserUncheckedCreateWithoutLocationAccessInput>
  }

  export type LocationCreateWithoutAdminUsersInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutAdminUsersInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutAdminUsersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAdminUsersInput, LocationUncheckedCreateWithoutAdminUsersInput>
  }

  export type UserUpsertWithoutLocationAccessInput = {
    update: XOR<UserUpdateWithoutLocationAccessInput, UserUncheckedUpdateWithoutLocationAccessInput>
    create: XOR<UserCreateWithoutLocationAccessInput, UserUncheckedCreateWithoutLocationAccessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLocationAccessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLocationAccessInput, UserUncheckedUpdateWithoutLocationAccessInput>
  }

  export type UserUpdateWithoutLocationAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUpdateManyWithoutOwnerNestedInput
    customerAccount?: CustomerUpdateOneWithoutUserAccountNestedInput
    createdPlugins?: PluginUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUncheckedUpdateManyWithoutOwnerNestedInput
    customerAccount?: CustomerUncheckedUpdateOneWithoutUserAccountNestedInput
    createdPlugins?: PluginUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type LocationUpsertWithoutAdminUsersInput = {
    update: XOR<LocationUpdateWithoutAdminUsersInput, LocationUncheckedUpdateWithoutAdminUsersInput>
    create: XOR<LocationCreateWithoutAdminUsersInput, LocationUncheckedCreateWithoutAdminUsersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAdminUsersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAdminUsersInput, LocationUncheckedUpdateWithoutAdminUsersInput>
  }

  export type LocationUpdateWithoutAdminUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutAdminUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateWithoutTerritoryInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutTerritoryInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutTerritoryInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutTerritoryInput, LocationUncheckedCreateWithoutTerritoryInput>
  }

  export type LocationUpsertWithoutTerritoryInput = {
    update: XOR<LocationUpdateWithoutTerritoryInput, LocationUncheckedUpdateWithoutTerritoryInput>
    create: XOR<LocationCreateWithoutTerritoryInput, LocationUncheckedCreateWithoutTerritoryInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutTerritoryInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutTerritoryInput, LocationUncheckedUpdateWithoutTerritoryInput>
  }

  export type LocationUpdateWithoutTerritoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutTerritoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateWithoutCsiRecordsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutCsiRecordsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutCsiRecordsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCsiRecordsInput, LocationUncheckedCreateWithoutCsiRecordsInput>
  }

  export type CustomerCreateWithoutCsiRecordsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCustomersInput
    userAccount?: UserCreateNestedOneWithoutCustomerAccountInput
    appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCsiRecordsInput = {
    id?: string
    locationId?: string | null
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCsiRecordsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCsiRecordsInput, CustomerUncheckedCreateWithoutCsiRecordsInput>
  }

  export type LocationUpsertWithoutCsiRecordsInput = {
    update: XOR<LocationUpdateWithoutCsiRecordsInput, LocationUncheckedUpdateWithoutCsiRecordsInput>
    create: XOR<LocationCreateWithoutCsiRecordsInput, LocationUncheckedCreateWithoutCsiRecordsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutCsiRecordsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutCsiRecordsInput, LocationUncheckedUpdateWithoutCsiRecordsInput>
  }

  export type LocationUpdateWithoutCsiRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutCsiRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CustomerUpsertWithoutCsiRecordsInput = {
    update: XOR<CustomerUpdateWithoutCsiRecordsInput, CustomerUncheckedUpdateWithoutCsiRecordsInput>
    create: XOR<CustomerCreateWithoutCsiRecordsInput, CustomerUncheckedCreateWithoutCsiRecordsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCsiRecordsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCsiRecordsInput, CustomerUncheckedUpdateWithoutCsiRecordsInput>
  }

  export type CustomerUpdateWithoutCsiRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCustomersNestedInput
    userAccount?: UserUpdateOneWithoutCustomerAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCsiRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCreateWithoutOwnedLocationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    locationAccess?: UserAdministratorCreateNestedManyWithoutUserInput
    customerAccount?: CustomerCreateNestedOneWithoutUserAccountInput
    createdPlugins?: PluginCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOwnedLocationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    locationAccess?: UserAdministratorUncheckedCreateNestedManyWithoutUserInput
    customerAccount?: CustomerUncheckedCreateNestedOneWithoutUserAccountInput
    createdPlugins?: PluginUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOwnedLocationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedLocationsInput, UserUncheckedCreateWithoutOwnedLocationsInput>
  }

  export type TerritoryCreateWithoutLocationInput = {
    id?: string
    territoryCode: string
    territoryName: string
    territoryAddress?: string | null
    territoryCity?: string | null
    territoryState?: string | null
    territoryZipCode?: string | null
    territoryPhone?: string | null
    territoryEmail?: string | null
    exclusiveRadius?: number | null
    populationServed?: number | null
    marketPenetration?: number | null
    assignedAt?: Date | string
  }

  export type TerritoryUncheckedCreateWithoutLocationInput = {
    id?: string
    territoryCode: string
    territoryName: string
    territoryAddress?: string | null
    territoryCity?: string | null
    territoryState?: string | null
    territoryZipCode?: string | null
    territoryPhone?: string | null
    territoryEmail?: string | null
    exclusiveRadius?: number | null
    populationServed?: number | null
    marketPenetration?: number | null
    assignedAt?: Date | string
  }

  export type TerritoryCreateOrConnectWithoutLocationInput = {
    where: TerritoryWhereUniqueInput
    create: XOR<TerritoryCreateWithoutLocationInput, TerritoryUncheckedCreateWithoutLocationInput>
  }

  export type CSICreateWithoutLocationInput = {
    id?: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
    customer?: CustomerCreateNestedOneWithoutCsiRecordsInput
  }

  export type CSIUncheckedCreateWithoutLocationInput = {
    id?: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    customerId?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
  }

  export type CSICreateOrConnectWithoutLocationInput = {
    where: CSIWhereUniqueInput
    create: XOR<CSICreateWithoutLocationInput, CSIUncheckedCreateWithoutLocationInput>
  }

  export type CSICreateManyLocationInputEnvelope = {
    data: CSICreateManyLocationInput | CSICreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserAdministratorCreateWithoutLocationInput = {
    id?: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
    user: UserCreateNestedOneWithoutLocationAccessInput
  }

  export type UserAdministratorUncheckedCreateWithoutLocationInput = {
    id?: string
    userId: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserAdministratorCreateOrConnectWithoutLocationInput = {
    where: UserAdministratorWhereUniqueInput
    create: XOR<UserAdministratorCreateWithoutLocationInput, UserAdministratorUncheckedCreateWithoutLocationInput>
  }

  export type UserAdministratorCreateManyLocationInputEnvelope = {
    data: UserAdministratorCreateManyLocationInput | UserAdministratorCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutLocationInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userAccount?: UserCreateNestedOneWithoutCustomerAccountInput
    appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    csiRecords?: CSICreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutLocationInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutLocationInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLocationInput, CustomerUncheckedCreateWithoutLocationInput>
  }

  export type CustomerCreateManyLocationInputEnvelope = {
    data: CustomerCreateManyLocationInput | CustomerCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutLocationInput = {
    id?: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutLocationInput = {
    id?: string
    customerId: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutLocationInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput>
  }

  export type AppointmentCreateManyLocationInputEnvelope = {
    data: AppointmentCreateManyLocationInput | AppointmentCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutLocationInput = {
    id?: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutLocationInput = {
    id?: string
    customerId: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutLocationInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutLocationInput, SubscriptionUncheckedCreateWithoutLocationInput>
  }

  export type SubscriptionCreateManyLocationInputEnvelope = {
    data: SubscriptionCreateManyLocationInput | SubscriptionCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutLocationInput = {
    id?: string
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutLocationInput = {
    id?: string
    customerId?: string | null
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutLocationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderCreateManyLocationInputEnvelope = {
    data: OrderCreateManyLocationInput | OrderCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutLocationInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutLocationInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput>
  }

  export type ProductCreateManyLocationInputEnvelope = {
    data: ProductCreateManyLocationInput | ProductCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type FranchiseFeeCreateWithoutLocationInput = {
    id?: string
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid?: boolean
    paidAt?: Date | string | null
    dueDate: Date | string
    createdAt?: Date | string
  }

  export type FranchiseFeeUncheckedCreateWithoutLocationInput = {
    id?: string
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid?: boolean
    paidAt?: Date | string | null
    dueDate: Date | string
    createdAt?: Date | string
  }

  export type FranchiseFeeCreateOrConnectWithoutLocationInput = {
    where: FranchiseFeeWhereUniqueInput
    create: XOR<FranchiseFeeCreateWithoutLocationInput, FranchiseFeeUncheckedCreateWithoutLocationInput>
  }

  export type FranchiseFeeCreateManyLocationInputEnvelope = {
    data: FranchiseFeeCreateManyLocationInput | FranchiseFeeCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedLocationsInput = {
    update: XOR<UserUpdateWithoutOwnedLocationsInput, UserUncheckedUpdateWithoutOwnedLocationsInput>
    create: XOR<UserCreateWithoutOwnedLocationsInput, UserUncheckedCreateWithoutOwnedLocationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedLocationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedLocationsInput, UserUncheckedUpdateWithoutOwnedLocationsInput>
  }

  export type UserUpdateWithoutOwnedLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: UserAdministratorUpdateManyWithoutUserNestedInput
    customerAccount?: CustomerUpdateOneWithoutUserAccountNestedInput
    createdPlugins?: PluginUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: UserAdministratorUncheckedUpdateManyWithoutUserNestedInput
    customerAccount?: CustomerUncheckedUpdateOneWithoutUserAccountNestedInput
    createdPlugins?: PluginUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TerritoryUpsertWithoutLocationInput = {
    update: XOR<TerritoryUpdateWithoutLocationInput, TerritoryUncheckedUpdateWithoutLocationInput>
    create: XOR<TerritoryCreateWithoutLocationInput, TerritoryUncheckedCreateWithoutLocationInput>
    where?: TerritoryWhereInput
  }

  export type TerritoryUpdateToOneWithWhereWithoutLocationInput = {
    where?: TerritoryWhereInput
    data: XOR<TerritoryUpdateWithoutLocationInput, TerritoryUncheckedUpdateWithoutLocationInput>
  }

  export type TerritoryUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    territoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    territoryCity?: NullableStringFieldUpdateOperationsInput | string | null
    territoryState?: NullableStringFieldUpdateOperationsInput | string | null
    territoryZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    territoryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    territoryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    populationServed?: NullableIntFieldUpdateOperationsInput | number | null
    marketPenetration?: NullableFloatFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryCode?: StringFieldUpdateOperationsInput | string
    territoryName?: StringFieldUpdateOperationsInput | string
    territoryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    territoryCity?: NullableStringFieldUpdateOperationsInput | string | null
    territoryState?: NullableStringFieldUpdateOperationsInput | string | null
    territoryZipCode?: NullableStringFieldUpdateOperationsInput | string | null
    territoryPhone?: NullableStringFieldUpdateOperationsInput | string | null
    territoryEmail?: NullableStringFieldUpdateOperationsInput | string | null
    exclusiveRadius?: NullableFloatFieldUpdateOperationsInput | number | null
    populationServed?: NullableIntFieldUpdateOperationsInput | number | null
    marketPenetration?: NullableFloatFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CSIUpsertWithWhereUniqueWithoutLocationInput = {
    where: CSIWhereUniqueInput
    update: XOR<CSIUpdateWithoutLocationInput, CSIUncheckedUpdateWithoutLocationInput>
    create: XOR<CSICreateWithoutLocationInput, CSIUncheckedCreateWithoutLocationInput>
  }

  export type CSIUpdateWithWhereUniqueWithoutLocationInput = {
    where: CSIWhereUniqueInput
    data: XOR<CSIUpdateWithoutLocationInput, CSIUncheckedUpdateWithoutLocationInput>
  }

  export type CSIUpdateManyWithWhereWithoutLocationInput = {
    where: CSIScalarWhereInput
    data: XOR<CSIUpdateManyMutationInput, CSIUncheckedUpdateManyWithoutLocationInput>
  }

  export type CSIScalarWhereInput = {
    AND?: CSIScalarWhereInput | CSIScalarWhereInput[]
    OR?: CSIScalarWhereInput[]
    NOT?: CSIScalarWhereInput | CSIScalarWhereInput[]
    id?: StringFilter<"CSI"> | string
    locationId?: StringFilter<"CSI"> | string
    score?: IntFilter<"CSI"> | number
    comment?: StringNullableFilter<"CSI"> | string | null
    source?: EnumCSISourceFilter<"CSI"> | $Enums.CSISource
    surveyType?: StringNullableFilter<"CSI"> | string | null
    customerId?: StringNullableFilter<"CSI"> | string | null
    recordedAt?: DateTimeFilter<"CSI"> | Date | string
    recordedBy?: StringNullableFilter<"CSI"> | string | null
  }

  export type UserAdministratorUpsertWithWhereUniqueWithoutLocationInput = {
    where: UserAdministratorWhereUniqueInput
    update: XOR<UserAdministratorUpdateWithoutLocationInput, UserAdministratorUncheckedUpdateWithoutLocationInput>
    create: XOR<UserAdministratorCreateWithoutLocationInput, UserAdministratorUncheckedCreateWithoutLocationInput>
  }

  export type UserAdministratorUpdateWithWhereUniqueWithoutLocationInput = {
    where: UserAdministratorWhereUniqueInput
    data: XOR<UserAdministratorUpdateWithoutLocationInput, UserAdministratorUncheckedUpdateWithoutLocationInput>
  }

  export type UserAdministratorUpdateManyWithWhereWithoutLocationInput = {
    where: UserAdministratorScalarWhereInput
    data: XOR<UserAdministratorUpdateManyMutationInput, UserAdministratorUncheckedUpdateManyWithoutLocationInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutLocationInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutLocationInput, CustomerUncheckedUpdateWithoutLocationInput>
    create: XOR<CustomerCreateWithoutLocationInput, CustomerUncheckedCreateWithoutLocationInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutLocationInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutLocationInput, CustomerUncheckedUpdateWithoutLocationInput>
  }

  export type CustomerUpdateManyWithWhereWithoutLocationInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutLocationInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    locationId?: StringNullableFilter<"Customer"> | string | null
    userId?: StringNullableFilter<"Customer"> | string | null
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    role?: EnumUserRoleFilter<"Customer"> | $Enums.UserRole
    dogName?: StringNullableFilter<"Customer"> | string | null
    dogBreed?: StringNullableFilter<"Customer"> | string | null
    dogAge?: IntNullableFilter<"Customer"> | number | null
    dogWeight?: FloatNullableFilter<"Customer"> | number | null
    allergies?: StringNullableFilter<"Customer"> | string | null
    preferredGroomer?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    squareCustomerId?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutLocationInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutLocationInput, AppointmentUncheckedUpdateWithoutLocationInput>
    create: XOR<AppointmentCreateWithoutLocationInput, AppointmentUncheckedCreateWithoutLocationInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutLocationInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutLocationInput, AppointmentUncheckedUpdateWithoutLocationInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutLocationInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutLocationInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    locationId?: StringFilter<"Appointment"> | string
    customerId?: StringFilter<"Appointment"> | string
    serviceType?: StringFilter<"Appointment"> | string
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    duration?: IntFilter<"Appointment"> | number
    price?: FloatFilter<"Appointment"> | number
    notes?: StringNullableFilter<"Appointment"> | string | null
    assignedTo?: StringNullableFilter<"Appointment"> | string | null
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    completedAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    squareOrderId?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutLocationInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutLocationInput, SubscriptionUncheckedUpdateWithoutLocationInput>
    create: XOR<SubscriptionCreateWithoutLocationInput, SubscriptionUncheckedCreateWithoutLocationInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutLocationInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutLocationInput, SubscriptionUncheckedUpdateWithoutLocationInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutLocationInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutLocationInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    locationId?: StringFilter<"Subscription"> | string
    customerId?: StringFilter<"Subscription"> | string
    packageType?: StringFilter<"Subscription"> | string
    price?: FloatFilter<"Subscription"> | number
    billingInterval?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    nextBillingDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    squareSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
  }

  export type OrderUpdateManyWithWhereWithoutLocationInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    customerId?: StringNullableFilter<"Order"> | string | null
    subtotal?: FloatFilter<"Order"> | number
    tax?: FloatFilter<"Order"> | number
    total?: FloatFilter<"Order"> | number
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    shippingAddress?: StringNullableFilter<"Order"> | string | null
    fulfilledAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    squareOrderId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutLocationInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutLocationInput, ProductUncheckedUpdateWithoutLocationInput>
    create: XOR<ProductCreateWithoutLocationInput, ProductUncheckedCreateWithoutLocationInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutLocationInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutLocationInput, ProductUncheckedUpdateWithoutLocationInput>
  }

  export type ProductUpdateManyWithWhereWithoutLocationInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutLocationInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    locationId?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    cost?: FloatNullableFilter<"Product"> | number | null
    stockQuantity?: IntFilter<"Product"> | number
    lowStockThreshold?: IntFilter<"Product"> | number
    squareItemId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type FranchiseFeeUpsertWithWhereUniqueWithoutLocationInput = {
    where: FranchiseFeeWhereUniqueInput
    update: XOR<FranchiseFeeUpdateWithoutLocationInput, FranchiseFeeUncheckedUpdateWithoutLocationInput>
    create: XOR<FranchiseFeeCreateWithoutLocationInput, FranchiseFeeUncheckedCreateWithoutLocationInput>
  }

  export type FranchiseFeeUpdateWithWhereUniqueWithoutLocationInput = {
    where: FranchiseFeeWhereUniqueInput
    data: XOR<FranchiseFeeUpdateWithoutLocationInput, FranchiseFeeUncheckedUpdateWithoutLocationInput>
  }

  export type FranchiseFeeUpdateManyWithWhereWithoutLocationInput = {
    where: FranchiseFeeScalarWhereInput
    data: XOR<FranchiseFeeUpdateManyMutationInput, FranchiseFeeUncheckedUpdateManyWithoutLocationInput>
  }

  export type FranchiseFeeScalarWhereInput = {
    AND?: FranchiseFeeScalarWhereInput | FranchiseFeeScalarWhereInput[]
    OR?: FranchiseFeeScalarWhereInput[]
    NOT?: FranchiseFeeScalarWhereInput | FranchiseFeeScalarWhereInput[]
    id?: StringFilter<"FranchiseFee"> | string
    locationId?: StringFilter<"FranchiseFee"> | string
    month?: IntFilter<"FranchiseFee"> | number
    year?: IntFilter<"FranchiseFee"> | number
    serviceRevenue?: FloatFilter<"FranchiseFee"> | number
    productRevenue?: FloatFilter<"FranchiseFee"> | number
    subscriptionRevenue?: FloatFilter<"FranchiseFee"> | number
    totalRevenue?: FloatFilter<"FranchiseFee"> | number
    franchiseFee?: FloatFilter<"FranchiseFee"> | number
    royaltyFee?: FloatFilter<"FranchiseFee"> | number
    totalFees?: FloatFilter<"FranchiseFee"> | number
    isPaid?: BoolFilter<"FranchiseFee"> | boolean
    paidAt?: DateTimeNullableFilter<"FranchiseFee"> | Date | string | null
    dueDate?: DateTimeFilter<"FranchiseFee"> | Date | string
    createdAt?: DateTimeFilter<"FranchiseFee"> | Date | string
  }

  export type LocationCreateWithoutCustomersInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutCustomersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCustomersInput, LocationUncheckedCreateWithoutCustomersInput>
  }

  export type UserCreateWithoutCustomerAccountInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationCreateNestedManyWithoutOwnerInput
    locationAccess?: UserAdministratorCreateNestedManyWithoutUserInput
    createdPlugins?: PluginCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCustomerAccountInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    clerkUserId: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    hasCustomerAccount?: boolean
    ownedLocations?: LocationUncheckedCreateNestedManyWithoutOwnerInput
    locationAccess?: UserAdministratorUncheckedCreateNestedManyWithoutUserInput
    createdPlugins?: PluginUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCustomerAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerAccountInput, UserUncheckedCreateWithoutCustomerAccountInput>
  }

  export type AppointmentCreateWithoutCustomerInput = {
    id?: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutCustomerInput = {
    id?: string
    locationId: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutCustomerInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput>
  }

  export type AppointmentCreateManyCustomerInputEnvelope = {
    data: AppointmentCreateManyCustomerInput | AppointmentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutCustomerInput = {
    id?: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutCustomerInput = {
    id?: string
    locationId: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionCreateManyCustomerInputEnvelope = {
    data: SubscriptionCreateManyCustomerInput | SubscriptionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    locationId: string
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CSICreateWithoutCustomerInput = {
    id?: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
    location: LocationCreateNestedOneWithoutCsiRecordsInput
  }

  export type CSIUncheckedCreateWithoutCustomerInput = {
    id?: string
    locationId: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
  }

  export type CSICreateOrConnectWithoutCustomerInput = {
    where: CSIWhereUniqueInput
    create: XOR<CSICreateWithoutCustomerInput, CSIUncheckedCreateWithoutCustomerInput>
  }

  export type CSICreateManyCustomerInputEnvelope = {
    data: CSICreateManyCustomerInput | CSICreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PluginPurchaseCreateWithoutCustomerInput = {
    id?: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
    plugin: PluginCreateNestedOneWithoutPurchasesInput
    usageRecords?: PluginUsageCreateNestedManyWithoutPurchaseInput
  }

  export type PluginPurchaseUncheckedCreateWithoutCustomerInput = {
    id?: string
    pluginId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
    usageRecords?: PluginUsageUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PluginPurchaseCreateOrConnectWithoutCustomerInput = {
    where: PluginPurchaseWhereUniqueInput
    create: XOR<PluginPurchaseCreateWithoutCustomerInput, PluginPurchaseUncheckedCreateWithoutCustomerInput>
  }

  export type PluginPurchaseCreateManyCustomerInputEnvelope = {
    data: PluginPurchaseCreateManyCustomerInput | PluginPurchaseCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutCustomersInput = {
    update: XOR<LocationUpdateWithoutCustomersInput, LocationUncheckedUpdateWithoutCustomersInput>
    create: XOR<LocationCreateWithoutCustomersInput, LocationUncheckedCreateWithoutCustomersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutCustomersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutCustomersInput, LocationUncheckedUpdateWithoutCustomersInput>
  }

  export type LocationUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserUpsertWithoutCustomerAccountInput = {
    update: XOR<UserUpdateWithoutCustomerAccountInput, UserUncheckedUpdateWithoutCustomerAccountInput>
    create: XOR<UserCreateWithoutCustomerAccountInput, UserUncheckedCreateWithoutCustomerAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerAccountInput, UserUncheckedUpdateWithoutCustomerAccountInput>
  }

  export type UserUpdateWithoutCustomerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUpdateManyWithoutOwnerNestedInput
    locationAccess?: UserAdministratorUpdateManyWithoutUserNestedInput
    createdPlugins?: PluginUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clerkUserId?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasCustomerAccount?: BoolFieldUpdateOperationsInput | boolean
    ownedLocations?: LocationUncheckedUpdateManyWithoutOwnerNestedInput
    locationAccess?: UserAdministratorUncheckedUpdateManyWithoutUserNestedInput
    createdPlugins?: PluginUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutCustomerInput, AppointmentUncheckedUpdateWithoutCustomerInput>
    create: XOR<AppointmentCreateWithoutCustomerInput, AppointmentUncheckedCreateWithoutCustomerInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutCustomerInput, AppointmentUncheckedUpdateWithoutCustomerInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutCustomerInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutCustomerInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CSIUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CSIWhereUniqueInput
    update: XOR<CSIUpdateWithoutCustomerInput, CSIUncheckedUpdateWithoutCustomerInput>
    create: XOR<CSICreateWithoutCustomerInput, CSIUncheckedCreateWithoutCustomerInput>
  }

  export type CSIUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CSIWhereUniqueInput
    data: XOR<CSIUpdateWithoutCustomerInput, CSIUncheckedUpdateWithoutCustomerInput>
  }

  export type CSIUpdateManyWithWhereWithoutCustomerInput = {
    where: CSIScalarWhereInput
    data: XOR<CSIUpdateManyMutationInput, CSIUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PluginPurchaseUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PluginPurchaseWhereUniqueInput
    update: XOR<PluginPurchaseUpdateWithoutCustomerInput, PluginPurchaseUncheckedUpdateWithoutCustomerInput>
    create: XOR<PluginPurchaseCreateWithoutCustomerInput, PluginPurchaseUncheckedCreateWithoutCustomerInput>
  }

  export type PluginPurchaseUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PluginPurchaseWhereUniqueInput
    data: XOR<PluginPurchaseUpdateWithoutCustomerInput, PluginPurchaseUncheckedUpdateWithoutCustomerInput>
  }

  export type PluginPurchaseUpdateManyWithWhereWithoutCustomerInput = {
    where: PluginPurchaseScalarWhereInput
    data: XOR<PluginPurchaseUpdateManyMutationInput, PluginPurchaseUncheckedUpdateManyWithoutCustomerInput>
  }

  export type LocationCreateWithoutFranchiseFeesInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutFranchiseFeesInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutFranchiseFeesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutFranchiseFeesInput, LocationUncheckedCreateWithoutFranchiseFeesInput>
  }

  export type LocationUpsertWithoutFranchiseFeesInput = {
    update: XOR<LocationUpdateWithoutFranchiseFeesInput, LocationUncheckedUpdateWithoutFranchiseFeesInput>
    create: XOR<LocationCreateWithoutFranchiseFeesInput, LocationUncheckedCreateWithoutFranchiseFeesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutFranchiseFeesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutFranchiseFeesInput, LocationUncheckedUpdateWithoutFranchiseFeesInput>
  }

  export type LocationUpdateWithoutFranchiseFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutFranchiseFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutAppointmentsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAppointmentsInput, LocationUncheckedCreateWithoutAppointmentsInput>
  }

  export type CustomerCreateWithoutAppointmentsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCustomersInput
    userAccount?: UserCreateNestedOneWithoutCustomerAccountInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    csiRecords?: CSICreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    locationId?: string | null
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAppointmentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAppointmentsInput, CustomerUncheckedCreateWithoutAppointmentsInput>
  }

  export type LocationUpsertWithoutAppointmentsInput = {
    update: XOR<LocationUpdateWithoutAppointmentsInput, LocationUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<LocationCreateWithoutAppointmentsInput, LocationUncheckedCreateWithoutAppointmentsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAppointmentsInput, LocationUncheckedUpdateWithoutAppointmentsInput>
  }

  export type LocationUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CustomerUpsertWithoutAppointmentsInput = {
    update: XOR<CustomerUpdateWithoutAppointmentsInput, CustomerUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<CustomerCreateWithoutAppointmentsInput, CustomerUncheckedCreateWithoutAppointmentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAppointmentsInput, CustomerUncheckedUpdateWithoutAppointmentsInput>
  }

  export type CustomerUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCustomersNestedInput
    userAccount?: UserUpdateOneWithoutCustomerAccountNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LocationCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutSubscriptionsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutSubscriptionsInput, LocationUncheckedCreateWithoutSubscriptionsInput>
  }

  export type CustomerCreateWithoutSubscriptionsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCustomersInput
    userAccount?: UserCreateNestedOneWithoutCustomerAccountInput
    appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    csiRecords?: CSICreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    locationId?: string | null
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSubscriptionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
  }

  export type LocationUpsertWithoutSubscriptionsInput = {
    update: XOR<LocationUpdateWithoutSubscriptionsInput, LocationUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<LocationCreateWithoutSubscriptionsInput, LocationUncheckedCreateWithoutSubscriptionsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutSubscriptionsInput, LocationUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type LocationUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CustomerUpsertWithoutSubscriptionsInput = {
    update: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<CustomerCreateWithoutSubscriptionsInput, CustomerUncheckedCreateWithoutSubscriptionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSubscriptionsInput, CustomerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CustomerUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCustomersNestedInput
    userAccount?: UserUpdateOneWithoutCustomerAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LocationCreateWithoutProductsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutProductsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProductsInput, LocationUncheckedCreateWithoutProductsInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    discount?: string | null
    quantity: number
    price: number
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    discount?: string | null
    quantity: number
    price: number
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutProductsInput = {
    update: XOR<LocationUpdateWithoutProductsInput, LocationUncheckedUpdateWithoutProductsInput>
    create: XOR<LocationCreateWithoutProductsInput, LocationUncheckedCreateWithoutProductsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutProductsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutProductsInput, LocationUncheckedUpdateWithoutProductsInput>
  }

  export type LocationUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    discount?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
  }

  export type LocationCreateWithoutOrdersInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedLocationsInput
    territory?: TerritoryCreateNestedOneWithoutLocationInput
    csiRecords?: CSICreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorCreateNestedManyWithoutLocationInput
    customers?: CustomerCreateNestedManyWithoutLocationInput
    appointments?: AppointmentCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionCreateNestedManyWithoutLocationInput
    products?: ProductCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    ownerId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    territory?: TerritoryUncheckedCreateNestedOneWithoutLocationInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutLocationInput
    adminUsers?: UserAdministratorUncheckedCreateNestedManyWithoutLocationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutLocationInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutLocationInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutLocationInput
    products?: ProductUncheckedCreateNestedManyWithoutLocationInput
    franchiseFees?: FranchiseFeeUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOrdersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCustomersInput
    userAccount?: UserCreateNestedOneWithoutCustomerAccountInput
    appointments?: AppointmentCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCustomerInput
    csiRecords?: CSICreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    locationId?: string | null
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutCustomerInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
    csiRecords?: CSIUncheckedCreateNestedManyWithoutCustomerInput
    pluginPurchases?: PluginPurchaseUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    discount?: string | null
    quantity: number
    price: number
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    discount?: string | null
    quantity: number
    price: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutOrdersInput = {
    update: XOR<LocationUpdateWithoutOrdersInput, LocationUncheckedUpdateWithoutOrdersInput>
    create: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutOrdersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutOrdersInput, LocationUncheckedUpdateWithoutOrdersInput>
  }

  export type LocationUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedLocationsNestedInput
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCustomersNestedInput
    userAccount?: UserUpdateOneWithoutCustomerAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    locationId: string
    customerId?: string | null
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    locationId?: string | null
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginCreateWithoutGithubCallbacksInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCreatedPluginsInput
    purchases?: PluginPurchaseCreateNestedManyWithoutPluginInput
    usageRecords?: PluginUsageCreateNestedManyWithoutPluginInput
  }

  export type PluginUncheckedCreateWithoutGithubCallbacksInput = {
    id?: string
    creatorId: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    purchases?: PluginPurchaseUncheckedCreateNestedManyWithoutPluginInput
    usageRecords?: PluginUsageUncheckedCreateNestedManyWithoutPluginInput
  }

  export type PluginCreateOrConnectWithoutGithubCallbacksInput = {
    where: PluginWhereUniqueInput
    create: XOR<PluginCreateWithoutGithubCallbacksInput, PluginUncheckedCreateWithoutGithubCallbacksInput>
  }

  export type PluginUpsertWithoutGithubCallbacksInput = {
    update: XOR<PluginUpdateWithoutGithubCallbacksInput, PluginUncheckedUpdateWithoutGithubCallbacksInput>
    create: XOR<PluginCreateWithoutGithubCallbacksInput, PluginUncheckedCreateWithoutGithubCallbacksInput>
    where?: PluginWhereInput
  }

  export type PluginUpdateToOneWithWhereWithoutGithubCallbacksInput = {
    where?: PluginWhereInput
    data: XOR<PluginUpdateWithoutGithubCallbacksInput, PluginUncheckedUpdateWithoutGithubCallbacksInput>
  }

  export type PluginUpdateWithoutGithubCallbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedPluginsNestedInput
    purchases?: PluginPurchaseUpdateManyWithoutPluginNestedInput
    usageRecords?: PluginUsageUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateWithoutGithubCallbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchases?: PluginPurchaseUncheckedUpdateManyWithoutPluginNestedInput
    usageRecords?: PluginUsageUncheckedUpdateManyWithoutPluginNestedInput
  }

  export type LocationCreateManyOwnerInput = {
    id?: string
    name: string
    address: string
    city: string
    state: string
    zipCode: string
    phone: string
    email: string
    isActive?: boolean
    franchiseId?: string | null
    franchiseFeeRate?: number | null
    royaltyRate?: number | null
    timezone?: string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: number | null
    lastCSIUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAdministratorCreateManyUserInput = {
    id?: string
    locationId: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PluginCreateManyCreatorInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PluginCategory
    templateId: string
    template: JsonNullValueInput | InputJsonValue
    gitRepo?: string | null
    pricingModel?: $Enums.PricingModel
    oneTimePrice?: number | null
    subscriptionTier?: string | null
    usagePrice?: number | null
    whiteLabel?: boolean
    isPublished?: boolean
    isActive?: boolean
    deploymentStatus?: $Enums.DeploymentStatus
    deploymentUrl?: string | null
    apiEndpoint?: string | null
    totalInstalls?: number
    monthlyActiveUsers?: number
    totalRevenue?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type LocationUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUpdateManyWithoutLocationNestedInput
    customers?: CustomerUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    products?: ProductUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUncheckedUpdateOneWithoutLocationNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutLocationNestedInput
    adminUsers?: UserAdministratorUncheckedUpdateManyWithoutLocationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutLocationNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutLocationNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    products?: ProductUncheckedUpdateManyWithoutLocationNestedInput
    franchiseFees?: FranchiseFeeUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    franchiseFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    royaltyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: StringFieldUpdateOperationsInput | string
    businessHours?: NullableJsonNullValueInput | InputJsonValue
    currentCSIAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCSIUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAdministratorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneRequiredWithoutAdminUsersNestedInput
  }

  export type UserAdministratorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdministratorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PluginUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchases?: PluginPurchaseUpdateManyWithoutPluginNestedInput
    usageRecords?: PluginUsageUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchases?: PluginPurchaseUncheckedUpdateManyWithoutPluginNestedInput
    usageRecords?: PluginUsageUncheckedUpdateManyWithoutPluginNestedInput
    githubCallbacks?: GithubCallbackUncheckedUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    templateId?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    gitRepo?: NullableStringFieldUpdateOperationsInput | string | null
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    oneTimePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    subscriptionTier?: NullableStringFieldUpdateOperationsInput | string | null
    usagePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deploymentStatus?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    deploymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstalls?: IntFieldUpdateOperationsInput | number
    monthlyActiveUsers?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginPurchaseCreateManyPluginInput = {
    id?: string
    customerId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type PluginUsageCreateManyPluginInput = {
    id?: string
    purchaseId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type GithubCallbackCreateManyPluginInput = {
    id?: string
    callbackId: string
    streamUrl?: string | null
    streamStatus?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginPurchaseUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutPluginPurchasesNestedInput
    usageRecords?: PluginUsageUpdateManyWithoutPurchaseNestedInput
  }

  export type PluginPurchaseUncheckedUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageRecords?: PluginUsageUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PluginPurchaseUncheckedUpdateManyWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginUsageUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PluginPurchaseUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type PluginUsageUncheckedUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginUsageUncheckedUpdateManyWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GithubCallbackUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    callbackId?: StringFieldUpdateOperationsInput | string
    streamUrl?: NullableStringFieldUpdateOperationsInput | string | null
    streamStatus?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GithubCallbackUncheckedUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    callbackId?: StringFieldUpdateOperationsInput | string
    streamUrl?: NullableStringFieldUpdateOperationsInput | string | null
    streamStatus?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GithubCallbackUncheckedUpdateManyWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    callbackId?: StringFieldUpdateOperationsInput | string
    streamUrl?: NullableStringFieldUpdateOperationsInput | string | null
    streamStatus?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginUsageCreateManyPurchaseInput = {
    id?: string
    pluginId: string
    endpoint: string
    method: string
    statusCode: number
    responseTime: number
    requestSize?: number | null
    responseSize?: number | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type PluginUsageUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    plugin?: PluginUpdateOneRequiredWithoutUsageRecordsNestedInput
  }

  export type PluginUsageUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginUsageUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    statusCode?: IntFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    requestSize?: NullableIntFieldUpdateOperationsInput | number | null
    responseSize?: NullableIntFieldUpdateOperationsInput | number | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CSICreateManyLocationInput = {
    id?: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    customerId?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
  }

  export type UserAdministratorCreateManyLocationInput = {
    id?: string
    userId: string
    canViewFinancials?: boolean
    canManageStaff?: boolean
    canEditAppointments?: boolean
    canViewReports?: boolean
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type CustomerCreateManyLocationInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email: string
    phone: string
    role?: $Enums.UserRole
    dogName?: string | null
    dogBreed?: string | null
    dogAge?: number | null
    dogWeight?: number | null
    allergies?: string | null
    preferredGroomer?: string | null
    notes?: string | null
    squareCustomerId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyLocationInput = {
    id?: string
    customerId: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyLocationInput = {
    id?: string
    customerId: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyLocationInput = {
    id?: string
    customerId?: string | null
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyLocationInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    price: number
    cost?: number | null
    stockQuantity?: number
    lowStockThreshold?: number
    squareItemId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FranchiseFeeCreateManyLocationInput = {
    id?: string
    month: number
    year: number
    serviceRevenue: number
    productRevenue: number
    subscriptionRevenue: number
    totalRevenue: number
    franchiseFee: number
    royaltyFee: number
    totalFees: number
    isPaid?: boolean
    paidAt?: Date | string | null
    dueDate: Date | string
    createdAt?: Date | string
  }

  export type CSIUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutCsiRecordsNestedInput
  }

  export type CSIUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CSIUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdministratorUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutLocationAccessNestedInput
  }

  export type UserAdministratorUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAdministratorUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    canViewFinancials?: BoolFieldUpdateOperationsInput | boolean
    canManageStaff?: BoolFieldUpdateOperationsInput | boolean
    canEditAppointments?: BoolFieldUpdateOperationsInput | boolean
    canViewReports?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAccount?: UserUpdateOneWithoutCustomerAccountNestedInput
    appointments?: AppointmentUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutCustomerNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    csiRecords?: CSIUncheckedUpdateManyWithoutCustomerNestedInput
    pluginPurchases?: PluginPurchaseUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dogName?: NullableStringFieldUpdateOperationsInput | string | null
    dogBreed?: NullableStringFieldUpdateOperationsInput | string | null
    dogAge?: NullableIntFieldUpdateOperationsInput | number | null
    dogWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    preferredGroomer?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    squareCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    lowStockThreshold?: IntFieldUpdateOperationsInput | number
    squareItemId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseFeeUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    productRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    royaltyFee?: FloatFieldUpdateOperationsInput | number
    totalFees?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseFeeUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    productRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    royaltyFee?: FloatFieldUpdateOperationsInput | number
    totalFees?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseFeeUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    productRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    franchiseFee?: FloatFieldUpdateOperationsInput | number
    royaltyFee?: FloatFieldUpdateOperationsInput | number
    totalFees?: FloatFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyCustomerInput = {
    id?: string
    locationId: string
    serviceType: string
    scheduledAt: Date | string
    duration: number
    price: number
    notes?: string | null
    assignedTo?: string | null
    status?: $Enums.AppointmentStatus
    completedAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyCustomerInput = {
    id?: string
    locationId: string
    packageType: string
    price: number
    billingInterval: string
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    nextBillingDate?: Date | string | null
    canceledAt?: Date | string | null
    squareSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    locationId: string
    subtotal: number
    tax?: number
    total: number
    status?: $Enums.OrderStatus
    shippingAddress?: string | null
    fulfilledAt?: Date | string | null
    squareOrderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CSICreateManyCustomerInput = {
    id?: string
    locationId: string
    score: number
    comment?: string | null
    source?: $Enums.CSISource
    surveyType?: string | null
    recordedAt?: Date | string
    recordedBy?: string | null
  }

  export type PluginPurchaseCreateManyCustomerInput = {
    id?: string
    pluginId: string
    purchaseType: $Enums.PurchaseType
    amount: number
    subscriptionStatus?: $Enums.SubscriptionStatus | null
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    nextBillingDate?: Date | string | null
    isActive?: boolean
    apiKey?: string | null
    usageLimit?: number | null
    usageCount?: number
    purchasedAt?: Date | string
    lastUsedAt?: Date | string | null
  }

  export type AppointmentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    packageType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    billingInterval?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    squareOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CSIUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneRequiredWithoutCsiRecordsNestedInput
  }

  export type CSIUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CSIUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCSISourceFieldUpdateOperationsInput | $Enums.CSISource
    surveyType?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PluginPurchaseUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plugin?: PluginUpdateOneRequiredWithoutPurchasesNestedInput
    usageRecords?: PluginUsageUpdateManyWithoutPurchaseNestedInput
  }

  export type PluginPurchaseUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageRecords?: PluginUsageUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type PluginPurchaseUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    purchaseType?: EnumPurchaseTypeFieldUpdateOperationsInput | $Enums.PurchaseType
    amount?: FloatFieldUpdateOperationsInput | number
    subscriptionStatus?: NullableEnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus | null
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    purchasedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    discount?: string | null
    quantity: number
    price: number
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    discount?: string | null
    quantity: number
    price: number
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}